{"version":3,"names":[],"sources":["WasmSample.cpp","../GraphicsWASM.cpp","../Graphics.h","mem.cpp","math.cpp","math.h","FileLoadersWASM.cpp","../sample.cpp"],"sourcesContent":["// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n    // The linker synthesizes this to call constructors.\n    __wasm_call_ctors();\n}\n\n#if 0\nstatic __attribute__((always_inline)) inline void* memcpy (void *dest, const void *src, unsigned int len) {\n  char *d = (char*)dest;\n  const char *s = (const char*)src;\n  while (len--)\n    *d++ = *s++;\n  return dest;\n}\n#endif\n\n#include \"../GraphicsWASM.cpp\"\n#include \"mem.cpp\"\n#include \"math.cpp\"\n\nMemory::Allocator* wasmGraphics_GlobalAllocator = 0;\n\nexport void wasmGraphics_SetGlobalAllocator(Memory::Allocator* alloc) {\n    wasmGraphics_GlobalAllocator = alloc;\n}\n\nexport void* wasmGraphics_AllocateMem(u32 bytes) {\n\treturn wasmGraphics_GlobalAllocator->Allocate(bytes, 0, \"JS bridge\");\n}\n \nexport void wasmGraphics_ReleaseMem(void* mem) {\n    wasmGraphics_GlobalAllocator->Release(mem, \"JS bridge\");\n}\n\ntypedef void* (*fpWasmGraphicsAllocateMem)(u32 bytes);\ntypedef void (*fpWasmGraphicsReleaseMem)(void* mem);\n\nexport fpWasmGraphicsAllocateMem wasmGraphics_GetAlloceFunction() {\n    return wasmGraphics_AllocateMem;\n}\n\nexport fpWasmGraphicsReleaseMem wasmGraphics_GetReleaseFunction() {\n    return wasmGraphics_ReleaseMem;\n}\n\n#include \"FileLoadersWASM.cpp\"\n#include \"../sample.cpp\"\n\nexport void StartSample(Graphics::Device* gfx) {\n    Graphics::Dependencies deps;\n    deps.Request = wasmGraphics_AllocateMem;\n    deps.Release = wasmGraphics_ReleaseMem;\n    GraphicsAssert(gfx != 0, \"Can't have null GFX\");\n    Initialize(&deps, gfx);\n}\n\nexport void UpdateSample(Graphics::Device* gfx, float dt) {\n    Update(gfx, dt);\n}\n\nexport void RenderSample(Graphics::Device * gfx, int x, int y, int w, int h) {\n    if (isFinishedInitializing) {\n        Render(gfx, x, y, w, h);\n    }\n}\n\nexport bool wasm_ToggleAmbient() {\n\tif (ambientOnly > 0.5f) { // If 1\n\t\tambientOnly = 0.0f; \n\t\treturn false;\n\t}\n\tambientOnly = 1.0f;\n\treturn true;\n}\n\nexport bool wasm_ToggleDepth() {\n\tShowDepth = !ShowDepth;\n\treturn ShowDepth;\n}\n\nexport bool wasm_TogglePCM() {\n\tenablePCM = !enablePCM;\n\treturn enablePCM;\n}","#include \"Graphics.h\"\n\n#define graphics_xstr(a) graphics_str(a)\n#define graphics_str(a) #a\n#define graphics_location \"On line: \" graphics_xstr(__LINE__) \", in file: \" __FILE__\n\n#if _DEBUG\n\t#define GraphicsAssert(cond, msg) Graphics::Internal::Assert(cond, graphics_location, msg)\n#else\n\t#define GraphicsAssert(c, m)\n#endif\n\n#ifndef ATLAS_I32\n\t#define ATLAS_I32\n\ttypedef int i32;\n\tstatic_assert (sizeof(i32) == 4, \"i32 should be defined as a 4 byte type\");\n#endif \n\ntypedef int GLenum;\n\nextern \"C\" void wasmGraphics_Log(const char* loc, int locLen, const char* msg, int msgLen);\nextern \"C\" void wasmGraphics_SetTexturePCM(int glTextureId, int glTextureAttachTarget, int glCompareMode, int glCompareFunc);\nextern \"C\" void wasmGraphics_TextureSetData(int glTextureId, int glInternalFormat, int width, int height, int glDataFormat, int glDataFormatType, void* data, bool genMipMaps);\n//extern \"C\" void wasmGraphics_TextureSetCubemap(int glTextureId, int glInternalFormat, int width, int height, int glDataFormat, int glDataType, void* rightData, void* leftData, void* topData, void* bottomData, void* backData, void* frontData, bool genMipMaps);\nextern \"C\" void wasmGraphics_DeviceSetFaceVisibility(bool changeglcullface, bool enableCullFace, bool disableCullFace, int cullFaceType, bool changeFace, int faceWind);\nextern \"C\" void wasmGraphics_DeviceClearRGBAD(float r, float g, float b, float d);\nextern \"C\" void wasmGraphics_SetDepthState(bool changeDepthState, int depthState, bool changeDepthFunc, int func, bool changeDepthRange, float depthRangeMin, float depthRangeMax);\nextern \"C\" void wasmGraphics_DeviceClearBufferBits(bool color, bool depth);\nextern \"C\" void wasmGraphics_DeviceWriteMask(bool r, bool g, bool b, bool a, bool depth);\nextern \"C\" void wasmGraphics_SetGLBlendFuncEnabled(bool state);\nextern \"C\" void wasmGraphics_UpdateGLBlendColor(float r, float g, float b, float a);\nextern \"C\" void wasmGraphics_ChangeGLBlendFuncSame(int srcRgb, int dstRgb);\nextern \"C\" void wasmGraphics_ChangeGLBlendFuncSeperate(int srcRgb, int dstRgb, int srcAlpha, int dstAlpha);\nextern \"C\" void wasmGraphics_ChangeGLBlendEquation(int rgbEquation);\nextern \"C\" void wasmGraphics_ChangeGLBlendEquationSeparate(int rgbEquation, int alphaEquation);\nextern \"C\" void wasmGraphics_DeviceClearColor(float r, float g, float b);\nextern \"C\" void wasmGraphics_DeviceClearDepth(float depth);\nextern \"C\" void wasmGraphics_SetGLViewport(int x, int y, int w, int h);\nextern \"C\" void wasmGraphics_DeviceSetScissorState(bool enableScissor, bool disableScissor, bool updateRect, int x, int y, int w, int h);\nextern \"C\" int wasmGraphics_GLGenFrameBuffer();\nextern \"C\" void wasmGraphics_DestroyFrameBuffer(int bufferId);\nextern \"C\" int wasmGraphics_GLGenBuffer();\nextern \"C\" void wasmGraphics_GLDestroyBuffer(int bufferId);\nextern \"C\" int wasmGraphics_GLCreateVAO();\nextern \"C\" void wasmGraphics_GLDestroyVAO(int vaoID);\nextern \"C\" int wasmGraphics_CreateTexture();\nextern \"C\" void wasmGraphics_GLDestroyTexture(int texId);\nextern \"C\" void wasmGraphics_GLDestroyShader(int shaderId);\nextern \"C\" void wasmGraphics_DeviceSetRenderTarget(int frameBufferId, int numAttachments);\nextern \"C\" void wasmGraphics_DeviceDraw(int glVao, bool indexed, int instanceCount, int drawMode, int startIndex, int indexCount, int bufferType);\nextern \"C\" void wasmGraphics_VertexLayoutSet(int glVaoId, int glBufferId, int slotId, int numComponents, int type, int stride, int offset, int divisor);\nextern \"C\" void wasmGraphics_VertexLayoutSetIndexBuffer(int glVaoId, int glElementArrayBufferId);\nextern \"C\" void wasmGraphics_FramebufferAttachColor(int attachTarget, int frameBufferId, int textureId, int attachmentIndex);\nextern \"C\" void wasmGraphics_FrameBufferAttachDepth(int target, int frameBufferId, int textureId, bool pcm);\nextern \"C\" bool wasmGraphics_FrameBufferIsValid(int frameBufferId);\nextern \"C\" void wasmGraphics_FrameBufferResolveTo(int readBuffer, int drawBuffer, int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, bool colorBit, bool depthBit, int filter);\nextern \"C\" int wasmGraphics_BufferReset(int bufferId);\nextern \"C\" void wasmGraphics_BufferSet(bool indexBuffer, int bufferId, int arraySizeInByfes, void* inputArray, bool isStatic);\nextern \"C\" int wasmGraphics_ShaderGetUniform(int program, const char* name, int name_len);\nextern \"C\" int wasmGraphics_ShaderGetAttribute(int program, const char* name, int name_len);\nextern \"C\" int wasmGraphics_ResetVertexLayout(int id);\nextern \"C\" void wasmGraphics_BindVAO(int vaoId);\nextern \"C\" void wasmGraphics_DeviceBindTexture(int textureUnitEnum, int textureUnitNumber, int textureTarget, int textureId, int uniformSlot, int minFilter, int magFilter, int wrapS, int wrapT, int wrapR, bool updateSampler);\nextern \"C\" void wasmGraphics_DeviceSetUniform(int type, int slotId, int count, void* data);\nextern \"C\" void wasmGraphics_DeviceBindShader(int programId, unsigned int boundTextures);\nextern \"C\" void wasmGraphics_SetDefaultGLState();\nextern \"C\" void wasmGraphics_GetScissorAndViewport(void* scissorPtr, void* viewPtr); // Might need to make a \"SetRect\" function to support in wasm\nextern \"C\" int wasmGraphics_CompileShader(const void* vShader, int vShaderLen, const void* fShader, int fShaderLen);\n\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#standard_webgl_1_constants\n#define GL_NONE\t\t\t\t\t\t\t0\n#define GL_ZERO\t\t\t\t\t\t\t0\n#define GL_ONE\t\t\t\t\t\t\t1\n#define GL_ALWAYS\t\t\t\t\t\t0x0207\n#define GL_NEVER\t\t\t\t\t\t0x0200\n#define GL_EQUAL\t\t\t\t\t\t0x0202\n#define GL_LEQUAL\t\t\t\t\t\t0x0203\n#define GL_GREATER\t\t\t\t\t\t0x0204\n#define GL_GEQUAL\t\t\t\t\t\t0x0206\n#define GL_NOTEQUAL\t\t\t\t\t\t0x0205\n#define GL_LESS\t\t\t\t\t\t\t0x0201\n#define GL_TEXTURE0\t\t\t\t\t\t0x84C0\n#define GL_FUNC_SUBTRACT\t\t\t\t0x800A\n#define GL_FUNC_REVERSE_SUBTRACT\t\t0x800B\n#define GL_MIN\t\t\t\t\t\t\t0x8007\n#define GL_MAX\t\t\t\t\t\t\t0x8008\n#define GL_FUNC_ADD\t\t\t\t\t\t0x8006\n#define GL_SRC_COLOR\t\t\t\t\t0x0300\n#define GL_ONE_MINUS_SRC_COLOR\t\t\t0x0301\n#define GL_DST_COLOR\t\t\t\t\t0x0306\n#define GL_ONE_MINUS_DST_COLOR\t\t\t0x0307\n#define GL_SRC_ALPHA\t\t\t\t\t0x0302\n#define GL_ONE_MINUS_SRC_ALPHA\t\t\t0x0303\n#define GL_DST_ALPHA\t\t\t\t\t0x0304\n#define GL_ONE_MINUS_DST_ALPHA\t\t\t0x0305\n#define GL_CONSTANT_COLOR\t\t\t\t0x8001\n#define GL_ONE_MINUS_CONSTANT_COLOR\t\t0x8002\n#define GL_CONSTANT_ALPHA\t\t\t\t0x8003\n#define GL_ONE_MINUS_CONSTANT_ALPHA\t\t0x8004\n#define GL_SRC_ALPHA_SATURATE\t\t\t0x0308\n#define GL_TRIANGLES\t\t\t\t\t0x0004\n#define GL_POINTS\t\t\t\t\t\t0x0000\n#define GL_LINES\t\t\t\t\t\t0x0001\n#define GL_LINE_STRIP\t\t\t\t\t0x0003\n#define GL_TRIANGLE_STRIP\t\t\t\t0x0005\n#define GL_TRIANGLE_FAN\t\t\t\t\t0x0006\n#define GL_R8\t\t\t\t\t\t\t0x8229\n#define GL_RG8\t\t\t\t\t\t\t0x822B\n#define GL_RGB8\t\t\t\t\t\t\t0x8051\n#define GL_RGBA8\t\t\t\t\t\t0x8058\n#define GL_RG\t\t\t\t\t\t\t0x8227\n#define GL_R32F\t\t\t\t\t\t\t0x822E\n#define GL_RG32F\t\t\t\t\t\t0x8230\n#define GL_RGB32F\t\t\t\t\t\t0x8815\n#define GL_RGBA32F\t\t\t\t\t\t0x8814\n#define GL_DEPTH_COMPONENT24\t\t\t0x81A6\n#define GL_DEPTH_COMPONENT32F\t\t\t0x8CAC\n#define GL_DEPTH_COMPONENT16\t\t\t0x81A5\n#define GL_DEPTH_COMPONENT\t\t\t\t0x1902\n#define GL_UNSIGNED_BYTE\t\t\t\t0x1401\n#define GL_RGB\t\t\t\t\t\t\t0x1907\n#define GL_RGBA\t\t\t\t\t\t\t0x1908\n#define GL_RED\t\t\t\t\t\t\t0x1903\n#define GL_FLOAT\t\t\t\t\t\t0x1406\n#define GL_BYTE\t\t\t\t\t\t\t0x1400\n#define GL_SHORT\t\t\t\t\t\t0x1402\n#define GL_INT\t\t\t\t\t\t\t0x1404\n#define GL_UNSIGNED_INT\t\t\t\t\t0x1405\n#define GL_UNSIGNED_SHORT\t\t\t\t0x1403\t\n#define GL_TEXTURE_2D\t\t\t\t\t0x0DE1\n#define GL_COMPARE_REF_TO_TEXTURE\t\t0x884E\n#define GL_BACK\t\t\t\t\t\t\t0x0405\n#define GL_CCW\t\t\t\t\t\t\t0x0901\n#define GL_FRONT\t\t\t\t\t\t0x0404\n#define GL_FRONT_AND_BACK\t\t\t\t0x0408\n#define GL_CW\t\t\t\t\t\t\t0x0900\n#define GL_DEPTH_TEST\t\t\t\t\t0x0B71\n#define GL_NEAREST_MIPMAP_LINEAR\t\t0x2702\n#define GL_LINEAR\t\t\t\t\t\t0x2601\n#define GL_REPEAT\t\t\t\t\t\t0x2901\n#define GL_COLOR_ATTACHMENT0\t\t\t0x8CE0\n#define GL_COLOR_ATTACHMENT1\t\t\t0x8CE1\n#define GL_COLOR_ATTACHMENT2\t\t\t0x8CE2\n#define GL_COLOR_ATTACHMENT3\t\t\t0x8CE3\n#define GL_COLOR_ATTACHMENT4\t\t\t0x8CE4\n#define GL_COLOR_ATTACHMENT5\t\t\t0x8CE5\n#define GL_COLOR_ATTACHMENT6\t\t\t0x8CE6\n#define GL_COLOR_ATTACHMENT7\t\t\t0x8CE7\n#define GL_NEAREST\t\t\t\t\t\t0x2600\n#define GL_NEAREST_MIPMAP_NEAREST\t\t0x2700\n#define GL_LINEAR_MIPMAP_NEAREST\t\t0x2701\n#define GL_LINEAR_MIPMAP_LINEAR\t\t\t0x2703\n#define GL_CLAMP_TO_EDGE\t\t\t\t0x812F\n\n#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD\n#define GL_DEPTH_STENCIL\t\t\t\t0x84F9\n#define GL_DEPTH32F_STENCIL8\t\t\t0x8CAD\n\n// Helpers\nnamespace Graphics {\n\tnamespace Internal {\n\t\tvoid Assert(bool cond, const char* location, const char* msg) {\n\t\t\tif (cond == false) {\n\t\t\t\tu32 msgLen = 0;\n\t\t\t\tfor (const char* i = msg; msg != 0 && *i != '\\0'; ++i, ++msgLen);\n\t\t\t\tu32 locLen = 0;\n\t\t\t\tfor (const char* i = location; location != 0 && *i != '\\0'; ++i, ++locLen);\n\n\t\t\t\twasmGraphics_Log(location, locLen, msg, msgLen);\n\t\t\t\t__builtin_trap();\n\t\t\t}\n\t\t}\n\n\t\tstruct TextureFormatResult {\n\t\t\tGLenum dataType;\n\t\t\tGLenum dataFormat;\n\t\t};\n\n\t\tstruct ShaderCompileResult {\n\t\t\tbool success;\n\t\t\tu32 program;\n\t\t\tchar* uniforms;\n\t\t\tchar* attributes;\n\t\t\tu32 numAttribs;\n\t\t\tu32 numUniforms;\n\n\t\t\tShaderCompileResult() {\n\t\t\t\tsuccess = false;\n\t\t\t\tprogram = 0;\n\t\t\t\tuniforms = 0;\n\t\t\t\tattributes = 0;\n\t\t\t\tnumAttribs = 0;\n\t\t\t\tnumUniforms = 0;\n\t\t\t}\n\t\t};\n\n\t\tinline GLenum DepthFuncToEnum(DepthFunc f) {\n\t\t\tif (f == DepthFunc::Always) {\n\t\t\t\treturn GL_ALWAYS;\n\t\t\t}\n\t\t\telse if (f == DepthFunc::Never) {\n\t\t\t\treturn GL_NEVER;\n\t\t\t}\n\t\t\telse if (f == DepthFunc::Equal) {\n\t\t\t\treturn GL_EQUAL;\n\t\t\t}\n\t\t\telse if (f == DepthFunc::LEqual) {\n\t\t\t\treturn GL_LEQUAL;\n\t\t\t}\n\t\t\telse if (f == DepthFunc::Greater) {\n\t\t\t\treturn GL_GREATER;\n\t\t\t}\n\t\t\telse if (f == DepthFunc::GEqual) {\n\t\t\t\treturn GL_GEQUAL;\n\t\t\t}\n\t\t\telse if (f == DepthFunc::NotEqual) {\n\t\t\t\treturn GL_NOTEQUAL;\n\t\t\t}\n\n\t\t\treturn GL_LESS;\n\t\t}\n\n\t\tinline GLenum GetTextureUnit(u32 index) {\n\t\t\tGraphicsAssert(index <= 32, \"Only supports up to GL_TEXTURE16\");\n\n\t\t\treturn GL_TEXTURE0 + index;\n\t\t}\n\n\t\tinline GLenum BlendEqToEnum(BlendEquation b) {\n\t\t\tif (b == BlendEquation::Subtract) {\n\t\t\t\treturn GL_FUNC_SUBTRACT;\n\t\t\t}\n\t\t\telse if (b == BlendEquation::ReverseSubtract) {\n\t\t\t\treturn GL_FUNC_REVERSE_SUBTRACT;\n\t\t\t}\n\t\t\telse if (b == BlendEquation::Min) {\n\t\t\t\treturn GL_MIN;\n\t\t\t}\n\t\t\telse if (b == BlendEquation::Max) {\n\t\t\t\treturn GL_MAX;\n\t\t\t}\n\n\t\t\treturn GL_FUNC_ADD;\n\t\t}\n\n\t\tinline GLenum BlendfuncToEnum(BlendFunction b) {\n\t\t\tGLenum result = GL_ZERO;\n\t\t\tif (b == BlendFunction::One) {\n\t\t\t\tresult = GL_ONE;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::SrcColor) {\n\t\t\t\tresult = GL_SRC_COLOR;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::OneMinusSrcColor) {\n\t\t\t\tresult = GL_ONE_MINUS_SRC_COLOR;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::DstColor) {\n\t\t\t\tresult = GL_DST_COLOR;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::OneMinusDstColor) {\n\t\t\t\tresult = GL_ONE_MINUS_DST_COLOR;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::SrcAlpha) {\n\t\t\t\tresult = GL_SRC_ALPHA;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::OneMinusSrcAlpha) {\n\t\t\t\tresult = GL_ONE_MINUS_SRC_ALPHA;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::DstAlpha) {\n\t\t\t\tresult = GL_DST_ALPHA;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::OneMinusDstAlpha) {\n\t\t\t\tresult = GL_ONE_MINUS_DST_ALPHA;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::ConstColor) {\n\t\t\t\tresult = GL_CONSTANT_COLOR;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::OneMinusConstColor) {\n\t\t\t\tresult = GL_ONE_MINUS_CONSTANT_COLOR;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::ConstAlpha) {\n\t\t\t\tresult = GL_CONSTANT_ALPHA;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::OneMinusconstAlpha) {\n\t\t\t\tresult = GL_ONE_MINUS_CONSTANT_ALPHA;\n\t\t\t}\n\t\t\telse if (b == BlendFunction::SrcAlphaSaturate) {\n\t\t\t\tresult = GL_SRC_ALPHA_SATURATE;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tinline GLenum DrawModeToEnum(DrawMode drawMode) {\n\t\t\tGLenum mode = GL_TRIANGLES;\n\t\t\tif (drawMode == DrawMode::Points) {\n\t\t\t\tmode = GL_POINTS;\n\t\t\t}\n\t\t\telse if (drawMode == DrawMode::Lines) {\n\t\t\t\tmode = GL_LINES;\n\t\t\t}\n\t\t\telse if (drawMode == DrawMode::LineStrip) {\n\t\t\t\tmode = GL_LINE_STRIP;\n\t\t\t}\n\t\t\telse if (drawMode == DrawMode::TriangleStrip) {\n\t\t\t\tmode = GL_TRIANGLE_STRIP;\n\t\t\t}\n\t\t\telse if (drawMode == DrawMode::TriangleFan) {\n\t\t\t\tmode = GL_TRIANGLE_FAN;\n\t\t\t}\n\t\t\treturn mode;\n\t\t}\n\n\t\tinline GLenum TextureGetInternalFormatFromEnum(TextureFormat component) {\n\t\t\tif (component == TextureFormat::R8) {\n\t\t\t\treturn GL_R8;\n\t\t\t}\n\t\t\telse if (component == TextureFormat::RG8) {\n\t\t\t\treturn GL_RG8;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGB8) {\n\t\t\t\treturn GL_RGB8;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGBA8) {\n\t\t\t\treturn GL_RGBA8;\n\t\t\t}\n\n\t\t\tif (component == TextureFormat::R32F) {\n\t\t\t\treturn GL_R32F;\n\t\t\t}\n\t\t\telse if (component == TextureFormat::RG32F) {\n\t\t\t\treturn GL_RG32F;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGB32F) {\n\t\t\t\treturn GL_RGB32F;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGBA32F) {\n\t\t\t\treturn GL_RGBA32F;\n\t\t\t}\n\n\t\t\treturn GL_DEPTH_COMPONENT32F; // Default to depth i guess\n\t\t}\n\n\t\t// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml\n\t\tinline TextureFormatResult TextureGetDataFormatFromEnum(TextureFormat component) {\n\t\t\tGLenum dataFormat = GL_DEPTH_COMPONENT;\n\t\t\tGLenum dataType = GL_FLOAT; \n\n\t\t\tif (component == TextureFormat::R8) {\n\t\t\t\tdataFormat = GL_RED;\n\t\t\t\tdataType = GL_UNSIGNED_BYTE;\n\t\t\t}\n\t\t\telse if (component == TextureFormat::RG8) {\n\t\t\t\tdataFormat = GL_RG;\n\t\t\t\tdataType = GL_UNSIGNED_BYTE;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGB8) {\n\t\t\t\tdataFormat = GL_RGB;\n\t\t\t\tdataType = GL_UNSIGNED_BYTE;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGBA8) {\n\t\t\t\tdataFormat = GL_RGBA;\n\t\t\t\tdataType = GL_UNSIGNED_BYTE;\n\t\t\t}\n\n\t\t\tif (component == TextureFormat::R32F) {\n\t\t\t\tdataFormat = GL_RED;\n\t\t\t\tdataType = GL_FLOAT;\n\t\t\t}\n\t\t\telse if (component == TextureFormat::RG32F) {\n\t\t\t\tdataFormat = GL_RG;\n\t\t\t\tdataType = GL_FLOAT;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGB32F) {\n\t\t\t\tdataFormat = GL_RGB;\n\t\t\t\tdataType = GL_FLOAT;\n\t\t\t}\n\t\t\tif (component == TextureFormat::RGBA32F) {\n\t\t\t\tdataFormat = GL_RGBA;\n\t\t\t\tdataType = GL_FLOAT;\n\t\t\t}\n\t\t\t\n\t\t\tTextureFormatResult result;\n\t\t\tresult.dataFormat = dataFormat;\n\t\t\tresult.dataType = dataType;\n\t\t\treturn result;\n\t\t}\n\n\t\tinline GLenum BufferTypeToEnum(BufferType bufferType) {\n\t\t\tGLenum type = GL_FLOAT;\n\n\t\t\tif (bufferType == BufferType::Int8) {\n\t\t\t\ttype = GL_BYTE;\n\t\t\t}\n\t\t\telse if (bufferType == BufferType::UInt8) {\n\t\t\t\ttype = GL_UNSIGNED_BYTE;\n\t\t\t}\n\t\t\telse if (bufferType == BufferType::Int16) {\n\t\t\t\ttype = GL_SHORT;\n\t\t\t}\n\t\t\telse if (bufferType == BufferType::UInt16) {\n\t\t\t\ttype = GL_UNSIGNED_SHORT;\n\t\t\t}\n\t\t\telse if (bufferType == BufferType::Int32) {\n\t\t\t\ttype = GL_INT;\n\t\t\t}\n\t\t\telse if (bufferType == BufferType::UInt32) {\n\t\t\t\ttype = GL_UNSIGNED_INT;\n\t\t\t}\n\n\t\t\treturn type;\n\t\t}\n\n\t\tShaderCompileResult CompileOpenGLShader(const char* vertexSource, const char* fragmentSource, Dependencies* platform) {\n\t\t\tShaderCompileResult result;\n\t\t\tresult.program = 0;\n\n\t\t\tint vLen = 0;\n\t\t\tGraphicsAssert(vertexSource != 0, \"Empty vertex pointer\");\n\t\t\tfor (const char* i = vertexSource; *i != '\\0'; ++i, ++vLen);\n\t\t\tconst char* vp1 = vertexSource + 1;\n\t\t\tGraphicsAssert(vLen != 0, \"Empty vertex shader\");\n\n\t\t\tint fLen = 0;\n\t\t\tGraphicsAssert(fragmentSource != 0, \"Empty fragment pointer\");\n\t\t\tfor (const char* i = fragmentSource; *i != '\\0'; ++i, ++fLen);\n\t\t\tGraphicsAssert(fLen != 0, \"Empty fragment shader\");\n\n\t\t\tresult.program = wasmGraphics_CompileShader(vertexSource, vLen, fragmentSource, fLen);\n\t\t\tresult.success = result.program != 0;\n\t\t\tGraphicsAssert(result.success, \"Could not compile shader\");\n\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\n/// Texture\n/*void Graphics::Texture::SetPCM(bool pcm) {\n\tGLenum attachTarget = GL_TEXTURE_2D;\n\n\tGLenum compareMode = GL_NONE;\n\tGLenum compareFunc = GL_LEQUAL;\n\tif (pcm) {\n\t\tcompareMode = GL_COMPARE_REF_TO_TEXTURE;\n\t\tcompareFunc = GL_LEQUAL;\n\t}\n\t\n\n\twasmGraphics_SetTexturePCM(mId, attachTarget, compareMode, compareFunc);\n}*/\n\nvoid Graphics::Texture::Set(void* data, TextureFormat dataFormat, u32 width, u32 height, bool genMipMaps) {\n\tGLenum internalFormat = Internal::TextureGetInternalFormatFromEnum(mInternalFormat);\n\tInternal::TextureFormatResult f = Internal::TextureGetDataFormatFromEnum(dataFormat);\n\n\tmWidth = width;\n\tmHeight = height;\n\tmIsMipMapped = genMipMaps;\n\n\tGraphicsAssert(mWidth > 0, \"Width must be > 0\");\n\tGraphicsAssert(mHeight > 0, \"Height must be > 0\");\n\n\twasmGraphics_TextureSetData(mId, internalFormat,  width,  height, f.dataFormat, f.dataType, data, genMipMaps);\n}\n\n/// Device\n\nvoid Graphics::Device::SetFaceCulling(CullFace cull, FaceWind wind) {\n\tbool enableCullFace = false;\n\tbool disableCullFace = false;\n\tbool changeCullFace = false;\n\tGLenum cullFaceType = GL_BACK;\n\tbool changeFace = false;\n\tGLenum faceWind = GL_CCW;\n\n\tif (mFaceCulling != cull) {\n\t\tif (cull == CullFace::Back) {\n\t\t\tif (mFaceCulling == CullFace::Off) {\n\t\t\t\tenableCullFace = true;\n\t\t\t}\n\t\t\tcullFaceType = GL_BACK;\n\t\t\tchangeCullFace = true;\n\t\t}\n\t\telse if (cull == CullFace::Front) {\n\t\t\tif (mFaceCulling == CullFace::Off) {\n\t\t\t\tenableCullFace = true;\n\t\t\t}\n\t\t\tcullFaceType = GL_FRONT;\n\t\t\tchangeCullFace = true;\n\t\t}\n\t\telse if (cull == CullFace::FrontAndBack) {\n\t\t\tif (mFaceCulling == CullFace::Off) {\n\t\t\t\tenableCullFace = true;\n\t\t\t}\n\t\t\tcullFaceType = GL_FRONT_AND_BACK;\n\t\t\tchangeCullFace = true;\n\t\t}\n\t\telse { // Off\n\t\t\tif (mFaceCulling != CullFace::Off) {\n\t\t\t\tdisableCullFace = true;\n\t\t\t}\n\t\t}\n\t\tmFaceCulling = cull;\n\t}\n\n\tif (mWindingOrder != wind) {\n\t\tchangeFace = true;\n\t\tif (wind == FaceWind::CounterClockwise) {\n\t\t\tfaceWind = GL_CCW;\n\t\t}\n\t\telse {\n\t\t\tfaceWind = GL_CW;\n\t\t}\n\t\tmWindingOrder = wind;\n\t}\n\n\tif (enableCullFace || disableCullFace || changeFace || changeCullFace) {\n\t\twasmGraphics_DeviceSetFaceVisibility(changeCullFace, enableCullFace, disableCullFace, cullFaceType, changeFace, faceWind);\n\t}\n}\n\nvoid Graphics::Device::SetDepthState(bool enable, DepthFunc depthFunc, f32* depthRange) {\n\tbool changeDepthState = false;\n\tGLenum depthState = GL_DEPTH_TEST;\n\tbool changeDepthFunc = false;\n\tGLenum func = GL_NONE;\n\tbool changeDepthRange = false;\n\tfloat depthRangeMin = 0.0f;\n\tfloat depthRangeMax = 0.0f;\n\n\tif (mDepth != enable) {\n\t\tchangeDepthState = true;\n\t\tif (enable) {\n\t\t\tdepthState = GL_DEPTH_TEST;\n\t\t}\n\t\telse {\n\t\t\tdepthState = 0; // Disabled\n\t\t}\n\t\tmDepth = enable;\n\t}\n\n\tif (mDepthFunc != depthFunc) {\n\t\tchangeDepthFunc = true;\n\t\tfunc = Internal::DepthFuncToEnum(depthFunc);\n\t\tmDepthFunc = depthFunc;\n\t}\n\n\tif (depthRange != 0) {\n\t\tchangeDepthRange = true;\n\t\tmDepthRange[0] = depthRangeMin = depthRange[0];\n\t\tmDepthRange[1] = depthRangeMax = depthRange[1];\n\t}\n\n\tif (changeDepthState || changeDepthFunc || changeDepthRange) {\n\t\twasmGraphics_SetDepthState(changeDepthState, depthState, changeDepthFunc,  func,  changeDepthRange,  depthRangeMin, depthRangeMax);\n\t}\n}\n\nvoid Graphics::Device::SetBlendState(bool blend, f32* blendColor,\n\tBlendFunction blendDstRgb, BlendFunction blendDstAlpha,\n\tBlendEquation blendEquationRgb, BlendEquation blendEquationAlpha,\n\tBlendFunction blendSrcRGB, BlendFunction blendSrcAlpha) {\n\n\tif (blend != mBlend) {\n\t\tif (blend) {\n\t\t\twasmGraphics_SetGLBlendFuncEnabled(false);\n\t\t}\n\t\telse {\n\t\t\twasmGraphics_SetGLBlendFuncEnabled(true);\n\t\t}\n\t\tmBlend = blend;\n\t}\n\n\tif (blendColor != 0) {\n\t\tmBlendColor[0] = blendColor[0];\n\t\tmBlendColor[1] = blendColor[1];\n\t\tmBlendColor[2] = blendColor[2];\n\t\tmBlendColor[3] = blendColor[3];\n\t\twasmGraphics_UpdateGLBlendColor(mBlendColor[0], mBlendColor[1], mBlendColor[2], mBlendColor[3]);\n\t}\n\n\tif (mBlendDstAlpha != blendDstAlpha || mBlendDstRGB != blendDstRgb ||\n\t\tmBlendSrcAlpba != blendSrcAlpha || mBlendSrcRGB != blendSrcRGB) {\n\t\tGLenum srcAlpha = Internal::BlendfuncToEnum(blendSrcAlpha);\n\t\tGLenum srcRgb = Internal::BlendfuncToEnum(blendSrcRGB);\n\t\tGLenum dstAlpha = Internal::BlendfuncToEnum(blendDstAlpha);\n\t\tGLenum dstRgb = Internal::BlendfuncToEnum(blendDstRgb);\n\n\t\tif (blendDstAlpha == blendDstRgb && blendSrcAlpha == blendSrcRGB) { // Same\n\t\t\twasmGraphics_ChangeGLBlendFuncSame(srcRgb, dstRgb);\n\t\t}\n\t\telse { // Seperate\n\t\t\twasmGraphics_ChangeGLBlendFuncSeperate(srcRgb, dstRgb, srcAlpha, dstAlpha);\n\t\t}\n\t\tmBlendDstAlpha = blendDstAlpha;\n\t\tmBlendDstRGB = blendDstRgb;\n\t\tmBlendSrcAlpba = blendSrcAlpha;\n\t\tmBlendSrcRGB = blendSrcRGB;\n\t}\n\n\tif (mBlendEquationAlpha != blendEquationAlpha || mBlendEquationRGB != blendEquationRgb) {\n\t\tGLenum alphaEquation = Internal::BlendEqToEnum(blendEquationAlpha);\n\t\tGLenum rgbEquation = Internal::BlendEqToEnum(blendEquationRgb);\n\n\t\tif (blendEquationAlpha == blendEquationRgb) { // Same\n\t\t\twasmGraphics_ChangeGLBlendEquation(rgbEquation);\n\t\t}\n\t\telse { // Seperate\n\t\t\twasmGraphics_ChangeGLBlendEquationSeparate(rgbEquation, alphaEquation);\n\t\t}\n\n\t\tmBlendEquationAlpha = blendEquationAlpha;\n\t\tmBlendEquationRGB = blendEquationRgb;\n\t}\n}\n\nvoid Graphics::Device::Clear(f32 r, f32 g, f32 b, f32 depth) {\n\twasmGraphics_DeviceClearRGBAD(r, g, b, depth);\n}\n\nvoid Graphics::Device::Clear(bool color, bool depth) {\n\twasmGraphics_DeviceClearBufferBits(color, depth);\n}\n\nvoid Graphics::Device::WriteMask(bool r, bool g, bool b, bool a, bool depth) {\n\twasmGraphics_DeviceWriteMask(r, g, b, a, depth);\n}\n\nvoid Graphics::Device::Clear(f32 r, f32 g, f32 b) {\n\twasmGraphics_DeviceClearColor(r, g, b);\n}\n\nvoid Graphics::Device::Clear(f32 depth) {\n\twasmGraphics_DeviceClearDepth(depth);\n}\n\nvoid Graphics::Device::SetViewport(u32 x, u32 y, u32 w, u32 h) {\n\tif (x != mViewportRect[0] || y != mViewportRect[1] ||\n\t\tw != mViewportRect[2] || h != mViewportRect[3]) {\n\t\twasmGraphics_SetGLViewport(x, y, w, h);\n\t\tmViewportRect[0] = x;\n\t\tmViewportRect[1] = y;\n\t\tmViewportRect[2] = w;\n\t\tmViewportRect[3] = h;\n\t}\n}\n\nvoid Graphics::Device::SetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h) {\n\tbool enableScissor = false;\n\tbool disableScissor = false;\n\tbool updateRect = false;\n\n\n\tif (enable != mScissor) {\n\t\tif (enable) {\n\t\t\tenableScissor = true;\n\t\t}\n\t\telse {\n\t\t\tdisableScissor = true;\n\t\t}\n\n\t\tmScissor = enable;\n\t}\n\n\tif (x != mScissorRect[0] || y != mScissorRect[1] || w != mScissorRect[2] || h != mScissorRect[3]) {\n\t\tmScissorRect[0] = x;\n\t\tmScissorRect[1] = y;\n\t\tmScissorRect[2] = w;\n\t\tmScissorRect[3] = h;\n\t\tupdateRect = true;\n\t}\n\n\tif (enableScissor || disableScissor || updateRect) {\n\t\twasmGraphics_DeviceSetScissorState(enableScissor, disableScissor, updateRect, x, y, w, h);\n\t}\n}\n\nGraphics::FrameBuffer* Graphics::Device::CreateFrameBuffer() {\n\tGraphics::FrameBuffer* result = (Graphics::FrameBuffer*)mPlatform.Request(sizeof(Graphics::FrameBuffer));\n\tresult->mId = wasmGraphics_GLGenFrameBuffer();\n\tresult->mColor0 = 0;\n\tresult->mColor1 = 0;\n\tresult->mColor2 = 0;\n\tresult->mColor3 = 0;\n\tresult->mColor4 = 0;\n\tresult->mColor5 = 0;\n\tresult->mDepth = 0;\n\tresult->mUserData = 0;\n\tresult->mOwner = this;\n\tresult->mAllocPrev = 0;\n\tresult->mAllocNext = mAllocatedFrameBuffers;\n\tif (mAllocatedFrameBuffers != 0) {\n\t\tmAllocatedFrameBuffers->mAllocPrev = result;\n\t}\n\tmAllocatedFrameBuffers = result;\n\tresult->mReadBufferConfig = GL_FRONT;\n\n\treturn result;\n}\n\nvoid Graphics::Device::Destroy(FrameBuffer* buffer) {\n\twasmGraphics_DestroyFrameBuffer(buffer->mId);\n\tmBoundFrameBuffer = 0;\n\n\tif (buffer->mAllocPrev != 0) { // Not head\n\t\tbuffer->mAllocPrev->mAllocNext = buffer->mAllocNext;\n\t\tif (buffer->mAllocNext != 0) {\n\t\t\tbuffer->mAllocNext->mAllocPrev = buffer->mAllocPrev;\n\t\t}\n\t}\n\telse { // Head\n\t\tmAllocatedFrameBuffers = mAllocatedFrameBuffers->mAllocNext;\n\t\tif (mAllocatedFrameBuffers != 0) {\n\t\t\tmAllocatedFrameBuffers->mAllocPrev = 0;\n\t\t}\n\t}\n\n\tmPlatform.Release(buffer);\n}\n\nGraphics::Buffer* Graphics::Device::CreateBuffer() {\n\tGraphics::Buffer* result = (Graphics::Buffer*)mPlatform.Request(sizeof(Graphics::Buffer));\n\tresult->mId = wasmGraphics_GLGenBuffer();\n\tresult->mIndexBuffer = false;\n\tresult->mUserData = 0;\n\tresult->mOwner = this;\n\tresult->mAllocPrev = 0;\n\tresult->mAllocNext = mAllocatedBuffers;\n\tif (mAllocatedBuffers != 0) {\n\t\tmAllocatedBuffers->mAllocPrev = result;\n\t}\n\tmAllocatedBuffers = result;\n\n\treturn result;\n}\n\nGraphics::Buffer* Graphics::Device::CreateIndexBuffer() {\n\tGraphics::Buffer* result = (Graphics::Buffer*)mPlatform.Request(sizeof(Graphics::Buffer));\n\tresult->mId = wasmGraphics_GLGenBuffer();\n\tresult->mIndexBuffer = true;\n\tresult->mUserData = 0;\n\tresult->mOwner = this;\n\tresult->mAllocPrev = 0;\n\tresult->mAllocNext = mAllocatedBuffers;\n\tif (mAllocatedBuffers != 0) {\n\t\tmAllocatedBuffers->mAllocPrev = result;\n\t}\n\tmAllocatedBuffers = result;\n\n\treturn result;\n}\n\nvoid Graphics::Device::Destroy(Buffer* buff) {\n\twasmGraphics_GLDestroyBuffer(buff->mId);\n\n\tif (buff->mAllocPrev != 0) { // Not head\n\t\tbuff->mAllocPrev->mAllocNext = buff->mAllocNext;\n\t\tif (buff->mAllocNext != 0) {\n\t\t\tbuff->mAllocNext->mAllocPrev = buff->mAllocPrev;\n\t\t}\n\t}\n\telse { // Head\n\t\tmAllocatedBuffers = mAllocatedBuffers->mAllocNext;\n\t\tif (mAllocatedBuffers != 0) {\n\t\t\tmAllocatedBuffers->mAllocPrev = 0;\n\t\t}\n\t}\n\n\tmPlatform.Release(buff);\n}\n\nGraphics::VertexLayout* Graphics::Device::CreateVertexLayout() {\n\tGraphics::VertexLayout* result = (Graphics::VertexLayout*)mPlatform.Request(sizeof(Graphics::VertexLayout));\n\n\tresult->mId = wasmGraphics_GLCreateVAO();\n\tresult->mUserData = 0;\n\tresult->mIndexBufferType = Graphics::BufferType::UInt32;\n\tresult->mHasIndexBuffer = false;\n\n\tresult->mAllocPrev = 0;\n\tresult->mAllocNext = mAllocatedStates;\n\tif (mAllocatedStates != 0) {\n\t\tmAllocatedStates->mAllocPrev = result;\n\t}\n\tmAllocatedStates = result;\n\n\treturn result;\n}\n\nvoid Graphics::Device::Destroy(VertexLayout* map) {\n\twasmGraphics_GLDestroyVAO(map->mId);\n\t\n\tif (map->mAllocPrev != 0) { // Not head\n\t\tmap->mAllocPrev->mAllocNext = map->mAllocNext;\n\t\tif (map->mAllocNext != 0) {\n\t\t\tmap->mAllocNext->mAllocPrev = map->mAllocPrev;\n\t\t}\n\t}\n\telse { // Head\n\t\tmAllocatedStates = mAllocatedStates->mAllocNext;\n\t\tif (mAllocatedStates != 0) {\n\t\t\tmAllocatedStates->mAllocPrev = 0;\n\t\t}\n\t}\n\n\tmPlatform.Release(map);\n}\n\nGraphics::Texture* Graphics::Device::CreateTexture(TextureFormat format) {\n\tGraphics::Texture* result = (Graphics::Texture*)mPlatform.Request(sizeof(Graphics::Texture));\n\n\tresult->mId = wasmGraphics_CreateTexture();\n\n\tresult->mWidth = 0;\n\tresult->mHeight = 0;\n\tresult->mInternalFormat = format;\n\tresult->mIsMipMapped = false;\n\tresult->mUserData = 0;\n\n\tresult->mCachedMin = GL_NEAREST_MIPMAP_LINEAR;\n\tresult->mCachedMag = GL_LINEAR;\n\n\tresult->mCachedS = GL_REPEAT;\n\tresult->mCachedR = GL_REPEAT;\n\tresult->mCachedT = GL_REPEAT;\n\n\tresult->mOwner = this;\n\tresult->mAllocPrev = 0;\n\tresult->mAllocNext = mAllocatedTextures;\n\tif (mAllocatedTextures != 0) {\n\t\tmAllocatedTextures->mAllocPrev = result;\n\t}\n\tmAllocatedTextures = result;\n\n\treturn result;\n}\n\nvoid Graphics::Device::Destroy(Texture* buff) {\n\twasmGraphics_GLDestroyTexture(buff->mId);\n\n\tif (buff->mAllocPrev != 0) { // Not head\n\t\tbuff->mAllocPrev->mAllocNext = buff->mAllocNext;\n\t\tif (buff->mAllocNext != 0) {\n\t\t\tbuff->mAllocNext->mAllocPrev = buff->mAllocPrev;\n\t\t}\n\t}\n\telse { // Head\n\t\tmAllocatedTextures = mAllocatedTextures->mAllocNext;\n\t\tif (mAllocatedTextures != 0) {\n\t\t\tmAllocatedTextures->mAllocPrev = 0;\n\t\t}\n\t}\n\n\tmPlatform.Release(buff);\n}\n\nGraphics::Shader* Graphics::Device::CreateShader(const char* vertex, const char* fragment) {\n\tGraphics::Shader* result = 0;\n\n\tGraphics::Internal::ShaderCompileResult compileStatus =\n\tGraphics::Internal::CompileOpenGLShader(vertex, fragment, &mPlatform);\n\tGraphicsAssert(compileStatus.success, \"Failed to compile shader\");\n\n\tif (compileStatus.success) {\n\t\tresult = (Graphics::Shader*)mPlatform.Request(sizeof(Graphics::Shader));\n\t\tresult->mProgram = compileStatus.program;\n\t}\n\n\tresult->mUserData = 0;\n\tresult->mOwner = this;\n\tresult->mAllocPrev = 0;\n\tresult->mAllocNext = mAllocatedShaders;\n\tif (mAllocatedShaders != 0) {\n\t\tmAllocatedShaders->mAllocPrev = result;\n\t}\n\tmAllocatedShaders = result;\n\n\n\treturn result;\n}\n\nvoid Graphics::Device::Destroy(Shader* shader) {\n\twasmGraphics_GLDestroyShader(shader->mProgram);\n\tmBoundProgram = 0;\n\tshader->mProgram = 0;\n\n\tif (shader->mAllocPrev != 0) { // Not head\n\t\tshader->mAllocPrev->mAllocNext = shader->mAllocNext;\n\t\tif (shader->mAllocNext != 0) {\n\t\t\tshader->mAllocNext->mAllocPrev = shader->mAllocPrev;\n\t\t}\n\t}\n\telse { // Head\n\t\tmAllocatedShaders = mAllocatedShaders->mAllocNext;\n\t\tif (mAllocatedShaders != 0) {\n\t\t\tmAllocatedShaders->mAllocPrev = 0;\n\t\t}\n\t}\n\n\tmPlatform.Release(shader);\n}\n\nvoid Graphics::Device::SetRenderTarget(FrameBuffer* frameBuffer) {\n\tconst u32 attachments[8] = { \n\t\tGL_COLOR_ATTACHMENT0, \n\t\tGL_COLOR_ATTACHMENT1,\n\t\tGL_COLOR_ATTACHMENT2,\n\t\tGL_COLOR_ATTACHMENT3,\n\t\tGL_COLOR_ATTACHMENT4,\n\t\tGL_COLOR_ATTACHMENT5,\n\t\tGL_COLOR_ATTACHMENT6,\n\t\tGL_COLOR_ATTACHMENT7,\n\t};\n\n\tint frameBufferId = 0;\n\tint numAttachments = 0;\n\n\tif (frameBuffer != 0) {\n\t\tframeBufferId = frameBuffer->mId;\n\t\tmBoundFrameBuffer = frameBuffer->mId;\n\t\tnumAttachments = frameBuffer->TargetCount();\n\t\tif (numAttachments == 0) {\n\t\t\tframeBuffer->mReadBufferConfig = GL_NONE;\n\t\t}\n\t\telse {\n\t\t\tframeBuffer->mReadBufferConfig = GL_FRONT;\n\t\t}\n\t\tGraphicsAssert(numAttachments <= 8, \"Only supports up to 8 color attachments\");\n\t}\n\telse if (mBoundFrameBuffer != 0) {\n\t\tconst u32 back_attach[1] = {GL_BACK};\n\t\tframeBufferId = 0;\n\t\tmBoundFrameBuffer = 0;\n\t\tnumAttachments = 1;\n\t}\n\n\twasmGraphics_DeviceSetRenderTarget(frameBufferId, numAttachments);\n}\n\nvoid Graphics::Device::Bind(Shader* shader) {\n\tu32 program = 0;\n\tif (shader != 0) {\n\t\tprogram = shader->mProgram;\n\t}\n\t\n\tif (mBoundProgram != program) {\n\t\tmBoundProgram = program;\n\t\tu32 bound = 0;\n\t\t{  // Unbind any previously bound textures\n\t\t\tfor (u32 i = 0; i < 32; ++i) {\n\t\t\t\tif (mBoundTextures[i].texture != 0) {\n\t\t\t\t\tmBoundTextures[i].texture = 0;\n\t\t\t\t\tmBoundTextures[i].target = 0;\n\t\t\t\t\tmBoundTextures[i].index.id = 0;\n\t\t\t\t\tmBoundTextures[i].index.valid = false;\n\t\t\t\t\tbound |= (1U << i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twasmGraphics_DeviceBindShader(program, bound);\n\t}\n}\n\nvoid Graphics::Device::Bind(Index& slot, UniformType type, void* data, u32 count) {\n\tGraphicsAssert(slot.valid, \"Setting invalid uniform\");\n\tGraphicsAssert(slot.valid || (!slot.valid && slot.id != 0), \"Something messed with slot\");\n\tGraphicsAssert(slot.shader == mBoundProgram, \"Binding index to wrong shader\");\n\twasmGraphics_DeviceSetUniform((int)type, slot.id, count, data);\n}\n\nvoid Graphics::Device::Bind(Index& uniformSlot, Texture& texture, Sampler& sampler) {\n\tGLenum min = GL_NEAREST;\n\tGLenum mag = GL_LINEAR;\n\n\tif (texture.mIsMipMapped) {\n\t\tif (sampler.min == Filter::Nearest) {\n\t\t\tif (sampler.mip == Filter::Nearest) {\n\t\t\t\tmin = GL_NEAREST_MIPMAP_NEAREST;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin = GL_NEAREST_MIPMAP_LINEAR;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (sampler.mip == Filter::Nearest) {\n\t\t\t\tmin = GL_LINEAR_MIPMAP_NEAREST;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin = GL_LINEAR_MIPMAP_LINEAR;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (sampler.min == Filter::Linear) {\n\t\t\tmin = GL_LINEAR;\n\t\t}\n\t\telse {\n\t\t\tmin = GL_NEAREST;\n\t\t}\n\t}\n\n\tif (sampler.mag == Filter::Nearest) {\n\t\tmag = GL_NEAREST;\n\t}\n\n\tGLenum wrapS = GL_REPEAT;\n\tGLenum wrapT = GL_REPEAT;\n\n\tif (sampler.wrapS == WrapMode::Clamp) {\n\t\twrapS = GL_CLAMP_TO_EDGE;\n\t}\n\n\tif (sampler.wrapT == WrapMode::Clamp) {\n\t\twrapT = GL_CLAMP_TO_EDGE;\n\t}\n\n\tGLenum target = GL_TEXTURE_2D;\n\n\t// Find texture unit\n\tu32 textureUnit = 33;\n\tu32 firstFree = 33;\n\tfor (u32 i = 0; i < 32; ++i) {\n\t\tif (mBoundTextures[i].texture != 0) { // Something is bound\n\t\t\tif (mBoundTextures[i].index.valid && mBoundTextures[i].index.id == uniformSlot.id) { // Re-use\n\t\t\t\ttextureUnit = i;\n\t\t\t\tGraphicsAssert(target == mBoundTextures[i].target, \"Binding invalid texture types\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (firstFree == 33) {\n\t\t\tGraphicsAssert(!mBoundTextures[i].index.valid, \"free slot should not be valid\");\n\t\t\tfirstFree = i;\n\t\t}\n\t}\n\tif (textureUnit == 33) {\n\t\ttextureUnit = firstFree;\n\t\tmBoundTextures[firstFree].index = uniformSlot;\n\t\tGraphicsAssert(mBoundTextures[firstFree].index.valid, \"Found invalid index\");\n\t\tmBoundTextures[firstFree].target = target;\n\t\tmBoundTextures[firstFree].texture = &texture;\n\t}\n\tGraphicsAssert(textureUnit < 33, \"Invalid texture unit\");\n\n\t\n\tGLenum enumTextureUnit = Internal::GetTextureUnit(textureUnit);\n\n\tbool updateSampler = false;\n\t// Set min and mag filter\n\tif (texture.mCachedMin != min) {\n\t\tupdateSampler = true;\n\t\ttexture.mCachedMin = min;\n\t}\n\tif (texture.mCachedMag != mag) {\n\t\tupdateSampler = true;\n\t\ttexture.mCachedMag = mag;\n\t}\n\n\t// Set Wrap Mode\n\tif (texture.mCachedS != wrapS) {\n\t\tupdateSampler = true;\n\t\ttexture.mCachedS = wrapS;\n\t}\n\tif (texture.mCachedT != wrapT) {\n\t\tupdateSampler = true;\n\t\ttexture.mCachedT = wrapT;\n\t}\n\n\twasmGraphics_DeviceBindTexture(enumTextureUnit, textureUnit, target, texture.mId, uniformSlot.id, min, mag, wrapS, wrapT, wrapT, updateSampler);\n}\n\nvoid Graphics::Device::Draw(const VertexLayout& attributes, DrawMode drawMode, u32 startIndex, u32 indexCount, u32 instanceCount) {\n\tGLenum type = Internal::BufferTypeToEnum(attributes.mIndexBufferType);\n\tGLenum _drawMode = Internal::DrawModeToEnum(drawMode);\n\n\twasmGraphics_DeviceDraw(attributes.mId, attributes.mHasIndexBuffer, instanceCount, _drawMode, startIndex, indexCount, type);\n}\n\nGraphics::Device* Graphics::Initialize(Device& outDevice, Dependencies& alloc) {\n\toutDevice.mPlatform = alloc;\n\toutDevice.mBoundProgram = 0;\n\toutDevice.mBoundFrameBuffer = 0;\n\n\tfor (u32 i = 0; i < 32; ++i) {\n\t\toutDevice.mBoundTextures[i].index.id = 0;\n\t\toutDevice.mBoundTextures[i].index.valid = false;\n\t\toutDevice.mBoundTextures[i].texture = 0;\n\t\toutDevice.mBoundTextures[i].target = 0;\n\t}\n\t\n\toutDevice.mUserData = 0;\n\toutDevice.mAllocatedTextures = 0;\n\toutDevice.mAllocatedBuffers = 0;\n\toutDevice.mAllocatedStates = 0;\n\toutDevice.mAllocatedShaders = 0;\n\toutDevice.mAllocatedFrameBuffers = 0;\n\n\t// Blend State\n\toutDevice.mBlend = false;\n\n\toutDevice.mBlendColor[0] = 0.0f;\n\toutDevice.mBlendColor[1] = 0.0f;\n\toutDevice.mBlendColor[2] = 0.0f;\n\toutDevice.mBlendColor[3] = 0.0f;\n\n\toutDevice.mBlendSrcAlpba = BlendFunction::One;\n\toutDevice.mBlendSrcRGB = BlendFunction::One;\n\toutDevice.mBlendDstAlpha = BlendFunction::Zero;\n\toutDevice.mBlendDstRGB = BlendFunction::Zero;\n\n\toutDevice.mBlendEquationAlpha = BlendEquation::Add;\n\toutDevice.mBlendEquationRGB = BlendEquation::Add;\n\n\t// Cull state\n\toutDevice.mFaceCulling = CullFace::Back;\n\toutDevice.mWindingOrder = FaceWind::CounterClockwise;\n\t\n\t// Depth state\n\toutDevice.mDepth = true;\n\toutDevice.mDepthFunc = DepthFunc::Less;\n\toutDevice.mDepthRange[0] = 0.0f;\n\toutDevice.mDepthRange[1] = 1.0f;\n\n\t// Scissor state\n\twasmGraphics_SetDefaultGLState();\n\twasmGraphics_GetScissorAndViewport(outDevice.mScissorRect, outDevice.mViewportRect);\n\toutDevice.mScissor = false;\n\n\treturn &outDevice;\n}\n\nvoid Graphics::Shutdown(Device& device) {\n\tdevice.Bind(0);\n\twasmGraphics_BindVAO(0);\n\n\tGraphicsAssert(device.mAllocatedTextures == 0, \"Not all memory has been released\");\n\tGraphicsAssert(device.mAllocatedBuffers == 0, \"Not all memory has been released\");\n\tGraphicsAssert(device.mAllocatedStates == 0, \"Not all memory has been released\");\n\tGraphicsAssert(device.mAllocatedShaders == 0, \"Not all memory has been released\");\n\tGraphicsAssert(device.mAllocatedFrameBuffers == 0, \"Not all memory has been released\");\n\n\tdevice.mPlatform.Request = 0;\n\tdevice.mPlatform.Release = 0;\n}\n\n// Pipeline state\nvoid Graphics::VertexLayout::Set(const Index& index, const Buffer& buffer, const BufferView& view, u32 instanceDivisor) {\n\tGLenum type = Internal::BufferTypeToEnum(view.Type);\n\twasmGraphics_VertexLayoutSet(mId, buffer.mId, index.id, view.NumberOfComponents, type, view.StrideInBytes, view.DataOffsetInBytes, instanceDivisor);\n}\n\nvoid Graphics::VertexLayout::Set(const Buffer& indexBuffer, const BufferType& indexType) {\n\tmHasIndexBuffer = true;\n\tmIndexBufferType = indexType;\n\twasmGraphics_VertexLayoutSetIndexBuffer(mId, indexBuffer.mId);\n}\n\nvoid Graphics::VertexLayout::Reset() {\n\tmHasIndexBuffer = false;\n\tmId = wasmGraphics_ResetVertexLayout(mId);\n}\n\n// Shader\n\nGraphics::Index Graphics::Shader::GetAttribute(const char* name) {\n\tu32 wasmLen = 0;\n\tfor (const char* i = name; name != 0 && *i != '\\0'; ++i, ++wasmLen);\n\n\tint location = wasmGraphics_ShaderGetAttribute(mProgram, name, wasmLen);\n\tIndex result(0, false, mProgram);\n\n\tif (location >= 0) {\n\t\tresult = Index(location, true, mProgram);\n\t}\n\n\treturn result;\n}\n\nGraphics::Index Graphics::Shader::GetUniform(const char* name) {\n\tu32 wasmLen = 0;\n\tfor (const char* i = name; name != 0 && *i != '\\0'; ++i, ++wasmLen);\n\n\tint location = wasmGraphics_ShaderGetUniform(mProgram, name, wasmLen);\n\tIndex result(0, false, mProgram);\n\n\tif (location >= 0) {\n\t\tresult = Index(location, true, mProgram);\n\t}\n\n\treturn result;\n}\n\n\n/// Buffer\n\nvoid Graphics::Buffer::Set(void* inputArray, u32 arraySizeInBytes, bool _static) {\n\twasmGraphics_BufferSet(mIndexBuffer, mId, arraySizeInBytes, inputArray, _static);\n}\n\nvoid Graphics::Buffer::Reset() {\n\tmId = wasmGraphics_BufferReset(mId);\n}\n\nu32 Graphics::FrameBuffer::TargetCount() {\n\tu32 count = 0;\n\tfor (u32 i = 0; i < 6; ++i) {\n\t\tif (mColor[i] != 0) {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn count;\n}\n\nu32 Graphics::FrameBuffer::GetWidth() {\n\tfor (u32 i = 0; i < 6; ++i) {\n\t\tif (mColor[i] != 0) {\n\t\t\treturn mColor[i]->GetWidth();\n\t\t}\n\t}\n\tif (mDepth != 0) {\n\t\treturn mDepth->GetWidth();\n\t}\n\treturn 0;\n}\n\nu32 Graphics::FrameBuffer::GetHeight() {\n\tfor (u32 i = 0; i < 6; ++i) {\n\t\tif (mColor[i] != 0) {\n\t\t\treturn mColor[i]->GetHeight();\n\t\t}\n\t}\n\tif (mDepth != 0) {\n\t\treturn mDepth->GetHeight();\n\t}\n\treturn 0;\n}\n\n/// Frame Buffer\nvoid Graphics::FrameBuffer::AttachColor(Texture& color, u32 attachmentIndex) {\n\tif (attachmentIndex > 5) { // Limit to 6 color attachments\n\t\tattachmentIndex = 5;\n\t}\n\n\tGLenum attachTarget = GL_TEXTURE_2D;\n\n\tcolor.mCachedMin = GL_LINEAR;\n\tcolor.mCachedMag = GL_LINEAR;\n\n\tmColor[attachmentIndex] = &color;\n\tmOwner->mBoundFrameBuffer = 0;\n\twasmGraphics_FramebufferAttachColor(attachTarget, mId, color.mId, attachmentIndex);\n}\n\nvoid Graphics::FrameBuffer::AttachDepth(Texture& depth, bool pcm) {\n\tGLenum attachTarget = GL_TEXTURE_2D;\n\n\tmDepth = &depth;\n\tmOwner->mBoundFrameBuffer = 0;\n\n\twasmGraphics_FrameBufferAttachDepth(attachTarget, mId, depth.mId, pcm);\n}\n\nbool Graphics::FrameBuffer::IsValid() {\n\tmOwner->mBoundFrameBuffer = 0;\n\treturn wasmGraphics_FrameBufferIsValid(mId);\n}\n\nvoid Graphics::FrameBuffer::ResolveTo(FrameBuffer* target, Filter filter, bool color, bool depth, u32 x0, u32 y0, u32 x1, u32 y1, u32 x2, u32 y2, u32 x3, u32 y3) {\n\tu32 targetId = 0;\n\tu32 targetHasColor = true;\n\tu32 targetHasDepth = true;\n\tif (target != 0) {\n\t\ttargetId = target->mId;\n\t\ttargetHasColor = target->TargetCount() != 0;\n\t\ttargetHasDepth = target->mDepth != 0;\n\t}\n\n\tbool hasColor = TargetCount() != 0;\n\tbool hasDepth = mDepth != 0;\n\n\tbool colorBit = false;\n\tbool depthBit = false;\n\tif (hasColor && targetHasColor && color) {\n\t\tcolorBit = true;\n\t}\n\tif (hasDepth && targetHasDepth && depth) {\n\t\tdepthBit = true;\n\t}\n\n\tGLenum gl_filter = GL_NEAREST;\n\tif (filter == Filter::Linear) {\n\t\tgl_filter = GL_LINEAR;\n\t}\n\n\tmOwner->mBoundFrameBuffer = 0;\n\twasmGraphics_FrameBufferResolveTo(mId, targetId, x0, y0, x1, y1, x2, y2, x3, y3, colorBit, depthBit, gl_filter);\n}\n\nvoid Graphics::FrameBuffer::ResolveTo(FrameBuffer* target, Filter filter, bool color, bool depth) {\n\tu32 width = GetWidth();\n\tu32 height = GetHeight();\n\n\tGraphicsAssert(GetWidth() == target->GetWidth(), \"Invalid resolve\");\n\tGraphicsAssert(GetHeight() == target->GetHeight(), \"Invalid resolve\");\n\t\n\tResolveTo(target, filter, color, depth, 0, 0, width, height, 0, 0, width, height);\n}\n\nvoid Graphics::FrameBuffer::Resize(u32 width, u32 height) {\n\tfor (u32 i = 0; i < 6; ++i) {\n\t\tif (mColor[i] != 0) {\n\t\t\tmColor[i]->Set(width, height);\n\t\t}\n\t}\n\tmDepth->Set(width, height);\n}\n\n\n\n#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\"\n\nexport void wasmGraphics_Assert(bool cond, const char* loc, const char* msg) {\n\tGraphics::Internal::Assert(cond, loc, msg);\n}\n\nexport Graphics::Device* wasm_Graphics_Initialize(Graphics::fpRequest allocPtr, Graphics::fpRelease releasePtr) {\n\tGraphics::Dependencies platform;\n\tplatform.Request = allocPtr;\n\tplatform.Release = releasePtr;\n\tGraphics::Device* device = (Graphics::Device*)allocPtr(sizeof(Graphics::Device));\n\treturn Graphics::Initialize(*device, platform);\n}\n\nexport void wasm_Graphics_Shutdown(Graphics::Device* device) {\n\tGraphics::Shutdown(*device);\n}","#pragma once\n\n#ifndef ATLAS_U32\n\t#define ATLAS_U32\n\ttypedef unsigned int u32;\n\tstatic_assert (sizeof(u32) == 4, \"u32 should be defined as a 4 byte type\");\n#endif \n\n#ifndef ATLAS_F32\n\t#define ATLAS_F32\n\ttypedef float f32;\n\tstatic_assert (sizeof(f32) == 4, \"f32 should be defined as a 4 byte type\");\n#endif \n\nnamespace Graphics {\n\t// The only external dependancy is memory allocation\n\ttypedef void* (*fpRequest)(u32 bytes);\n\ttypedef void (*fpRelease)(void* mem);\n\n\tstruct Dependencies {\n\t\tfpRequest Request; // malloc\n\t\tfpRelease Release; // free\n\n\t\tinline Dependencies() {\n\t\t\tRequest = 0;\n\t\t\tRelease = 0;\n\t\t}\n\t};\n\n\tclass Buffer;\n\tclass Shader;\n\tclass Device;\n\tclass Texture; \n\tclass VertexLayout;\n\tclass FrameBuffer;\n\n\tenum class Filter {\n\t\tNearest = 0,\n\t\tLinear = 1\n\t};\n\n\tenum class WrapMode {\n\t\tRepeat = 0,\n\t\tClamp = 1\n\t};\n\n\tenum class DepthFunc {\n\t\tAlways = 1,\n\t\tNever = 2,\n\t\tLess = 3,\n\t\tEqual = 4,\n\t\tLEqual = 5,\n\t\tGreater = 6,\n\t\tGEqual = 7,\n\t\tNotEqual = 8\n\t};\n\n\tenum class DrawMode {\n\t\tPoints = 0,\n\t\tLines = 1,\n\t\tLineStrip = 2,\n\t\tTriangles = 3,\n\t\tTriangleStrip = 4,\n\t\tTriangleFan = 5\n\t};\n\n\tenum class BufferType {\n\t\tFloat32 = 0,\n\t\tInt8 = 1,\n\t\tUInt8 = 2,\n\t\tInt16 = 3,\n\t\tUInt16 = 4,\n\t\tInt32 = 5,\n\t\tUInt32 = 6\n\t};\n\n\tenum class UniformType {\n\t\tInt1 = 0,\n\t\tInt2 = 1,\n\t\tInt3 = 2,\n\t\tInt4 = 3,\n\t\tFloat1 = 4,\n\t\tFloat2 = 5,\n\t\tFloat3 = 6,\n\t\tFloat4 = 7,\n\t\tFloat9 = 8,\n\t\tFloat16 = 9\n\t};\n\n\tenum class BlendEquation {\n\t\tAdd = 0, \n\t\tSubtract = 1, \n\t\tReverseSubtract = 2,\n\t\tMin = 3,\n\t\tMax = 4\n\t};\n\n\tenum class BlendFunction {\n\t\tZero = 1, \n\t\tOne = 2, \n\t\tSrcColor = 3, \n\t\tOneMinusSrcColor = 4, \n\t\tDstColor = 5, \n\t\tOneMinusDstColor = 6, \n\t\tSrcAlpha = 7, \n\t\tOneMinusSrcAlpha = 8, \n\t\tDstAlpha = 9, \n\t\tOneMinusDstAlpha = 10, \n\t\tConstColor = 11, \n\t\tOneMinusConstColor = 12, \n\t\tConstAlpha = 13, \n\t\tOneMinusconstAlpha = 14, \n\t\tSrcAlphaSaturate = 15\n\t};\n\n\tenum class CullFace {\n\t\tOff = 0, \n\t\tBack = 1, // Default\n\t\tFront = 2,\n\t\tFrontAndBack = 3\n\t};\n\n\tenum class FaceWind {\n\t\tCounterClockwise = 0, // Default\n\t\tClockwise = 1\n\t};\n\n\tenum class TextureFormat { // Rename to texture format\n\t\tR8 = 0,\t\t\n\t\tRG8 = 1,\t\n\t\tRGB8 = 2,\n\t\tRGBA8 = 3,\n\n\t\tR32F = 4,\n\t\tRG32F = 5,\n\t\tRGB32F = 6,\n\t\tRGBA32F = 7,\n\n\t\tDepth = 8\n\t};\n\n\tstruct Index { // Uniform / Attribute Index\n\t\tu32 id;\n\t\tu32 shader;\n\t\tbool valid;\n\n\t\tinline Index(u32 _id = 0, bool _valid = false, u32 _shader = 0) {\n\t\t\tid = _id;\n\t\t\tvalid = _valid;\n\t\t\tshader = _shader;\n\t\t}\n\t};\n\n\tstruct Sampler {\n\t\tWrapMode wrapS;\n\t\tWrapMode wrapT;\n\t\tFilter min; // Downscale\n\t\tFilter mip; // Mipmap transition\n\t\tFilter mag; // Upscale\n\n\t\tinline Sampler(WrapMode _wrapS = WrapMode::Repeat, WrapMode _wrapT = WrapMode::Repeat, Filter _min = Filter::Linear, Filter _mip = Filter::Linear, Filter _mag = Filter::Linear) {\n\t\t\twrapS = _wrapS;\n\t\t\twrapT = _wrapT;\n\t\t\tmin = _min;\n\t\t\tmip = _mip;\n\t\t\tmag = _mag;\n\t\t}\n\n\t\tinline Sampler(Filter _min, Filter _mip = Filter::Linear, Filter _mag = Filter::Linear) {\n\t\t\twrapS = WrapMode::Repeat;\n\t\t\twrapT = WrapMode::Repeat;\n\t\t\tmin = _min;\n\t\t\tmip = _mip;\n\t\t\tmag = _mag;\n\t\t}\n\n\t\tinline Sampler(WrapMode _wrap, Filter _filter) {\n\t\t\twrapS = _wrap;\n\t\t\twrapT = _wrap;\n\t\t\tmin = _filter;\n\t\t\tmip = _filter;\n\t\t\tmag = _filter;\n\t\t}\n\t};\n\n\tstruct BufferView {\n\t\tu32 NumberOfComponents; // (1) float, (2) vec2, (3) vec3, (4) vec4\n\t\tu32 StrideInBytes;\n\t\tBufferType Type; // float or int\n\t\tu32 DataOffsetInBytes; // pointer argument to glVertexAttribLPointer\n\n\t\tinline BufferView(\tu32 _numberOfComponents = 0, \n\t\t\t\t\t\t\tu32 _strideInBytes = 0, \n\t\t\t\t\t\t\tBufferType _type = BufferType::Float32, \n\t\t\t\t\t\t\tu32 _dataOffsetInBytes = 0) {\n\t\t\tNumberOfComponents = _numberOfComponents;\n\t\t\tStrideInBytes = _strideInBytes;\n\t\t\tType = _type;\n\t\t\tDataOffsetInBytes = _dataOffsetInBytes;\n\t\t}\n\t};\n\n\t// Making both depth texture and color texture be the same texture was a mistake\n\t// There should be three types of texture: ColorTexture, DepthTexture, and DataTexture\n\t// additionally we may want to have a ColorCubemap and a DepthCubeMap. Having all of \n\t// these textures in seperate classes will bloat the API considerably, but trying\n\t// to wrangle them all under Texture has been a nightmare.\n\tclass Texture { // These are texture objects\n\t\tfriend class Device;\n\t\tfriend class FrameBuffer;\n\tprotected:\n\t\tu32 mId;\n\t\tu32 mWidth;\n\t\tu32 mHeight;\n\t\tu32 mUserData;\n\t\tbool mIsMipMapped;\n\t\tTextureFormat mInternalFormat;\n\n\t\tu32 mCachedMin; // Default: GL_NEAREST_MIPMAP_LINEAR\n\t\tu32 mCachedMag; // Default: GL_LINEAR\n\t\tu32 mCachedS; // Default = GL_REPEAT\n\t\tu32 mCachedR; // Default = GL_REPEAT\n\t\tu32 mCachedT; // Default = GL_REPEAT\n\n\t\tTexture* mAllocPrev;\n\t\tTexture* mAllocNext;\n\t\tDevice* mOwner;\n\tprivate:\n\t\tTexture() = delete;\n\t\t~Texture() = delete;\n\t\tTexture(const Texture& other) = delete;\n\t\tTexture& operator=(const Texture& other) = delete;\n\tpublic:\n\t\tvoid Set(void* data, TextureFormat dataFormat, u32 width, u32 height, bool genMipMaps);\n\t\t\n\t\tinline void Set(u32 width, u32 height) {\n\t\t\tTextureFormat dataFormat = TextureFormat::RGBA8;\n\t\t\tSet(0, mInternalFormat, width, height, false);\n\t\t}\n\n\t\tinline u32 GetWidth() {\n\t\t\treturn mWidth;\n\t\t}\n\t\t\n\t\tinline u32 GetHeight() {\n\t\t\treturn mHeight;\n\t\t}\n\n\t\tinline TextureFormat GetFormat() {\n\t\t\treturn mInternalFormat;\n\t\t}\n\n\t\tinline void SetUserData(u32 data) {\n\t\t\tmUserData = data;\n\t\t}\n\n\t\tinline u32 GetUserData() {\n\t\t\treturn mUserData;\n\t\t}\n\t};\n\n\tnamespace Internal {\n\t\tstruct TextureUnit {\n\t\t\tGraphics::Index index;\n\t\t\tGraphics::Texture* texture; // Null or bound texture\n\t\t\tu32 target; // TEXTURE_2D, TEXTURE_3D, etc...\n\t\t};\n\t}\n\n\tclass Buffer {\n\t\tfriend class Device;\n\t\tfriend class VertexLayout;\n\tprotected:\n\t\tu32 mId;\n\t\tbool mIndexBuffer;\n\t\tu32 mUserData;\n\n\t\tBuffer* mAllocPrev;\n\t\tBuffer* mAllocNext;\n\t\tDevice* mOwner;\n\tprivate:\n\t\tBuffer() = delete;\n\t\tBuffer(const Buffer&) = delete;\n\t\tBuffer& operator=(const Buffer&) = delete;\n\t\t~Buffer() = delete;\n\tpublic:\n\t\tvoid Set(void* inputArray, u32 arraySizeInBytes, bool _static = true);\n\t\tvoid Reset();\n\n\t\tinline void SetUserData(u32 data) {\n\t\t\tmUserData = data;\n\t\t}\n\n\t\tinline u32 GetUserData() {\n\t\t\treturn mUserData;\n\t\t}\n\n\t\tinline bool IsIndexBuffer() {\n\t\t\treturn mIndexBuffer;\n\t\t}\n\t};\n\n\t// Note to self in the future:\n\t// The way this would work is that a MeshRenderer has a list of materials\n\t// Each material has a shader. For each material, the mesh renderer needs\n\t// to create a vertex layout. Then, when drawing a MeshRenderer, loop trough\n\t// all of it's materials. For each material: bind the shader, and the vertex\n\t// layout. \n\t// To do things like normal mapping, A mapping from VertexLayout to arbitrary\n\t// shaders / materials needs to be doable. \n\tclass VertexLayout {\n\t\tfriend class Device;\n\tprotected:\n\t\tu32 mId;\n\t\tbool mHasIndexBuffer;\n\t\tu32 mUserData;\n\t\tBufferType mIndexBufferType;\n\t\t\n\t\tVertexLayout* mAllocPrev;\n\t\tVertexLayout* mAllocNext;\n\t\tDevice* mOwner;\n\tprivate:\n\t\tVertexLayout() = delete;\n\t\tVertexLayout(const VertexLayout&) = delete;\n\t\tVertexLayout& operator=(const VertexLayout&) = delete;\n\t\t~VertexLayout() = delete;\n\tpublic:\n\t\tvoid Set(const Index& index, const Buffer& buffer, const BufferView& view, u32 instanceDivisor = 0);\n\t\tvoid Set(const Buffer& indexBuffer, const BufferType& indexType);\n\t\tvoid Reset();\n\n\t\tinline void SetUserData(u32 data) {\n\t\t\tmUserData = data;\n\t\t}\n\n\t\tinline u32 GetUserData() {\n\t\t\treturn mUserData;\n\t\t}\n\t};\n\n\tclass Shader {\n\t\tfriend class Device;\n\tprotected:\n\t\tu32 mProgram;\n\t\tu32 mUserData;\n\n#if GRAPHICS_SHADERS_ENABLENAMES\n\t\tchar* mUniformNames; // Might not be needed\n\t\tu32 mNumUniforms;    // Might not be needed\n\n\t\tchar* mAttributeNames; // Might not be needed\n\t\tu32 mNumAttributes;    // Might not be needed\n#endif\n\t\tShader* mAllocPrev; \n\t\tShader* mAllocNext;\n\t\tDevice* mOwner; \n\tprivate:\n\t\tShader() = delete;\n\t\tShader(const Shader&) = delete;\n\t\tShader& operator=(const Shader&) = delete;\n\t\t~Shader() = delete;\n\tpublic:\n\t\tIndex GetAttribute(const char* name);\n\t\tIndex GetUniform(const char* name);\n\n\t\tinline void SetUserData(u32 data) {\n\t\t\tmUserData = data;\n\t\t}\n\n\t\tinline u32 GetUserData() {\n\t\t\treturn mUserData;\n\t\t}\n\n\t\t/* I added support for the shader knowing it's uniform names here,\n\t\t* with the idea that a MeshRenderer would need to map the shader to\n\t\t* some vertex buffer format. That's not really important tough. If the\n\t\t* standard streams are known  \"ie, position, normal, tangent, etc\"\n\t\t* then i can just get their Index-es and see if the index is valid\n\t\t* if it is, bind it to the fbo, it it isn't, don't. Anyway, i already added\n\t\t* the code to get the info, so i'm going to keep it alive without \n\t\t* exposing it. If it's not needed, i'll emove it from the final version */\n\t};\n\n\tclass FrameBuffer {\n\t\tfriend class Device;\n\tprotected:\n\t\tu32 mId;\n\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tTexture* mColor0;\n\t\t\t\tTexture* mColor1;\n\t\t\t\tTexture* mColor2;\n\t\t\t\tTexture* mColor3;\n\t\t\t\tTexture* mColor4;\n\t\t\t\tTexture* mColor5;\n\t\t\t};\n\t\t\tTexture* mColor[6];\n\t\t};\n\t\t\n\t\tTexture* mDepth;\n\t\tu32 mReadBufferConfig;\n\n\t\tu32 mUserData;\n\n\t\tFrameBuffer* mAllocPrev;\n\t\tFrameBuffer* mAllocNext;\n\t\tDevice* mOwner;\n\tprivate:\n\t\tFrameBuffer() = delete;\n\t\tFrameBuffer(const FrameBuffer&) = delete;\n\t\tFrameBuffer& operator=(const FrameBuffer&) = delete;\n\t\t~FrameBuffer() = delete;\n\tpublic:\n\t\tvoid AttachColor(Texture& color, u32 attachmentIndex = 0);\n\t\tvoid AttachDepth(Texture& depth, bool pcf = true);\n\t\t\n\t\tvoid Resize(u32 width, u32 height);\n\t\tbool IsValid();\n\n\t\tu32 TargetCount();\n\t\tu32 GetWidth();\n\t\tu32 GetHeight();\n\n\t\tvoid ResolveTo(FrameBuffer* target, Filter filter, bool color, bool depth, u32 x0, u32 y0, u32 x1, u32 y1, u32 x2, u32 y2, u32 x3, u32 y3);\n\t\tvoid ResolveTo(FrameBuffer* target, Filter filter = Filter::Nearest, bool color = true, bool depth = true);\n\n\t\tinline void SetUserData(u32 data) {\n\t\t\tmUserData = data;\n\t\t}\n\n\t\tinline u32 GetUserData() {\n\t\t\treturn mUserData;\n\t\t}\n\t};\n\n\tclass Device {\n\t\tfriend class FrameBuffer;\n\t\tfriend Device* Initialize(Device& outDevice, Dependencies& platform);\n\t\tfriend void Shutdown(Device& device);\n\tprotected:\n\t\tDependencies mPlatform;\n\t\tu32 mUserData;\n\t\tu32 mViewportRect[4];\n\n\t\tu32 mBoundProgram;\n\t\tu32 mBoundFrameBuffer;\n\n\t\t// Texture state\n\t\tInternal::TextureUnit mBoundTextures[32];\n\t\t\n\t\t// Cull state\n\t\tCullFace mFaceCulling; // Default back\n\t\tFaceWind mWindingOrder; // Default CCW\n\n\t\t// Blend State\n\t\tbool mBlend; // Default: false\n\t\tf32 mBlendColor[4]; // Default: 0, 0, 0, 0\n\t\tBlendFunction mBlendDstAlpha; // Default BlendFunction::Zero\n\t\tBlendFunction mBlendDstRGB; // Default BlendFunction::Zero\n\t\tBlendEquation mBlendEquationAlpha; // Default: BlendEquation::Add\n\t\tBlendEquation mBlendEquationRGB; // Default: BlendEquation::Add\n\t\tBlendFunction mBlendSrcAlpba; // Default BlendFunction::One\n\t\tBlendFunction mBlendSrcRGB; // Default BlendFunction::One\n\n\t\t// Depth state\n\t\tbool mDepth;\t// true\n\t\tDepthFunc mDepthFunc; // less\n\t\tf32 mDepthRange[2]; // 0, 1\n\n\t\t// Scissor state\n\t\tbool mScissor;\n\t\tu32 mScissorRect[4];\n\n\t\t// Memory tracking\n\t\tTexture* mAllocatedTextures;\n\t\tBuffer* mAllocatedBuffers;\n\t\tVertexLayout* mAllocatedStates;\n\t\tShader* mAllocatedShaders;\n\t\tFrameBuffer* mAllocatedFrameBuffers;\n\tprivate:\n\t\tDevice() = delete;\n\t\tDevice(const Device&) = delete;\n\t\tDevice& operator=(const Device&) = delete;\n\t\t~Device() = delete;\n\tpublic:\n\t\tinline void* Allocate(u32 bytes) {\n\t\t\tif (mPlatform.Request != 0) {\n\t\t\t\treturn mPlatform.Request(bytes);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tinline void Release(void* mem) {\n\t\t\tif (mPlatform.Release != 0) {\n\t\t\t\tmPlatform.Release(mem);\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tShader* CreateShader(const char* vertex, const char* fragment);\n\t\tvoid Destroy(Shader* shader);\n\n\t\tBuffer* CreateBuffer();\n\t\tBuffer* CreateIndexBuffer();\n\t\tinline Buffer* CreateBuffer(void* array, u32 sizeInBytes, bool _static = true) {\n\t\t\tBuffer* result = CreateBuffer();\n\t\t\tresult->Set(array, sizeInBytes, _static);\n\t\t\treturn result;\n\t\t}\n\t\tinline Buffer* CreateIndexBuffer(void* array, u32 sizeInBytes, bool _static = true) {\n\t\t\tBuffer* result = CreateIndexBuffer();\n\t\t\tresult->Set(array, sizeInBytes, _static);\n\t\t\treturn result;\n\t\t}\n\t\tvoid Destroy(Buffer* buff);\n\n\t\tVertexLayout* CreateVertexLayout();\n\t\tvoid Destroy(VertexLayout* map);\n\n\t\tFrameBuffer* CreateFrameBuffer();\n\t\tvoid Destroy(FrameBuffer* buffer);\n\n\t\tTexture* CreateTexture(TextureFormat format);\n\n\t\tinline Texture* CreateTexture(TextureFormat format, u32 width, u32 height, void* data, TextureFormat dataFormat, bool genMipMaps) {\n\t\t\tTexture* result = CreateTexture(format);\n\t\t\tresult->Set(data, dataFormat, width, height, genMipMaps);\n\t\t\treturn result;\n\t\t}\n\t\tinline Texture* CreateTexture(TextureFormat format, u32 width, u32 height) {\n\t\t\tTexture* result = CreateTexture(format);\n\t\t\tresult->Set(width, height);\n\t\t\treturn result;\n\t\t}\n\t\tvoid Destroy(Texture* buff);\n\n\t\tvoid Bind(Shader* shader); // Binds shader & allows for Bind(0)\n\t\tinline void Bind(Shader& shader) {\n\t\t\tBind(&shader);\n\t\t}\n\n\t\t// Frame buffers should persist between Bind calls, even if null is bound\n\t\tvoid SetRenderTarget(FrameBuffer* frameBuffer);\n\t\tinline void SetRenderTarget(FrameBuffer& frameBuffer) {\n\t\t\tSetRenderTarget(&frameBuffer);\n\t\t}\n\n\t\tvoid Bind(Index& slot, UniformType type, void* data, u32 count = 1); // Binds uniform\n\t\tvoid Bind(Index& uniformSlot, Texture& texture, Sampler& sampler); // Binds texture (uniform still)\n\n\t\tvoid Draw(const VertexLayout& attributes, DrawMode drawMode, u32 startIndex, u32 indexCount, u32 instanceCount = 1);\n\tpublic: // State management\n\t\t// Blend state\n\t\tvoid SetBlendState(bool blend, f32* optBlendColor, \n\t\t\tBlendFunction blendDstRgb, BlendFunction blendDstAlpha, \n\t\t\tBlendEquation blendEquationRgb, BlendEquation blendEquationAlpha,\n\t\t\tBlendFunction blendSrcRgb, BlendFunction blendSrcAlpha);\n\n\t\tinline void SetBlendState(f32* color, BlendFunction blendDst, BlendEquation blendEq, BlendFunction blendSrc) {\n\t\t\tSetBlendState(true, color, blendDst, blendDst, blendEq, blendEq, blendSrc, blendSrc);\n\t\t}\n\t\tinline void SetBlendState(BlendFunction dst, BlendEquation eq, BlendFunction src) {\n\t\t\tSetBlendState(true, 0, dst, dst, eq, eq, src, src);\n\t\t}\n\t\tinline void SetBlendState(BlendFunction dst, BlendFunction src) {\n\t\t\tSetBlendState(true, 0, dst, dst, BlendEquation::Add, BlendEquation::Add, src, src);\n\t\t}\n\t\tinline void SetBlendState(BlendEquation eq) {\n\t\t\tSetBlendState(true, 0, BlendFunction::Zero, BlendFunction::Zero, eq, eq, BlendFunction::One, BlendFunction::One);\n\t\t}\n\t\tinline void SetBlendState(bool blend) {\n\t\t\tSetBlendState(blend, 0, BlendFunction::Zero, BlendFunction::Zero, BlendEquation::Add, BlendEquation::Add, BlendFunction::One, BlendFunction::One);\n\t\t}\n\t\t// End Blend state\n\n\t\t// Cull state\n\t\tvoid SetFaceCulling(CullFace cull, FaceWind wind = FaceWind::CounterClockwise);\n\t\t// End cull state\n\n\t\t// Depth State\n\t\tvoid SetDepthState(bool enable, DepthFunc depthFunc, f32* depthRange = 0);\n\t\tinline void SetDepthState(DepthFunc depthFunc) {\n\t\t\tSetDepthState(true, depthFunc, 0);\n\t\t}\n\t\tinline void SetDepthState(bool enable) {\n\t\t\tSetDepthState(enable, DepthFunc::Less, 0);\n\t\t}\n\t\t// End depth state\n\n\t\t// Scissor State\n\t\tvoid SetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h);\n\t\tinline void SetScissorState(bool enable) {\n\t\t\tSetScissorState(enable, mScissorRect[0], mScissorRect[1], mScissorRect[2], mScissorRect[3]);\n\t\t}\n\t\t// End Scissor state\n\t\t\n\n\t\tvoid WriteMask(bool r, bool g, bool b, bool a, bool depth);\n\t\tvoid SetViewport(u32 x, u32 y, u32 w, u32 h);\n\t\t\n\t\tvoid Clear(f32 r, f32 g, f32 b, f32 depth);\n\t\tvoid Clear(f32 r, f32 g, f32 b);\n\t\tvoid Clear(f32 depth);\n\t\tvoid Clear(bool color, bool depth);\n\n\t\tinline void SetUserData(u32 data) {\n\t\t\tmUserData = data;\n\t\t}\n\n\t\tinline u32 GetUserData() {\n\t\t\treturn mUserData;\n\t\t}\n\n\t\tinline Dependencies* GetPlatform() {\n\t\t\treturn &mPlatform;\n\t\t}\n\t};\n\n\tDevice* Initialize(Device& outDevice, Dependencies& platform);\n\tinline Device* Initialize(Dependencies& platform) {\n\t\tDevice* result = (Device*)platform.Request(sizeof(Graphics::Device));\n\t\tInitialize(*result, platform);\n\t\treturn result;\n\t}\n\tvoid Shutdown(Device& device);\n}","#include \"mem.h\"\n\n#pragma warning(disable:6011)\n#pragma warning(disable:28182)\n\n#ifndef ATLAS_U16\n\t#define ATLAS_U16\n\ttypedef unsigned short u16;\n\tstatic_assert (sizeof(u16) == 2, \"u16 should be defined as a 2 byte type\");\n#endif \n\n#if _DEBUG\n\t#define assert(cond, msg) Memory::Assert(cond, msg, __LINE__, __FILE__)\n#else\n\t#define assert(cond, msg) ;\n#endif\n\nnamespace Memory {\n\tAllocator* wasmGlobalAllocator = 0;\n}\n#define NotImplementedException() Memory::Assert(false, \"Not implemented exception\", __LINE__m, __FILE__);\n\nextern \"C\" void* __cdecl memset(void* _mem, i32 _value, Memory::ptr_type _size) {\n\treturn Memory::Set(_mem, (u8)_value, (u32)_size, \"internal - memset\");\n}\nextern \"C\" void wasmGraphics_Log(const char* loc, int locLen, const char* msg, int msgLen);\n\nnamespace Memory {\n\tnamespace Debug {\n\t\tu32 u32toa(u8* dest, u32 destSize, u32 num);\n\t}\n\tstatic void Assert(bool condition, const char* msg, u32 line, const char* file) {\n#if _WASM32\n\t\tif (condition == false) {\n            u32 msg_len = 0;\n            for (const char* i = msg; msg != 0 && *i != '\\0'; ++i, ++msg_len);\n\t\t\tu32 loc_len = 0;\n            for (const char* i = file; file != 0 && *i != '\\0'; ++i, ++loc_len);\n            wasmGraphics_Log(file, loc_len, msg, msg_len);\n            __builtin_trap();\n\t\t}\n#else\n\t\tchar* data = (char*)((void*)0);\n\t\tif (condition == false) {\n\t\t\t*data = '\\0';\n\t\t}\n#endif\n\t}\n\n\tstatic inline u32 AllocatorPaddedSize() {\n\t\tstatic_assert (sizeof(Memory::Allocator) % AllocatorAlignment == 0, \"Memory::Allocator size needs to be 8 byte aligned for the allocation mask to start on this alignment without any padding\");\n\t\treturn sizeof(Allocator);\n\t}\n\n\tstatic inline u8* AllocatorPageMask(Allocator* allocator) {\n\t\tstatic_assert (sizeof(Memory::Allocator) % AllocatorAlignment == 0, \"Memory::Allocator size needs to be 8 byte aligned for the allocation mask to start on this alignment without any padding\");\n\t\treturn ((u8*)allocator) + sizeof(Allocator);\n\t}\n\n\tstatic inline u32 AllocatorPageMaskSize(Allocator* allocator) { // This is the number of u8's that make up the AllocatorPageMask array\n\t\tconst u32 allocatorNumberOfPages = allocator->size / allocator->pageSize; // 1 page = (probably) 4096 bytes, how many are needed\n\t\tassert(allocator->size % allocator->pageSize == 0, \"Allocator size should line up with page size\");\n\t\t// allocatorNumberOfPages is the number of bits that are required to track memory\n\n\t\t// Pad out to sizeof(32) (if MaskTrackerSize is 32). This is because AllocatorPageMask will often be used as a u32 array\n\t\t// and we want to make sure that enough space is reserved.\n\t\tconst u32 allocatorPageArraySize = allocatorNumberOfPages / TrackingUnitSize + (allocatorNumberOfPages % TrackingUnitSize ? 1 : 0);\n\t\treturn allocatorPageArraySize * (TrackingUnitSize / 8); // In bytes, not bits\n\t}\n\n\tstatic inline void RemoveFromList(Allocator* allocator, Allocation** list, Allocation* allocation) {\n\t\tu32 allocationOffset = (u32)((u8*)allocation - (u8*)allocator);\n\t\tu32 listOffset = (u32)((u8*)(*list) - (u8*)allocator);\n\t\t\n\t\tAllocation* head = *list;\n\n\t\tif (head == allocation) { // Removing head\n\t\t\tif (head->nextOffset != 0) { // There is a next\n\t\t\t\tAllocation* allocNext = 0;\n\t\t\t\tif (allocation->nextOffset != 0) {\n\t\t\t\t\tallocNext = (Allocation*)((u8*)allocator + allocation->nextOffset);\n\t\t\t\t}\n\t\t\t\tAllocation* headerNext = 0;\n\t\t\t\tif (head->nextOffset != 0) {\n\t\t\t\t\theaderNext = (Allocation*)((u8*)allocator + head->nextOffset);\n\t\t\t\t}\n\t\t\t\tassert(allocNext == headerNext, __LOCATION__);\n\t\t\t\tassert(headerNext->prevOffset == allocationOffset, __LOCATION__);\n\t\t\t\theaderNext->prevOffset = 0;\n\t\t\t}\n\t\t\tAllocation* next = 0;\n\t\t\tif (head != 0 && head->nextOffset != 0) {\n\t\t\t\tnext = (Allocation*)((u8*)allocator + head->nextOffset);\n\t\t\t}\n\t\t\t*list = next;\n\t\t}\n\t\telse {\n\t\t\tif (allocation->nextOffset != 0) {\n\t\t\t\tAllocation* _next = (Allocation*)((u8*)allocator + allocation->nextOffset);\n\t\t\t\tassert(_next->prevOffset == allocationOffset, __LOCATION__);\n\t\t\t\t_next->prevOffset = allocation->prevOffset;\n\t\t\t}\n\t\t\tif (allocation->prevOffset != 0) {\n\t\t\t\tAllocation* _prev = (Allocation*)((u8*)allocator + allocation->prevOffset);\n\t\t\t\tassert(_prev->nextOffset == allocationOffset, __LOCATION__);\n\t\t\t\t_prev->nextOffset = allocation->nextOffset;\n\t\t\t}\n\t\t}\n\n\t\tallocation->prevOffset = 0;\n\t\tallocation->nextOffset = 0;\n\t}\n\n\tstatic inline void AddtoList(Allocator* allocator, Allocation** list, Allocation* allocation) {\n\t\tu32 allocationOffset = (u32)((u8*)allocation - (u8*)allocator);\n\t\tu32 listOffset = (u32)((u8*)(*list) - (u8*)allocator);\n\t\tAllocation* head = *list;\n\n\t\tallocation->prevOffset = 0;\n\t\tallocation->nextOffset = 0;\n\t\tif (head != 0) {\n\t\t\tallocation->nextOffset = listOffset;\n\t\t\thead->prevOffset = allocationOffset;\n\t\t}\n\t\t*list = allocation;\n\t}\n\n\t// Returns 0 on error. Since the first page is always tracking overhead it's invalid for a range\n\tstatic inline u32 FindRange(Allocator* allocator, u32 numPages, u32 searchStartBit) {\n\t\tassert(allocator != 0, __LOCATION__);\n\t\tassert(numPages != 0, __LOCATION__);\n\n\t\tu32 * mask = (u32*)AllocatorPageMask(allocator);\n\t\tu32 numBitsInMask = AllocatorPageMaskSize(allocator) * 8;\n\t\tu32 numElementsInMask = AllocatorPageMaskSize(allocator) / (TrackingUnitSize / 8);\n\t\tassert(allocator->size % allocator->pageSize == 0, \"Memory::FindRange, the allocators size must be a multiple of Memory::PageSize, otherwise there would be a partial page at the end\");\n\t\tassert(mask != 0, __LOCATION__);\n\t\tassert(numBitsInMask != 0, __LOCATION__);\n\n\t\tu32 startBit = 0;\n\t\tu32 numBits = 0;\n\n\t\tfor (u32 i = searchStartBit; i < numBitsInMask; ++i) {\n\t\t\tu32 m = i / TrackingUnitSize;\n\t\t\tu32 b = i % TrackingUnitSize;\n\n\t\t\tassert(m < numElementsInMask, \"indexing mask out of range\");\n\t\t\tbool set = mask[m] & (1 << b);\n\n\t\t\tif (!set) {\n\t\t\t\tif (startBit == 0) {\n\t\t\t\t\tstartBit = i;\n\t\t\t\t\tnumBits = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnumBits++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstartBit = 0;\n\t\t\t\tnumBits = 0;\n\t\t\t}\n\n\t\t\tif (numBits == numPages) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (numBits != numPages || startBit == 0) {\n\t\t\tstartBit = 0;\n\t\t\tnumBits = 0;\n\n\t\t\tfor (u32 i = 0; i < searchStartBit; ++i) {\n\t\t\t\tu32 m = i / TrackingUnitSize;\n\t\t\t\tu32 b = i % TrackingUnitSize;\n\n\t\t\t\tbool set = mask[m] & (1 << b);\n\n\t\t\t\tif (!set) {\n\t\t\t\t\tif (startBit == 0) {\n\t\t\t\t\t\tstartBit = i;\n\t\t\t\t\t\tnumBits = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnumBits++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstartBit = 0;\n\t\t\t\t\tnumBits = 0;\n\t\t\t\t}\n\n\t\t\t\tif (numBits == numPages) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tallocator->scanBit = startBit + numPages;\n\n\t\tassert(numBits == numPages, \"Memory::FindRange Could not find enough memory to fufill request\");\n\t\tassert(startBit != 0, \"Memory::FindRange Could not memory fufill request\");\n\t\tif (numBits != numPages || startBit == 0 || allocator->size % allocator->pageSize != 0) {\n\t\t\tassert(false, __LOCATION__);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn startBit;\n\t}\n\n\tstatic inline void SetRange(Allocator* allocator, u32 startBit, u32 bitCount) {\n\t\tassert(allocator != 0, __LOCATION__);\n\t\tassert(bitCount != 0, __LOCATION__);\n\n\t\tu32* mask = (u32*)AllocatorPageMask(allocator);\n\t\tassert(allocator->size % allocator->pageSize == 0, \"Memory::FindRange, the allocators size must be a multiple of Memory::PageSize, otherwise there would be a partial page at the end\");\n\t\tassert(mask != 0, __LOCATION__);\n\n#if _DEBUG\n\t\tu32 numBitsInMask = AllocatorPageMaskSize(allocator) * 8;\n\t\tassert(numBitsInMask != 0, __LOCATION__);\n#endif\n\t\tu32 numElementsInMask = AllocatorPageMaskSize(allocator) / (TrackingUnitSize / 8);\n\n\t\tfor (u32 i = startBit; i < startBit + bitCount; ++i) {\n\n\t\t\tu32 m = i / TrackingUnitSize;\n\t\t\tu32 b = i % TrackingUnitSize;\n\n\t\t\tassert(m < numElementsInMask, \"indexing mask out of range\");\n#if _DEBUG\n\t\t\tassert(i < numBitsInMask, __LOCATION__);\n\t\t\tbool set = mask[m] & (1 << b);\n\t\t\tassert(!set, __LOCATION__);\n#endif\n\n\t\t\tmask[m] |= (1 << b);\n\t\t}\n\n\t\tassert(allocator->numPagesUsed <= numBitsInMask, \"Memory::FindRange, over allocating\");\n\t\tassert(allocator->numPagesUsed + bitCount <= numBitsInMask, \"Memory::FindRange, over allocating\");\n\t\tallocator->numPagesUsed += bitCount;\n\t\tif (allocator->numPagesUsed > allocator->peekPagesUsed) {\n\t\t\tallocator->peekPagesUsed = allocator->numPagesUsed;\n\t\t}\n\t}\n\n\tstatic inline void ClearRange(Allocator* allocator, u32 startBit, u32 bitCount) {\n\t\tassert(allocator != 0, __LOCATION__);\n\t\tassert(bitCount != 0, __LOCATION__);\n\n\t\tu32* mask = (u32*)AllocatorPageMask(allocator);\n\t\tassert(allocator->size % allocator->pageSize == 0, \"Memory::FindRange, the allocators size must be a multiple of Memory::PageSize, otherwise there would be a partial page at the end\");\n\t\tassert(mask != 0, __LOCATION__);\n\n#if _DEBUG\n\t\tu32 numBitsInMask = AllocatorPageMaskSize(allocator) * 8;\n\t\tassert(numBitsInMask != 0, __LOCATION__);\n#endif\n\n\t\tu32 numElementsInMask = AllocatorPageMaskSize(allocator) / (TrackingUnitSize / 8);\n\n\t\tfor (u32 i = startBit; i < startBit + bitCount; ++i) {\n\n\t\t\tu32 m = i / TrackingUnitSize;\n\t\t\tu32 b = i % TrackingUnitSize;\n\n\t\t\tassert(m < numElementsInMask, \"indexing mask out of range\");\n\n#if _DEBUG\n\t\t\tassert(i < numBitsInMask, __LOCATION__);\n\t\t\tbool set = mask[m] & (1 << b);\n\t\t\tassert(set, __LOCATION__);\n#endif\n\n\t\t\tmask[m] &= ~(1 << b);\n\t\t}\n\n\t\tassert(allocator->numPagesUsed != 0, __LOCATION__);\n\t\tassert(allocator->numPagesUsed >= bitCount != 0, \"underflow\");\n\t\tallocator->numPagesUsed -= bitCount;\n\t}\n\n#if MEM_USE_SUBALLOCATORS\n\t// This function will chop the provided page into several blocks. Since the block size is constant, we\n\t// know that headers will be laid out at a stride of blockSize. There is no additional tracking needed.\n\tvoid* SubAllocate(u32 requestedBytes, u32 blockSize, Allocation** freeList, const char* location, Allocator* allocator) {\n\t\tassert(blockSize < allocator->pageSize, \"Block size must be less than page size\");\n\n\t\t// There is no blocks of the requested size available. Reserve 1 page, and carve it up into blocks.\n\t\tbool grabNewPage = *freeList == 0;\n\t\tif (*freeList == 0) {\n\t\t\t// Find and reserve 1 free page\n#if MEM_FIRST_FIT\n\t\t\tconst u32 page = FindRange(allocator, 1, 0);\n#else\n\t\t\tconst u32 page = FindRange(allocator, 1, allocator->scanBit);\n#endif\n\t\t\tSetRange(allocator, page, 1);\n\n\t\t\t// Zero out the pages memory\n\t\t\tu8* mem = (u8*)allocator + allocator->pageSize * page;\n\t\t\tSet(mem, 0, allocator->pageSize, __LOCATION__);\n\n\t\t\t// Figure out how many blocks fit into this page\n\t\t\tconst u32 numBlocks = allocator->pageSize / blockSize;\n\t\t\tassert(numBlocks > 0, __LOCATION__);\n\t\t\tassert(numBlocks < 128, __LOCATION__);\n\n\t\t\t// For each block in this page, initialize it's header and add it to the free list\n\t\t\tfor (u32 i = 0; i < numBlocks; ++i) {\n\t\t\t\tAllocation* alloc = (Allocation*)mem;\n\t\t\t\tmem += blockSize;\n\n\t\t\t\t// Initialize the allocation header\n\t\t\t\talloc->prevOffset = 0;\n\t\t\t\talloc->nextOffset = 0;\n\t\t\t\talloc->size = 0;\n\t\t\t\talloc->alignment = 0;\n#if MEM_TRACK_LOCATION\n\t\t\t\talloc->location = location;\n#endif\n\n\t\t\t\tAddtoList(allocator, freeList, alloc);\n\t\t\t}\n\t\t}\n\t\tassert(*freeList != 0, \"The free list literally can't be zero here...\");\n\n\t\t// At this point we know the free list has some number of blocks in it. \n\t\t// Save a reference to the current header & advance the free list\n\t\t// Advance the free list, we're going to be using this one.\n\t\tAllocation* block = *freeList;\n#if MEM_CLEAR_ON_ALLOC\n\t\tSet((u8*)block + sizeof(Allocation), 0, blockSize - sizeof(Allocation), location);\n#elif MEM_DEBUG_ON_ALLOC\n\t\t{\n\t\t\tconst u8 stamp[] = \"-MEMORY-\";\n\t\t\tu8* mem = (u8*)block + sizeof(Allocation);\n\t\t\tu32 size = blockSize - sizeof(Allocation);\n\t\t\tfor (u32 i = requestedBytes; i < size; ++i) {\n\t\t\t\tmem[i] = stamp[(i - requestedBytes) % 7];\n\t\t\t}\n\t\t}\n#endif\n\t\tif ((*freeList)->nextOffset != 0) { // Advance one\n\t\t\tAllocation* _next = (Allocation*)((u8*)allocator + (*freeList)->nextOffset);\n\t\t\t_next->prevOffset = 0;\n\t\t\t*freeList = (Allocation*)((u8*)allocator + (*freeList)->nextOffset); // freeList = freeList.next\n\t\t}\n\t\telse {\n\t\t\t*freeList = 0;\n\t\t}\n\n\t\tblock->prevOffset = 0;\n\t\tblock->size = requestedBytes;\n\t\tblock->alignment = 0;\n#if MEM_TRACK_LOCATION\n\t\tblock->location = location;\n#endif\n\n\t\tAddtoList(allocator, &allocator->active, block); // Sets block->next\n\n\t\tif (allocator->allocateCallback != 0) {\n\t\t\tu32 firstPage = ((u32)((u8*)block - (u8*)allocator)) / allocator->pageSize;\n\t\t\tallocator->allocateCallback(allocator, block, requestedBytes, blockSize, firstPage, grabNewPage? 1 : 0);\n\t\t}\n\n\t\t// Memory always follows the header\n\t\treturn (u8*)block + sizeof(Allocation);\n\t}\n#endif\n\n#if MEM_USE_SUBALLOCATORS\n\tvoid SubRelease(void* memory, u32 blockSize, Allocation** freeList, const char* location, Allocator* allocator) {\n\t\t// Find the allocation header and mark it as free. Early out on double free to avoid breaking.\n\t\tAllocation* header = (Allocation*)((u8*)memory - sizeof(Allocation));\n\t\tassert(header->size != 0, \"Double Free!\"); // Make sure it's not a double free\n\t\tif (header->size == 0) {\n\t\t\tassert(false, __LOCATION__);\n\t\t\treturn;\n\t\t}\n\t\tu32 oldSize = header->size;\n\t\theader->size = 0;\n\n\t\t// Now remove from the active list.\n\t\tRemoveFromList(allocator, &allocator->active, header);\n\t\t// Add memory back into the free list\n\t\tAddtoList(allocator, freeList, header);\n#if _DEBUG & MEM_TRACK_LOCATION\n\t\theader->location = \"SubRelease released this block\";\n#endif\n\n\t\t// Find the first allocation inside the page\n\t\tu32 startPage = (u32)((u8*)header - (u8*)allocator) / allocator->pageSize;\n\n\t\tu8* mem =(u8*)allocator + startPage * allocator->pageSize;\n\n\t\t// Each sub allocator page contains multiple blocks. check if all of the blocks \n\t\t// belonging to a single page are free, if they are, release the page.\n\t\tbool releasePage = true;\n\t\t\n\t\tconst u32 numAllocationsPerPage = allocator->pageSize / blockSize;\n\t\tassert(numAllocationsPerPage >= 1, __LOCATION__);\n\t\tfor (u32 i = 0; i < numAllocationsPerPage; ++i) {\n\t\t\tAllocation* alloc = (Allocation*)mem;\n\t\t\tif (alloc->size > 0) {\n\t\t\t\treleasePage = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmem += blockSize;\n\t\t}\n\n\t\t// If appropriate, release entire page\n\t\tif (releasePage) {\n\t\t\t// Remove from free list\n\t\t\tmem = (u8*)allocator + startPage * allocator->pageSize;\n\t\t\tfor (u32 i = 0; i < numAllocationsPerPage; ++i) {\n\t\t\t\tAllocation* iter = (Allocation*)mem;\n\t\t\t\tmem += blockSize;\n\t\t\t\tassert(iter != 0, __LOCATION__);\n\n\t\t\t\tRemoveFromList(allocator, freeList, iter);\n\t\t\t}\n\n\t\t\t// Clear the tracking bits\n\t\t\tassert(startPage > 0, __LOCATION__);\n\t\t\tClearRange(allocator, startPage, 1);\n\t\t}\n\n\t\tif (allocator->releaseCallback != 0) {\n\t\t\tallocator->releaseCallback(allocator, header, oldSize, blockSize, startPage, releasePage ? 1 : 0);\n\t\t}\n\t}\n#endif\n} // Namespace Memory\n\n#if _WASM32\n\t#define export __attribute__ (( visibility( \"default\" ) )) extern \"C\"\n\n\textern unsigned char __heap_base;\n\textern unsigned char __data_end;\n\n\t// These are wasm shim functions\n\n\texport int GameAllocator_wasmHeapSize(int memSize) {\n\t\tvoid* heapPtr = &__heap_base;\n\n\t\tMemory::ptr_type heapAddr = (Memory::ptr_type)heapPtr;\n\t\tMemory::ptr_type maxAddr = (Memory::ptr_type)memSize;\n\n\t\tMemory::ptr_type heapSize = maxAddr - heapAddr;\n\t\treturn (int)heapSize;\n\t}\n\n\texport Memory::Allocator* GameAllocator_wasmInitialize(int heapSize) {\n\t\tvoid* memory = &__heap_base;\n\t\tu32 size = (u32)heapSize; //GameAllocator_wasmHeapSize(totalMemorySize);\n\n\t\tMemory::AlignAndTrim(&memory, &size);\n\t\tMemory::Allocator* allocator = Memory::Initialize(memory, size);\n\t\tMemory::wasmGlobalAllocator = allocator;\n\n\t\treturn allocator;\n\t}\n\t\n\texport void GameAllocator_wasmShutdown(Memory::Allocator* allocator) {\n\t\tMemory::Shutdown(allocator);\n\t}\n\t\n\texport void* GameAllocator_wasmAllocate(Memory::Allocator* allocator, int bytes, int alignment) {\n\t\treturn Memory::wasmGlobalAllocator->Allocate(bytes, alignment, \"GameAllocator_wasmAllocate\");\n\t}\n\n\texport void GameAllocator_wasmRelease(Memory::Allocator* allocator, void* mem) {\n\t\tMemory::wasmGlobalAllocator->Release(mem, \"GameAllocator_wasmAllocate\");\n\t}\n\n\texport void GameAllocator_wasmSet(void* mem, int val, int size) {\n\t\tMemory::Set(mem, (u8)val, (u32)size, \"GameAllocator_wasmAllocate\");\n\t}\n\n\texport void GameAllocator_wasmCopy(void* dst, const void* src, int size) {\n\t\tMemory::Copy(dst, src, (u32)size, \"GameAllocator_wasmAllocate\");\n\t}\n\n\texport int GameAllocator_wasmGetNumPages(Memory::Allocator* a) {\n        return a->size / a->pageSize;\n\t}\n\n\texport int GameAllocator_wasmGetNumPagesInUse(Memory::Allocator* a) {\n        return a->numPagesUsed;\n\t}\n\n\texport int GameAllocator_wasmGetPeekPagesUsed(Memory::Allocator* a) {\n        return a->peekPagesUsed;\n\t}\n\n\texport int GameAllocator_wasmGetRequestedBytes(Memory::Allocator* a) {\n        return a->requested;\n\t}\n\n\texport int GameAllocator_wasmGetServedBytes(Memory::Allocator* a) {\n\t\tu32 maskSize = AllocatorPageMaskSize(a) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n\t\tu32 metaDataSizeBytes = sizeof(Memory::Allocator) + (maskSize * sizeof(u32));\n\t\tu32 numberOfMasksUsed = metaDataSizeBytes / a->pageSize;\n\t\tif (metaDataSizeBytes % a->pageSize != 0) {\n\t\t\tnumberOfMasksUsed += 1;\n\t\t}\n\t\tmetaDataSizeBytes = numberOfMasksUsed * a->pageSize; // This way, allocatable will start on a page boundary\n\t\t// Account for meta data\n\t\tmetaDataSizeBytes += a->pageSize;\n\t\tnumberOfMasksUsed += 1;\n\n\t\tu32 numPages = a->size / a->pageSize;\n\t\tu32 usedPages = a->numPagesUsed;\n\t\tu32 freePages = numPages - usedPages;\n\t\tu32 overheadPages = metaDataSizeBytes / a->pageSize;\n\n\t\treturn (usedPages - overheadPages) * a->pageSize;\n\t}\n\n\texport int GameAllocator_wasmIsPageInUse(Memory::Allocator* a, int page) {\n\t\tu32 m = page / Memory::TrackingUnitSize;\n\t\tu32 b = page % Memory::TrackingUnitSize;\n\t\tu32 * mask = (u32*)Memory::AllocatorPageMask(a);\n\n\t\tbool set = mask[m] & (1 << b);\n\t\treturn set;\n\t}\n\n\texport int GameAllocator_wasmGetSize(Memory::Allocator* a) {\n        return a->size;\n\t}\n\n\texport int GameAllocator_wasmGetNumOverheadPages(Memory::Allocator* a) {\n\t\tu32 maskSize = Memory::AllocatorPageMaskSize(a) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n\t\tu32 metaDataSizeBytes = Memory::AllocatorPaddedSize() + (maskSize * sizeof(u32));\n\t\tu32 numberOfMasksUsed = metaDataSizeBytes / a->pageSize;\n\t\tif (metaDataSizeBytes % a->pageSize != 0) {\n\t\t\tnumberOfMasksUsed += 1;\n\t\t}\n\t\tmetaDataSizeBytes = numberOfMasksUsed * a->pageSize; // This way, allocatable will start on a page boundary\n\t\t// Account for meta data\n\t\tmetaDataSizeBytes += a->pageSize;\n\t\tnumberOfMasksUsed += 1;\n\n\t\tu32 overheadPages = metaDataSizeBytes / a->pageSize;\n\n\t\treturn (int)overheadPages;\n\t}\n\n\t// Helper functions\n\texport int GameAllocator_wasmStrLen(const char* str) {\n\t\tif (str == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst char *s = str;\n\t\twhile (*s) {\n\t\t\t++s;\n\t\t}\n\t\treturn (s - str);\n\t}\n\n    extern \"C\" void GameAllocator_jsBuildMemState(const u8* msg, int len);\n\n\texport void GameAllocator_wasmDumpState(Memory::Allocator* allocator) {\n\t\tMemory::Debug::MemInfo(allocator, [](const u8* mem, u32 size, void* userdata) {\n\t\t\tGameAllocator_jsBuildMemState(mem, (int)size);\n\t\t}, 0);\n\t}\n\n\texport void* GameAllocator_wasmGetAllocationDebugName(Memory::Allocator* allocator, void* _m) {\n\t\tconst char* l = \"mem_GetAllocationDebugName\";\n\n\t\tu8* debugPage = allocator->RequestDbgPage();\n\t\tu32 debugSize = allocator->pageSize;\n\t\t\n\t\t// Reset memory buffer\n\t\tMemory::Set(debugPage, 0, debugSize, l);\n\t\tu8* i_to_a_buff = debugPage; // Used to convert numbers to strings\n\t\tconst u32 i_to_a_buff_size = GameAllocator_wasmStrLen((const char*)\"18446744073709551615\") + 1; // u64 max\n\t\t\n\t\tu8* mem = i_to_a_buff + i_to_a_buff_size;\n\t\tu32 memSize = allocator->pageSize - i_to_a_buff_size;\n\t\t\n\t\tu8* m = (u8*)_m - sizeof(Memory::Allocation);\n\t\tMemory::Allocation* iter = (Memory::Allocation*)m;\n\n\t\tMemory::Copy(mem, \"Address: \", 9, l);\n\t\tmem += 9; memSize -= 9;\n\n\t\tu32 allocationOffset = (u32)((u8*)iter - (u8*)allocator);\n\t\ti32 i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, allocationOffset);\n\t\tMemory::Copy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tMemory::Copy(mem, \", size: \", 8, l);\n\t\tmem += 8; memSize -= 8;\n\n\t\ti_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->size);\n\t\tMemory::Copy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tMemory::Copy(mem, \", padded: \", 10, l);\n\t\tmem += 10; memSize -= 10;\n\n\t\tu32 alignment = iter->alignment;\n\t\tu32 allocationHeaderPadding = 0;\n\t\tif (alignment != 0) {  // Add padding to the header to compensate for alignment\n\t\t\tallocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n\t\t}\n\n\t\tu32 realSize = iter->size + (u32)(sizeof(Memory::Allocation)) + allocationHeaderPadding;\n\t\ti_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, realSize);\n\t\tMemory::Copy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tMemory::Copy(mem, \", alignment: \", 13, l);\n\t\tmem += 13; memSize -= 13;\n\n\t\ti_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->alignment);\n\t\tMemory::Copy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tMemory::Copy(mem, \", first page: \", 14, l);\n\t\tmem += 14; memSize -= 14;\n\n\t\ti_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, (allocationOffset) / allocator->pageSize);\n\t\tMemory::Copy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tMemory::Copy(mem, \", prev: \", 8, l);\n\t\tmem += 8; memSize -= 8;\n\n\t\ti_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->prevOffset);\n\t\tMemory::Copy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tMemory::Copy(mem, \", next: \", 8, l);\n\t\tmem += 8; memSize -= 8;\n\n\t\ti_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->nextOffset);\n\t\tMemory::Copy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tu32 pathLen = 0;\n\t#if MEM_TRACK_LOCATION\n\t\tif (iter->location != 0) {\n\t\t\tpathLen = GameAllocator_wasmStrLen((const char*)iter->location);\n\t\t}\n\t#endif\n\n\t\tMemory::Copy(mem, \", location: \", 12, l);\n\t\tmem += 12; memSize -= 12;\n\n\t#if MEM_TRACK_LOCATION\n\t\tif (iter->location == 0) {\n\t#else\n\t\t{\n\t#endif\n\t\t\tMemory::Copy(mem, \"null\", 4, l);\n\t\t\tmem += 4; memSize -= 4;\n\t\t}   \n\t#if MEM_TRACK_LOCATION\n\t\telse {\n\t\t\tMemory::Copy(mem, iter->location, pathLen, l);\n\t\t\tmem += pathLen;\n\t\t\tmemSize -= pathLen;\n\t\t}\n\t#endif\n\n\t\t*mem = '\\0';\n\n\t\tallocator->ReleaseDbgPage();\n\n\t\treturn debugPage + i_to_a_buff_size;\n\t}\n#endif\n\n\nu32 Memory::AlignAndTrim(void** memory, u32* size, u32 alignment, u32 pageSize) {\n#if ATLAS_64\n\tu64 ptr = (u64)((const void*)(*memory));\n#elif ATLAS_32\n\tu32 ptr = (u32)((const void*)(*memory));\n#else\n\t#error Unknown Platform\n#endif\n\tu32 delta = 0;\n\n    if (alignment != 0) {\n        // Align to 8 byte boundary. This is so the mask array lines up on a u64\n        u32 alignmentDelta = alignment - (u32)(ptr % alignment);\n        assert(alignmentDelta <= (*size), __LOCATION__);\n        if (alignmentDelta > *size) { // In release mode, we want to fail on asserts\n            *memory = 0;\n            *size = 0;\n            return 0;\n        }\n\n        if (ptr % alignment != 0) {\n            u8* mem = (u8*)(*memory);\n\n            delta += alignmentDelta;\n            mem += alignmentDelta;\n            *size -= alignmentDelta;\n            *memory = mem;\n        }\n    }\n\n\t// Trim to page size (4096) to make sure the provided memory can be chunked up perfectly\n\tif ((*size) % pageSize != 0) {\n\t\tu32 diff = (*size) % pageSize;\n\t\tassert(*size >= diff, __LOCATION__);\n        if (*size < diff) { // In release mode, fail on assert\n            *memory = 0;\n            *size = 0;\n            return 0;\n        }\n\t\t*size -= diff;\n\t\tdelta += diff;\n\t}\n\n\treturn delta;\n}\n\nMemory::Allocator* Memory::Initialize(void* memory, u32 bytes, u32 pageSize) {\n\tassert(pageSize % AllocatorAlignment == 0, \"Memory::Initialize, Page boundaries are expected to be on 8 bytes\");\n\t// First, make sure that the memory being passed in is aligned well\n#if ATLAS_64\n\tu64 ptr = (u64)((const void*)memory);\n#elif ATLAS_32\n\tu32 ptr = (u32)((const void*)memory);\n#else\n\t#error Unknown platform\n#endif\n\tassert(ptr % AllocatorAlignment == 0, \"Memory::Initialize, Memory being managed should be 8 byte aligned. Consider using Memory::AlignAndTrim\");\n\tassert(bytes % pageSize == 0, \"Memory::Initialize, the size of the memory being managed must be aligned to Memory::PageSize\");\n\tassert(bytes / pageSize >= 10, \"Memory::Initialize, minimum memory size is 10 pages, page size is Memory::PageSize\");\n\n\t// Set up the allocator\n\tAllocator* allocator = (Allocator*)memory;\n\tSet(memory, 0, sizeof(Allocator), \"Memory::Initialize\");\n\tallocator->size = bytes;\n\tallocator->pageSize = pageSize;\n\tallocator->mask = 0;\n\n\t// Set up the mask that will track our allocation data\n\tu32* mask = (u32*)AllocatorPageMask(allocator);\n\tu32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n\tSet(mask, 0, sizeof(u32) * maskSize, __LOCATION__);\n\t\n\t// Find how many pages the meta data for the header + allocation mask will take up. \n\t// Store the offset to first allocatable, \n\tu32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n\tu32 numberOfMasksUsed = metaDataSizeBytes / pageSize;\n\tif (metaDataSizeBytes % pageSize != 0) {\n\t\tnumberOfMasksUsed += 1;\n\t}\n\tmetaDataSizeBytes = numberOfMasksUsed * pageSize; // This way, allocatable will start on a page boundary\n\n\t// Add a debug page at the end\n\tmetaDataSizeBytes += pageSize;\n\tnumberOfMasksUsed += 1;\n\n\t//allocator->offsetToAllocatable = metaDataSizeBytes;\n\tallocator->scanBit = 0;\n\tSetRange(allocator, 0, numberOfMasksUsed);\n\tallocator->requested = 0;\n\n\tif (ptr % AllocatorAlignment != 0 || bytes % pageSize != 0 || bytes / pageSize < 10) {\n\t\tassert(false, __LOCATION__);\n\t\treturn 0;\n\t}\n\t\n\treturn (Allocator*)memory;\n}\n\nvoid Memory::Shutdown(Allocator* allocator) {\n\tassert(allocator != 0, \"Memory::Shutdown called without it being initialized\");\n\tu32* mask = (u32*)AllocatorPageMask(allocator);\n\tu32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n\tassert(allocator->size > 0, \"Memory::Shutdown, trying to shut down an un-initialized allocator\");\n\n\t// Unset tracking bits\n\tu32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n\tu32 numberOfMasksUsed = metaDataSizeBytes / allocator->pageSize;\n\tif (metaDataSizeBytes % allocator->pageSize != 0) {\n\t\tnumberOfMasksUsed += 1;\n\t}\n\tmetaDataSizeBytes = numberOfMasksUsed * allocator->pageSize;\n\n\t// There is a debug between the memory bitmask and allocatable memory\n\tmetaDataSizeBytes += allocator->pageSize;\n\tnumberOfMasksUsed += 1;\n\n\tClearRange(allocator, 0, numberOfMasksUsed);\n\tassert(allocator->requested == 0, \"Memory::Shutdown, not all memory has been released\");\n\n\tassert(allocator->active == 0, \"There are active allocations in Memory::Shutdown, leaking memory\");\n\tassert(allocator->free_64 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\");\n\tassert(allocator->free_128 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\");\n\tassert(allocator->free_256 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\");\n\tassert(allocator->free_512 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\");\n\tassert(allocator->free_1024 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\");\n\tassert(allocator->free_2048 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\");\n\n#if _DEBUG\n\t// In debug mode only, we will scan the entire mask to make sure all memory has been free-d\n\tfor (u32 i = 0; i < maskSize; ++i) {\n\t\tassert(mask[i] == 0, \"Page tracking unit isn't empty in Memory::Shutdown, leaking memory.\");\n\t}\n#endif\n}\n\nvoid Memory::Copy(void* dest, const void* source, u32 size, const char* location) {\n#if ATLAS_64\n\tu64 dst_ptr = (u64)((const void*)(dest));\n\tu64 src_ptr = (u64)((const void*)(source));\n\tu64 alignment = sizeof(u64);\n#elif ATLAS_32\n\tu32 dst_ptr = (u32)((const void*)(dest));\n\tu32 src_ptr = (u32)((const void*)(source));\n\tu32 alignment = sizeof(u32);\n#else\n\t#error Unknown Platform\n#endif\n\n\tif (dst_ptr % alignment != 0 || src_ptr % alignment != 0) {\n\t\t// Memory is not aligned well, fall back on slow copy\n\t\tu8* dst = (u8*)dest;\n\t\tconst u8* src = (const u8*)source;\n\t\tfor (u32 i = 0; i < size; ++i) {\n\t\t\tdst[i] = src[i];\n\t\t}\n\t\treturn;\n\t}\n\n#if ATLAS_64\n\tu64 size_64 = size / sizeof(u64);\n\tu64* dst_64 = (u64*)dest;\n\tconst u64* src_64 = (const u64*)source;\n\tfor (u32 i = 0; i < size_64; ++i) {\n\t\tdst_64[i] = src_64[i];\n\t}\n#endif\n\n#if ATLAS_64\n\tu32 size_32 = (u32)((size - size_64 * sizeof(u64)) / sizeof(u32));\n\tu32* dst_32 = (u32*)(dst_64 + size_64);\n\tconst u32* src_32 = (const u32*)(src_64 + size_64);\n#else \n\tu32 size_32 = size / sizeof(u32);\n\tu32* dst_32 = (u32*)dest;\n\tconst u32* src_32 = (u32*)source;\n#endif\n\tfor (u32 i = 0; i < size_32; ++i) {\n\t\tdst_32[i] = src_32[i];\n\t}\n\n#if ATLAS_64\n\tu32 size_16 = (u32)((size - size_64 * sizeof(u64) - size_32 * sizeof(u32)) / sizeof(u16));\n#else\n\tu32 size_16 = (size - size_32 * sizeof(u32)) / sizeof(u16);\n#endif\n\tu16* dst_16 = (u16*)(dst_32 + size_32);\n\tconst u16* src_16 = (const u16*)(src_32 + size_32);\n\tfor (u32 i = 0; i < size_16; ++i) {\n\t\tdst_16[i] = src_16[i];\n\t}\n\n#if ATLAS_64\n\tu32 size_8 = (u32)(size - size_64 * sizeof(u64) - size_32 * sizeof(u32) - size_16 * sizeof(u16));\n#else\n\tu32 size_8 = (size - size_32 * sizeof(u32) - size_16 * sizeof(u16));\n#endif\n\tu8* dst_8 = (u8*)(dst_16 + size_16);\n\tconst u8* src_8 = (const u8*)(src_16 + size_16);\n\tfor (u32 i = 0; i < size_8; ++i) {\n\t\tdst_8[i] = src_8[i];\n\t}\n\n#if ATLAS_64\n\tassert(size_64 * sizeof(u64) + size_32 * sizeof(u32) + size_16 * sizeof(u16) + size_8 == size, \"Number of pages not adding up\");\n#elif ATLAS_32\n\tassert(size_32 * sizeof(u32) + size_16 * sizeof(u16) + size_8 == size, \"Number of pages not adding up\");\n#else\n\t#error Unknown Platform\n#endif\n}\n\n// MSVC generates a recursive memset with this implementation. The naive one works fine.\n//#pragma optimize( \"\", off )\nvoid* Memory::Set(void* memory, u8 value, u32 size, const char* location) {\n\tif (memory == 0) {\n\t\treturn 0; // Can't set null!\n\t}\n\n#if ATLAS_64\n\tu64 ptr = (u64)((const void*)(memory));\n\tu64 alignment = sizeof(u64);\n#elif ATLAS_32\n\tu32 ptr = (u32)((const void*)(memory));\n\tu32 alignment = sizeof(u32);\n#else\n\t#error Unknown Platform\n#endif\n\n\tif (size <= alignment) {\n\t\tu8* mem = (u8*)memory;\n\t\t/* MSCV was optimizing this loop into a recursive call?\n\t\tfor (u32 i = 0; i < size; ++i) {\n\t\t\tmem[i] = value;\n\t\t}*/\n\t\twhile ((alignment--) > 0) {\n\t\t\t*mem = value;\n\t\t}\n\t\treturn memory;\n\t}\n\n\t// Algin memory if needed\n\tassert(alignment >= (ptr % alignment), __LOCATION__);\n\tu32 alignDelta = (u32)(alignment - (ptr % alignment));\n\tassert(alignDelta <= alignment, __LOCATION__);\n\tassert(size >= alignDelta, __LOCATION__);\n\n\tu8* mem = (u8*)(memory);\n\tif (alignDelta != 0) {\n\t\tif (alignDelta > size) {\n\t\t\talignDelta = size;\n\t\t}\n\t\tfor (u32 iter = 0; iter < alignDelta; ++iter) {\n\t\t\tmem[iter] = value;\n\t\t}\n\n\t\tmem += alignDelta;\n\t\tsize -= alignDelta;\n\t}\n\n#if ATLAS_64\n\tu64 size_64 = size / sizeof(u64);\n\tu64* ptr_64 = (u64*)mem;\n\tu32 v32 = (((u32)value) << 8) | (((u32)value) << 16) | (((u32)value) << 24) | ((u32)value);\n\tu64 val_64 = (((u64)v32) << 32) | ((u64)v32);\n\tfor (u32 i = 0; i < size_64; ++i) {\n\t\tptr_64[i] = val_64;\n\t}\n#endif\n\n#if ATLAS_64\n\tu32 size_32 = (u32)((size - size_64 * sizeof(u64)) / sizeof(u32));\n\tu32* ptr_32 = (u32*)(ptr_64 + size_64);\n#else\n\tu32 size_32 = size / sizeof(u32);\n\tu32* ptr_32 = (u32*)memory;\n#endif\n\tu32 val_32 = (((u32)value) << 8) | (((u32)value) << 16) | (((u32)value) << 24) | ((u32)value);\n\tfor (u32 i = 0; i < size_32; ++i) {\n\t\tptr_32[i] = val_32;\n\t}\n\t\n#if ATLAS_64\n\tu32 size_16 = (u32)((size - size_64 * sizeof(u64) - size_32 * sizeof(u32)) / sizeof(u16));\n#else\n\tu32 size_16 = (size - size_32 * sizeof(u32)) / sizeof(u16);\n#endif\n\tu16* ptr_16 = (u16*)(ptr_32 + size_32);\n\tu32 val_16 = (((u16)value) << 8) | ((u16)value);\n\tfor (u32 i = 0; i < size_16; ++i) {\n\t\tptr_16[i] = val_16;\n\t}\n\n#if ATLAS_64\n\tu32 size_8 = (u32)((size - size_64 * sizeof(u64) - size_32 * sizeof(u32) - size_16 * sizeof(u16)) / sizeof(u8));\n#else\n\tu32 size_8 = (size - size_32 * sizeof(u32) - size_16 * sizeof(u16));\n#endif\n\tu8* ptr_8 = (u8*)(ptr_16 + size_16);\n\tfor (u32 i = 0; i < size_8; ++i) {\n\t\tptr_8[i] = value;\n\t}\n\n#if ATLAS_64\n\tassert(size_64 * sizeof(u64) + size_32 * sizeof(u32) + size_16 * sizeof(u16) + size_8 == size, \"Number of pages not adding up\");\n#elif ATLAS_32\n\tassert(size_32 * sizeof(u32) + size_16 * sizeof(u16) + size_8 == size, \"Number of pages not adding up\");\n#else\n\t#error Unknown Platform\n#endif\n\n\treturn memory;\n}\n//#pragma optimize( \"\", on )\n\nu8* Memory::Allocator::RequestDbgPage() {\n\tMemory::Allocator* allocator = this;\n\n\tassert(allocator->mask == 0, \"Debug page already in use\");\n\tallocator->mask  = 1;\n\n\t// Set up the mask that will track our allocation data\n\tu32* mask = (u32*)AllocatorPageMask(allocator);\n\tu32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n\n\t// Find how many pages the meta data for the header + allocation mask will take up. \n\t// Store the offset to first allocatable, \n\tu32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n\tu32 numberOfMasksUsed = metaDataSizeBytes / allocator->pageSize;\n\tif (metaDataSizeBytes % allocator->pageSize != 0) {\n\t\tnumberOfMasksUsed += 1;\n\t}\n\tmetaDataSizeBytes = numberOfMasksUsed * allocator->pageSize; // This way, allocatable will start on a page boundary\n\n\t// Add a debug page at the end\n\tmetaDataSizeBytes += allocator->pageSize;\n\tnumberOfMasksUsed += 1;\n\n\tu8* debugPage = (u8*)allocator + metaDataSizeBytes - allocator->pageSize; // Debug page is always one page before allocatable\n\treturn debugPage;\n}\n\nvoid Memory::Allocator::ReleaseDbgPage() {\n\tMemory::Allocator* allocator = this;\n\n\tassert(allocator->mask != 0, \"Debug page not in use\");\n\tallocator->mask  = 0;\n}\n\nvoid* Memory::Allocator::Allocate(u32 bytes, u32 alignment, const char* location) {\n\tif (bytes == 0) {\n\t\tbytes = 1; // At least one byte required\n\t}\n\tMemory::Allocator* allocator = this;\n\tassert(bytes < allocator->size, \"Memory::Allocate trying to allocate more memory than is available\");\n\tassert(bytes < allocator->size - allocator->requested, \"Memory::Allocate trying to allocate more memory than is available\");\n\n\tu32 allocationHeaderPadding = 0;\n\tif (alignment != 0) { // Add paddnig to make sure we can align the memory\n\t\tallocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n\t}\n\tu32 allocationHeaderSize = sizeof(Allocation) + allocationHeaderPadding;\n\n\t// Add the header size to our allocation size\n\tu32 allocationSize = bytes; // Add enough space to pad out for alignment\n\tallocationSize += allocationHeaderSize;\n\n\t// Figure out how many pages are going to be needed to hold that much memory\n\tu32 numPagesRequested = allocationSize / allocator->pageSize + (allocationSize % allocator->pageSize ? 1 : 0);\n\tassert(numPagesRequested > 0, \"Memory::Allocate needs to request at least 1 page\");\n\t\n\t// We can record the request here. It's made before the allocation callback, and is valid for sub-allocations too.\n\tallocator->requested += bytes;\n\tassert(allocator->requested < allocator->size, __LOCATION__);\n\n#if MEM_USE_SUBALLOCATORS\n\tif (alignment == 0) {\n\t\tif (allocationSize <= 64) {\n\t\t\treturn SubAllocate(bytes, 64, &allocator->free_64, location, allocator);\n\t\t}\n\t\telse if (allocationSize <= 128) {\n\t\t\treturn SubAllocate(bytes, 128, &allocator->free_128, location, allocator);\n\t\t}\n\t\telse if (allocationSize <= 256) {\n\t\t\treturn SubAllocate(bytes, 256, &allocator->free_256, location, allocator);\n\t\t}\n\t\telse if (allocationSize <= 512) {\n\t\t\treturn SubAllocate(bytes, 512, &allocator->free_512, location, allocator);\n\t\t}\n\t\telse if (allocationSize <= 1024) {\n\t\t\treturn SubAllocate(bytes, 1024, &allocator->free_1024, location, allocator);\n\t\t}\n\t\telse if (allocationSize <= 2048) {\n\t\t\treturn SubAllocate(bytes, 2048, &allocator->free_2048, location, allocator);\n\t\t}\n\t}\n#endif\n\n\t// Find enough memory to allocate\n#if MEM_FIRST_FIT\n\tu32 firstPage = FindRange(allocator, numPagesRequested, 0);\n#else\n\tu32 firstPage = FindRange(allocator, numPagesRequested, allocator->scanBit);\n#endif\n\tassert(firstPage != 0, \"Memory::Allocate failed to find enough pages to fufill allocation\");\n\n\tSetRange(allocator, firstPage, numPagesRequested);\n\n\tif (firstPage == 0 || allocator->size % allocator->pageSize != 0) {\n\t\tassert(false, __LOCATION__);\n\t\treturn 0; // Fail this allocation in release mode\n\t}\n\t\n\t// Fill out header\n\tu8* mem = (u8*)allocator + firstPage * allocator->pageSize;\n\n\tu32 alignmentOffset = 0;\n\tif (alignment != 0) { \n#if ATLAS_64\n\t\tu64 mem_addr = (u64)((void*)mem) + sizeof(Allocation);\n#elif ATLAS_32\n\t\tu32 mem_addr = (u32)((void*)mem) + sizeof(Allocation);\n#else\n\t\t#error Unknown platform\n#endif\n\t\tif (mem_addr % alignment != 0) {\n\t\t\tmem_addr = (mem_addr + (alignment - 1)) / alignment * alignment;\n\t\t\tmem = (u8*)(mem_addr - sizeof(Allocation));\n\t\t}\n\t}\n\n\tAllocation* allocation = (Allocation*)mem;\n\tmem += sizeof(Allocation);\n\n\tallocation->alignment = alignment;\n\tallocation->size = bytes;\n\tallocation->prevOffset = 0;\n\tallocation->nextOffset = 0;\n#if MEM_TRACK_LOCATION\n\tallocation->location = location;\n#endif\n\n\t// Track allocated memory\n\tassert(allocation != allocator->active, __LOCATION__); // Should be impossible, but we could have bugs...\n\tAddtoList(allocator, &allocator->active, allocation);\n\n\t// Return memory\n#if MEM_CLEAR_ON_ALLOC\n\tSet(mem, 0, bytes, location);\n#elif MEM_DEBUG_ON_ALLOC\n\tconst u8 stamp[] = \"-MEMORY-\";\n\tu32 size = PageSize - allocationHeaderPadding - sizeof(Allocation);\n\tfor (u32 i = bytes; i < size; ++i) {\n\t\tmem[i] = stamp[(i - bytes) % 7];\n\t}\n#endif\n\n\tif (allocator->allocateCallback != 0) {\n\t\tu8* _mem = (u8*)allocator + firstPage * allocator->pageSize;\n\t\t_mem += allocationHeaderPadding;\n\t\tAllocation* _allocation = (Allocation*)_mem;\n\t\tallocator->allocateCallback(allocator, _allocation, bytes, allocationSize, firstPage, numPagesRequested);\n\t}\n\n\treturn mem;\n}\n\nvoid Memory::Allocator::Release(void* memory, const char* location) {\n\tassert(memory != 0, \"Memory:Free can't free a null pointer\");\n\tAllocator* allocator = this;\n\n\t// Retrieve allocation information from header. The allocation header always\n\t// preceeds the allocation.\n\tu8* mem = (u8*)memory;\n\tmem -= sizeof(Allocation);\n\tAllocation* allocation = (Allocation*)mem;\n\tassert(allocation != 0, \"Can't free null\");\n\tu32 alignment = allocation->alignment;\n\t\n\tu32 allocationSize = allocation->size; // Add enough space to pad out for alignment\n\t\n\tu32 allocationHeaderPadding = 0;\n\tif (alignment != 0) {  // Add padding to the header to compensate for alignment\n\t\tallocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n\t}\n\tu32 paddedAllocationSize = allocationSize + allocationHeaderPadding + sizeof(Allocation);\n\tassert(allocationSize != 0, \"Memory::Free, double free\");\n\t\n\tassert(allocator->requested >= allocation->size, \"Memory::Free releasing more memory than was requested\");\n\tassert(allocator->requested != 0, \"Memory::Free releasing more memory, but there is nothing to release\");\n\tallocator->requested -= allocation->size;\n\n#if MEM_USE_SUBALLOCATORS\n\tif (alignment == 0) {\n\t\tif (paddedAllocationSize <= 64) {\n\t\t\tSubRelease(memory, 64, &allocator->free_64, location, allocator);\n\t\t\treturn;\n\t\t}\n\t\telse if (paddedAllocationSize <= 128) {\n\t\t\tSubRelease(memory, 128, &allocator->free_128, location, allocator);\n\t\t\treturn;\n\t\t}\n\t\telse if (paddedAllocationSize <= 256) {\n\t\t\tSubRelease(memory, 256, &allocator->free_256, location, allocator);\n\t\t\treturn;\n\t\t}\n\t\telse if (paddedAllocationSize <= 512) {\n\t\t\tSubRelease(memory, 512, &allocator->free_512, location, allocator);\n\t\t\treturn;\n\t\t}\n\t\telse if (paddedAllocationSize <= 1024) {\n\t\t\tSubRelease(memory, 1024, &allocator->free_1024, location, allocator);\n\t\t\treturn;\n\t\t}\n\t\telse if (paddedAllocationSize <= 2048) {\n\t\t\tSubRelease(memory, 2048, &allocator->free_2048, location, allocator);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t// Clear the bits that where tracking this memory\n\tu8* firstMemory = (u8*)allocator;\n\tu32 address = (u32)((u8*)mem - (u8*)firstMemory);\n\n\tu32 firstPage = address / allocator->pageSize;\n\tu32 numPages = paddedAllocationSize / allocator->pageSize + (paddedAllocationSize % allocator->pageSize ? 1 : 0);\n\tClearRange(allocator, firstPage, numPages);\n\n\t// Unlink tracking\n\tRemoveFromList(allocator, &allocator->active, allocation);\n\n\t// Set the size to 0, to indicate that this header has been free-d\n\tu32 oldSize = allocation->size;\n\tallocation->size = 0;\n\n\tif (allocator->releaseCallback != 0) {\n\t\tallocator->releaseCallback(allocator, allocation, oldSize, paddedAllocationSize, firstPage, numPages);\n\t}\n}\n\nnamespace Memory {\n\tnamespace Debug {\n\t\tclass str_const { // constexpr string\n\t\tprivate:\n\t\t\tconst char* const p_;\n\t\t\tconst ptr_type sz_;\n\t\tprivate:\n\t\t\tstr_const& operator= (const str_const& other) = delete;\n\t\t\tstr_const(const str_const&& other) = delete;\n\t\t\tstr_const& operator= (const str_const&& other) = delete;\n\t\tpublic:\n\t\t\ttemplate<ptr_type N>\n\t\t\tconstexpr str_const(const char(&a)[N]) noexcept : // ctor\n\t\t\t\tp_(a), sz_(N - 1) {\n\t\t\t}\n\t\t\tconstexpr char operator[](ptr_type n) const noexcept { // []\n#if _WASM32\n\t\t\t\tif (n >= sz_) {\n\t\t\t\t\tAssert(false, \"n >= sz\", __LINE__, __FILE__);\n\t\t\t\t}\n\t\t\t\treturn p_[n];\n#else\n\t\t\t\treturn n < sz_ ? p_[n] : (*(char*)((void*)0) = '\\0');\n#endif\n\t\t\t}\n\t\t\tconstexpr u32 size() const noexcept { // string length\n\t\t\t\treturn (u32)sz_;\n\t\t\t} // size()\n\t\t\tconst char* begin() const noexcept { // start iterator\n\t\t\t\treturn p_;\n\t\t\t} // begin()\n\t\t\tconst char* end() const noexcept { // End iterator\n\t\t\t\treturn p_ + sz_;\n\t\t\t} // end()\n\t\t\ttemplate<typename T>\n\t\t\tT& operator<<(T& stream) { // Stream op\n\t\t\t\tstream << p_;\n\t\t\t\treturn stream;\n\t\t\t} // <<\n\t\t};\n\n\t\tu32 u32toa(u8* dest, u32 destSize, u32 num) { // Returns length of string\n\t\t\tSet(dest, 0, destSize, \"Memory::Debug::u32toa\");\n\n\t\t\tu32 count = 0;\n\t\t\tu32 tmp = num;\n\t\t\twhile (tmp != 0) {\n\t\t\t\ttmp = tmp / 10;\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\n\t\t\tif (count == 0) {\n\t\t\t\t*dest = '0';\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tu8* last = dest + count - 1;\n\t\t\twhile (num != 0) {\n\t\t\t\tu32 digit = num % 10;\n\t\t\t\tnum = num / 10;\n\n\t\t\t\t*last-- = '0' + digit;\n\t\t\t}\n\n\t\t\treturn count;\n\t\t}\n\n\t\tu32 strlen(const u8* str) {\n\t\t\tconst u8* s;\n\t\t\tfor (s = str; *s; ++s);\n\t\t\treturn (u32)(s - str);\n\t\t}\n\t} // namespace Debug\n} // namespace Memory\n\nvoid Memory::Debug::MemInfo(Allocator* allocator, WriteCallback callback, void* userdata) {\n\tconst char* l = \"Memory::Debug::DumpAllocationHeaders\";\n\n\tu8* debugPage = allocator->RequestDbgPage();\n\tu32 debugSize = allocator->pageSize;\n\n\t// Reset memory buffer\n\tSet(debugPage, 0, debugSize, l);\n\tu8* i_to_a_buff = debugPage; // Used to convert numbers to strings\n\tconst u32 i_to_a_buff_size = strlen((const u8*)\"18446744073709551615\") + 1; // u64 max\n\tu8* mem = i_to_a_buff + i_to_a_buff_size;\n\tu32 memSize = allocator->pageSize - i_to_a_buff_size;\n\n\t{ // Tracking %d Pages, %d KiB (%d MiB)\n\t\tconstexpr str_const out0(\"Tracking \");\n\t\tCopy(mem, out0.begin(), out0.size(), l);\n\t\tmem += out0.size();\n\t\tmemSize -= out0.size();\n\n\t\tu32 numPages = allocator->size / allocator->pageSize;\n\t\tassert(allocator->size % allocator->pageSize == 0, l);\n\n\t\tu32 i_len = u32toa(i_to_a_buff, i_to_a_buff_size, numPages);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out1(\" pages, Page size: \");\n\t\tCopy(mem, out1.begin(), out1.size(), l);\n\t\tmem += out1.size();\n\t\tmemSize -= out1.size();\n\n\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, allocator->pageSize);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out11(\" bytes\\nTotal memory size: \");\n\t\tCopy(mem, out11.begin(), out11.size(), l);\n\t\tmem += out11.size();\n\t\tmemSize -= out11.size();\n\n\t\tu32 kib = allocator->size / 1024;\n\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, kib);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out2(\" KiB (\");\n\t\tCopy(mem, out2.begin(), out2.size(), l);\n\t\tmem += out2.size();\n\t\tmemSize -= out2.size();\n\n\t\tu32 mib = kib / 1024;\n\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, mib);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out3(\" MiB)\\n\");\n\t\tCopy(mem, out3.begin(), out3.size(), l);\n\t\tmem += out3.size();\n\t\tmemSize -= out3.size();\n\t}\n\n\t// Dump what's been written so far\n\tmem = i_to_a_buff + i_to_a_buff_size;\n\tcallback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n\t// Reset memory buffer\n\tSet(debugPage, 0, debugSize, l);\n\ti_to_a_buff = debugPage; // Used to convert numbers to strings\n\tmem = i_to_a_buff + i_to_a_buff_size;\n\tmemSize = allocator->pageSize - i_to_a_buff_size;\n\n\t{ // Pages: %d free, %d used, %d overhead\n\t\tconstexpr str_const out0(\"Page state: \");\n\t\tCopy(mem, out0.begin(), out0.size(), l);\n\t\tmem += out0.size();\n\t\tmemSize -= out0.size();\n\n\t\tu32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n\t\tu32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n\t\tu32 numberOfMasksUsed = metaDataSizeBytes / allocator->pageSize;\n\t\tif (metaDataSizeBytes % allocator->pageSize != 0) {\n\t\t\tnumberOfMasksUsed += 1;\n\t\t}\n\t\tmetaDataSizeBytes = numberOfMasksUsed * allocator->pageSize; // This way, allocatable will start on a page boundary\n\t\t// Account for meta data\n\t\tmetaDataSizeBytes += allocator->pageSize;\n\t\tnumberOfMasksUsed += 1;\n\n\t\tu32 numPages = allocator->size / allocator->pageSize;\n\t\tassert(allocator->size % allocator->pageSize == 0, l);\n\t\tu32 usedPages = allocator->numPagesUsed;\n\t\tassert(usedPages <= numPages, l);\n\t\tu32 freePages = numPages - usedPages;\n\t\tu32 overheadPages = metaDataSizeBytes / allocator->pageSize;\n\t\tassert(usedPages >= overheadPages, l);\n\t\tusedPages -= overheadPages;\n\n\t\tu32 i_len = u32toa(i_to_a_buff, i_to_a_buff_size, freePages);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out1(\" free, \");\n\t\tCopy(mem, out1.begin(), out1.size(), l);\n\t\tmem += out1.size();\n\t\tmemSize -= out1.size();\n\n\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, usedPages);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out2(\" used, \");\n\t\tCopy(mem, out2.begin(), out2.size(), l);\n\t\tmem += out2.size();\n\t\tmemSize -= out2.size();\n\n\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, overheadPages);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out3(\" overhead\\nRequested: \");\n\t\tCopy(mem, out3.begin(), out3.size(), l);\n\t\tmem += out3.size();\n\t\tmemSize -= out3.size();\n\n\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, allocator->requested);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out4(\" bytes, Served: \");\n\t\tCopy(mem, out4.begin(), out4.size(), l);\n\t\tmem += out4.size();\n\t\tmemSize -= out4.size();\n\n\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, usedPages * allocator->pageSize);\n\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\tmem += i_len;\n\t\tmemSize -= i_len;\n\n\t\tconstexpr str_const out5(\" bytes\\n\");\n\t\tCopy(mem, out5.begin(), out5.size(), l);\n\t\tmem += out5.size();\n\t\tmemSize -= out5.size();\n\t}\n\n\t// Dump what's been written so far\n\tmem = i_to_a_buff + i_to_a_buff_size;\n\tcallback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n\t// Reset memory buffer\n\tSet(debugPage, 0, debugSize, l);\n\ti_to_a_buff = debugPage; // Used to convert numbers to strings\n\tmem = i_to_a_buff + i_to_a_buff_size;\n\tmemSize = allocator->pageSize - i_to_a_buff_size;\n\n\t{ // Dump active list\n\t\tconstexpr str_const out0(\"\\nActive allocations:\\n\");\n\t\tCopy(mem, out0.begin(), out0.size(), l);\n\t\tmem += out0.size();\n\t\tmemSize -= out0.size();\n\n\t\tfor (Allocation* iter = allocator->active; iter != 0; iter = (iter->nextOffset == 0)? 0 : (Allocation*)((u8*)allocator + iter->nextOffset)) {\n\t\t\t//u64 address = (u64)((void*)iter);\n\t\t\tu64 alloc_address = (u64)((void*)allocator);\n\n\t\t\tconstexpr str_const out5(\"\\t\");\n\t\t\tCopy(mem, out5.begin(), out5.size(), l);\n\t\t\tmem += out5.size();\n\t\t\tmemSize -= out5.size();\n\n\t\t\tu32 allocationOffset = (u32)((u8*)iter - (u8*)allocator);\n\t\t\ti32 i_len = u32toa(i_to_a_buff, i_to_a_buff_size, allocationOffset);\n\t\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\t\tmem += i_len;\n\t\t\tmemSize -= i_len;\n\n\t\t\tconstexpr str_const out2(\", size: \");\n\t\t\tCopy(mem, out2.begin(), out2.size(), l);\n\t\t\tmem += out2.size();\n\t\t\tmemSize -= out2.size();\n\n\t\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->size);\n\t\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\t\tmem += i_len;\n\t\t\tmemSize -= i_len;\n\n\t\t\tconstexpr str_const out3(\", padded: \");\n\t\t\tCopy(mem, out3.begin(), out3.size(), l);\n\t\t\tmem += out3.size();\n\t\t\tmemSize -= out3.size();\n\n\t\t\tu32 alignment = iter->alignment;\n\t\t\tu32 allocationHeaderPadding = 0;\n\t\t\tif (alignment != 0) {  // Add padding to the header to compensate for alignment\n\t\t\t\tallocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n\t\t\t}\n\n\t\t\tu32 realSize = iter->size + (u32)(sizeof(Allocation)) + allocationHeaderPadding;\n\t\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, realSize);\n\t\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\t\tmem += i_len;\n\t\t\tmemSize -= i_len;\n\n\t\t\tconstexpr str_const out6(\", alignment: \");\n\t\t\tCopy(mem, out6.begin(), out6.size(), l);\n\t\t\tmem += out6.size();\n\t\t\tmemSize -= out6.size();\n\n\t\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->alignment);\n\t\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\t\tmem += i_len;\n\t\t\tmemSize -= i_len;\n\n\t\t\tconstexpr str_const outfp(\", first page: \");\n\t\t\tCopy(mem, outfp.begin(), outfp.size(), l);\n\t\t\tmem += outfp.size();\n\t\t\tmemSize -= outfp.size();\n\n\t\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, (allocationOffset) / allocator->pageSize);\n\t\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\t\tmem += i_len;\n\t\t\tmemSize -= i_len;\n\n\t\t\tconstexpr str_const out0(\", prev: \");\n\t\t\tCopy(mem, out0.begin(), out0.size(), l);\n\t\t\tmem += out0.size();\n\t\t\tmemSize -= out0.size();\n\n\t\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->prevOffset);\n\t\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\t\tmem += i_len;\n\t\t\tmemSize -= i_len;\n\n\t\t\tconstexpr str_const out1(\", next: \");\n\t\t\tCopy(mem, out1.begin(), out1.size(), l);\n\t\t\tmem += out1.size();\n\t\t\tmemSize -= out1.size();\n\n\t\t\ti_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->nextOffset);\n\t\t\tCopy(mem, i_to_a_buff, i_len, l);\n\t\t\tmem += i_len;\n\t\t\tmemSize -= i_len;\n\n\t\t\tu32 pathLen = 0;\n#if MEM_TRACK_LOCATION\n\t\t\tif (iter->location != 0) {\n\t\t\t\tpathLen = strlen((const u8*)iter->location);\n\t\t\t}\n#endif\n\n\t\t\tif (memSize < allocator->pageSize / 4 || memSize < (pathLen + pathLen / 4)) { // Drain occasiaonally\n\t\t\t\t// Dump what's been written so far\n\t\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\t\tcallback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n\t\t\t\t// Reset memory buffer\n\t\t\t\tSet(debugPage, 0, debugSize, l);\n\t\t\t\ti_to_a_buff = debugPage; // Used to convert numbers to strings\n\t\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\t\tmemSize = allocator->pageSize - i_to_a_buff_size;\n\t\t\t}\n\n\t\t\tconstexpr str_const out_loc(\", location: \");\n\t\t\tCopy(mem, out_loc.begin(), out_loc.size(), l);\n\t\t\tmem += out_loc.size();\n\t\t\tmemSize -= out_loc.size();\n\n#if MEM_TRACK_LOCATION\n\t\t\tif (iter->location == 0) {\n#else\n\t\t\t{\n#endif\n\t\t\t\tassert(pathLen == 0, __LOCATION__);\n\t\t\t\t\n\t\t\t\tconstexpr str_const out_loc(\"null\");\n\t\t\t\tCopy(mem, out_loc.begin(), out_loc.size(), l);\n\t\t\t\tmem += out_loc.size();\n\t\t\t\tmemSize -= out_loc.size();\n\t\t\t}\n#if MEM_TRACK_LOCATION\n\t\t\telse {\n\t\t\t\tassert(pathLen != 0, __LOCATION__);\n\t\t\t\tCopy(mem, iter->location, pathLen, l);\n\t\t\t\tmem += pathLen;\n\t\t\t\tmemSize -= pathLen;\n\t\t\t}\n#endif\n\n\t\t\tconstexpr str_const out4(\"\\n\");\n\t\t\tCopy(mem, out4.begin(), out4.size(), l);\n\t\t\tmem += out4.size();\n\t\t\tmemSize -= out4.size();\n\t\t}\n\n\t\tif (memSize != allocator->pageSize - i_to_a_buff_size) { // Drain if needed\n\t\t\t// Dump what's been written so far\n\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\tcallback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n\t\t\t// Reset memory buffer\n\t\t\tSet(debugPage, 0, debugSize, l);\n\t\t\ti_to_a_buff = debugPage; // Used to convert numbers to strings\n\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\tmemSize = allocator->pageSize - i_to_a_buff_size;\n\t\t}\n\t}\n\n\t// Reset memory buffer\n\tSet(debugPage, 0, debugSize, l);\n\ti_to_a_buff = debugPage; // Used to convert numbers to strings\n\tmem = i_to_a_buff + i_to_a_buff_size;\n\tmemSize = allocator->pageSize - i_to_a_buff_size;\n\n\tconstexpr str_const newline(\"\\n\\t\");\n\tconstexpr str_const isSet(\"0\");\n\tconstexpr str_const notSet(\"-\");\n\n\t{ // Draw a pretty graph\n\t\tu32 numPages = allocator->size / allocator->pageSize;\n\t\tu32* mask = (u32*)AllocatorPageMask(allocator);\n\n\t\tconstexpr str_const out5(\"\\nPage chart:\\n\\t\");\n\t\tCopy(mem, out5.begin(), out5.size(), l);\n\t\tmem += out5.size();\n\t\tmemSize -= out5.size();\n\n\t\tfor (u32 i = 0; i < numPages; ++i) {\n\t\t\tu32 m = i / TrackingUnitSize;\n\t\t\tu32 b = i % TrackingUnitSize;\n\n\t\t\tbool set = mask[m] & (1 << b);\n\t\t\tif (set) {\n\t\t\t\tCopy(mem, isSet.begin(), isSet.size(), l);\n\t\t\t\tmem += isSet.size();\n\t\t\t\tmemSize -= isSet.size();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCopy(mem, notSet.begin(), notSet.size(), l);\n\t\t\t\tmem += notSet.size();\n\t\t\t\tmemSize -= notSet.size();\n\t\t\t}\n\n\t\t\tif ((i + 1) % 80 == 0) {\n\t\t\t\tCopy(mem, newline.begin(), newline.size(), l);\n\t\t\t\tmem += newline.size();\n\t\t\t\tmemSize -= newline.size();\n\t\t\t}\n\n\t\t\tif (memSize < allocator->pageSize / 4) { // Drain occasiaonally\n\t\t\t\t// Dump what's been written so far\n\t\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\t\tcallback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n\t\t\t\t// Reset memory buffer\n\t\t\t\tSet(debugPage, 0, debugSize, l);\n\t\t\t\ti_to_a_buff = debugPage; // Used to convert numbers to strings\n\t\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\t\tmemSize = allocator->pageSize - i_to_a_buff_size;\n\t\t\t}\n\t\t}\n\n\t\tif (memSize != allocator->pageSize - i_to_a_buff_size) { // Drain if needed\n\t\t\t// Dump what's been written so far\n\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\tcallback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n\t\t\t// Reset memory buffer\n\t\t\tSet(debugPage, 0, debugSize, l);\n\t\t\ti_to_a_buff = debugPage; // Used to convert numbers to strings\n\t\t\tmem = i_to_a_buff + i_to_a_buff_size;\n\t\t\tmemSize = allocator->pageSize - i_to_a_buff_size;\n\t\t}\n\t}\n\n\tallocator->ReleaseDbgPage();\n}\n\nvoid Memory::Debug::PageContent(Allocator* allocator, u32 page, WriteCallback callback, void* userdata) {\n\tu8* mem = (u8*)allocator + page * allocator->pageSize;\n\tu32 chunk = allocator->pageSize / 4; // Does not need to be a multiple of 4\n\t\n\tcallback(mem, chunk, userdata);\n\tmem += chunk;\n\tcallback(mem, chunk, userdata);\n\tmem += chunk;\n\tcallback(mem, chunk, userdata);\n\tmem += chunk;\n\tcallback(mem, allocator->pageSize - (allocator->pageSize / 4) * 3, userdata);\n}\n\n#pragma warning(default:6011)\n#pragma warning(default:28182)\n","\u00ef\u00bb\u00bf#include \"math.h\"\n\nfloat Sqrtf(const float& n) {\n\tif (n == 0.0f) {\n\t\treturn 0.0f;\n\t}\n\n\tint i = 0x2035AD0C + (*(int*)&n >> 1);\n\treturn n / *(float*)&i + *(float*)&i * 0.25f;\n}\n\nfloat Fabsf(const float& f) {\n\tif (f < 0.0f) {\n\t\treturn f * -1.0f;\n\t}\n\treturn f;\n}\n\ndouble Sin(const double& x) {\n\tint i = 1;\n\tdouble cur = x;\n\tdouble acc = 1;\n\tdouble fact = 1;\n\tdouble pow = x;\n\twhile (acc > .00000001 && i < 100) {\n\t\tfact *= ((2 * i) * (2 * i + 1));\n\t\tpow *= -1 * x * x;\n\t\tacc = pow / fact;\n\t\tif (acc < 0.0) { // fabs\n\t\t\tacc *= -1.0;\n\t\t}\n\t\tcur += acc;\n\t\ti++;\n\t}\n\treturn cur;\n}\n\n#define PI         (3.1415926535f)\n#define HALF_PI    (0.5f * PI)\n#define TWO_PI     (2.0f * PI)\n#define TWO_PI_INV (1.0f / TWO_PI)\n\ninline float Hill(float x)\n{\n\tconst float a0 = 1.0f;\n\tconst float a2 = 2.0f / PI - 12.0f / (PI * PI);\n\tconst float a3 = 16.0f / (PI * PI * PI) - 4.0f / (PI * PI);\n\tconst float xx = x * x;\n\tconst float xxx = xx * x;\n\n\treturn a0 + a2 * xx + a3 * xxx;\n}\n\nfloat FastSin(float x)\n{\n\t// wrap x within [0, TWO_PI)\n\tconst float a = x * TWO_PI_INV;\n\tx -= static_cast<int>(a) * TWO_PI;\n\tif (x < 0.0f)\n\t\tx += TWO_PI;\n\n\t// 4 pieces of hills\n\tif (x < HALF_PI)\n\t\treturn Hill(HALF_PI - x);\n\telse if (x < PI)\n\t\treturn Hill(x - HALF_PI);\n\telse if (x < 3.0f * HALF_PI)\n\t\treturn -Hill(3.0f * HALF_PI - x);\n\telse\n\t\treturn -Hill(x - 3.0f * HALF_PI);\n}\n\nfloat FastCos(float x)\n{\n\treturn FastSin(x + HALF_PI);\n}\n\nfloat Tan(const float& d) {\n\treturn FastSin(d) / FastCos(d);\n}\n\n\nvec3 operator+(const vec3& l, const vec3& r) {\n\treturn vec3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\n\nvec3 operator-(const vec3& l, const vec3& r) {\n\treturn vec3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\n\nvec3 operator*(const vec3& v, float f) {\n\treturn vec3(v.x * f, v.y * f, v.z * f);\n}\n\nvec3 operator*(const vec3& l, const vec3& r) {\n\treturn vec3(l.x * r.x, l.y * r.y, l.z * r.z);\n}\n\nfloat dot(const vec3& l, const vec3& r) {\n\treturn l.x * r.x + l.y * r.y + l.z * r.z;\n}\n\nfloat lenSq(const vec3& v) {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nfloat len(const vec3& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n\tif (lenSq < VEC3_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\treturn Sqrtf(lenSq);\n}\n\nvoid normalize(vec3& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n\tif (lenSq < VEC3_EPSILON) {\n\t\treturn;\n\t}\n\tfloat invLen = 1.0f / Sqrtf(lenSq);\n\n\tv.x *= invLen;\n\tv.y *= invLen;\n\tv.z *= invLen;\n}\n\nvec3 normalized(const vec3& v) {\n\tfloat lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n\tif (lenSq < VEC3_EPSILON) {\n\t\treturn v;\n\t}\n\tfloat invLen = 1.0f / Sqrtf(lenSq);\n\n\treturn vec3(\n\t\tv.x * invLen,\n\t\tv.y * invLen,\n\t\tv.z * invLen\n\t);\n}\n\nvec3 project(const vec3& a, const vec3& b) {\n\tfloat magBSq = len(b);\n\tif (magBSq < VEC3_EPSILON) {\n\t\treturn vec3();\n\t}\n\tfloat scale = dot(a, b) / magBSq;\n\treturn b * scale;\n}\n\nvec3 reject(const vec3& a, const vec3& b) {\n\tvec3 projection = project(a, b);\n\treturn a - projection;\n}\n\nvec3 reflect(const vec3& a, const vec3& b) {\n\tfloat magBSq = len(b);\n\tif (magBSq < VEC3_EPSILON) {\n\t\treturn vec3();\n\t}\n\tfloat scale = dot(a, b) / magBSq;\n\tvec3 proj2 = b * (scale * 2);\n\treturn a - proj2;\n}\n\nvec3 cross(const vec3& l, const vec3& r) {\n\treturn vec3(\n\t\tl.y * r.z - l.z * r.y,\n\t\tl.z * r.x - l.x * r.z,\n\t\tl.x * r.y - l.y * r.x\n\t);\n}\n\nvec3 lerp(const vec3& s, const vec3& e, float t) {\n\treturn vec3(\n\t\ts.x + (e.x - s.x) * t,\n\t\ts.y + (e.y - s.y) * t,\n\t\ts.z + (e.z - s.z) * t\n\t);\n}\n\nvec3 nlerp(const vec3& s, const vec3& e, float t) {\n\tvec3 linear(\n\t\ts.x + (e.x - s.x) * t,\n\t\ts.y + (e.y - s.y) * t,\n\t\ts.z + (e.z - s.z) * t\n\t);\n\treturn normalized(linear);\n}\n\nbool operator==(const vec3& l, const vec3& r) {\n\tvec3 diff(l - r);\n\treturn lenSq(diff) < VEC3_EPSILON;\n}\n\nbool operator!=(const vec3& l, const vec3& r) {\n\treturn !(l == r);\n}\n\nbool operator==(const mat4& a, const mat4& b) {\n\tfor (int i = 0; i < 16; ++i) {\n\t\tif (Fabsf(a.v[i] - b.v[i]) > MAT4_EPSILON) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool operator!=(const mat4& a, const mat4& b) {\n\treturn !(a == b);\n}\n\nmat4 operator+(const mat4& a, const mat4& b) {\n\treturn mat4(\n\t\ta.xx + b.xx, a.xy + b.xy, a.xz + b.xz, a.xw + b.xw,\n\t\ta.yx + b.yx, a.yy + b.yy, a.yz + b.yz, a.yw + b.yw,\n\t\ta.zx + b.zx, a.zy + b.zy, a.zz + b.zz, a.zw + b.zw,\n\t\ta.tx + b.tx, a.ty + b.ty, a.tz + b.tz, a.tw + b.tw\n\t);\n}\n\nmat4 operator*(const mat4& m, float f) {\n\treturn mat4(\n\t\tm.xx * f, m.xy * f, m.xz * f, m.xw * f,\n\t\tm.yx * f, m.yy * f, m.yz * f, m.yw * f,\n\t\tm.zx * f, m.zy * f, m.zz * f, m.zw * f,\n\t\tm.tx * f, m.ty * f, m.tz * f, m.tw * f\n\t);\n}\n\n#define M4D(aRow, bCol) \\\n    a.v[0 * 4 + aRow] * b.v[bCol * 4 + 0] + \\\n    a.v[1 * 4 + aRow] * b.v[bCol * 4 + 1] + \\\n    a.v[2 * 4 + aRow] * b.v[bCol * 4 + 2] + \\\n    a.v[3 * 4 + aRow] * b.v[bCol * 4 + 3]\n\nmat4 operator*(const mat4& a, const mat4& b) {\n\treturn mat4(\n\t\tM4D(0, 0), M4D(1, 0), M4D(2, 0), M4D(3, 0), // Column 0\n\t\tM4D(0, 1), M4D(1, 1), M4D(2, 1), M4D(3, 1), // Column 1\n\t\tM4D(0, 2), M4D(1, 2), M4D(2, 2), M4D(3, 2), // Column 2\n\t\tM4D(0, 3), M4D(1, 3), M4D(2, 3), M4D(3, 3)  // Column 3\n\t);\n}\n\n#define M4V4D(mRow, x, y, z, w) \\\n    x * m.v[0 * 4 + mRow] + \\\n    y * m.v[1 * 4 + mRow] + \\\n    z * m.v[2 * 4 + mRow] + \\\n    w * m.v[3 * 4 + mRow]\n\nvec4 operator*(const mat4& m, const vec4& v) {\n\treturn vec4(\n\t\tM4V4D(0, v.x, v.y, v.z, v.w),\n\t\tM4V4D(1, v.x, v.y, v.z, v.w),\n\t\tM4V4D(2, v.x, v.y, v.z, v.w),\n\t\tM4V4D(3, v.x, v.y, v.z, v.w)\n\t);\n}\n\nvec3 transformVector(const mat4& m, const vec3& v) {\n\treturn vec3(\n\t\tM4V4D(0, v.x, v.y, v.z, 0.0f),\n\t\tM4V4D(1, v.x, v.y, v.z, 0.0f),\n\t\tM4V4D(2, v.x, v.y, v.z, 0.0f)\n\t);\n}\n\nvec3 transformPoint(const mat4& m, const vec3& v) {\n\treturn vec3(\n\t\tM4V4D(0, v.x, v.y, v.z, 1.0f),\n\t\tM4V4D(1, v.x, v.y, v.z, 1.0f),\n\t\tM4V4D(2, v.x, v.y, v.z, 1.0f)\n\t);\n}\n\nvec3 transformPoint(const mat4& m, const vec3& v, float& w) {\n\tfloat _w = w;\n\tw = M4V4D(3, v.x, v.y, v.z, _w);\n\n\treturn vec3(\n\t\tM4V4D(0, v.x, v.y, v.z, _w),\n\t\tM4V4D(1, v.x, v.y, v.z, _w),\n\t\tM4V4D(2, v.x, v.y, v.z, _w)\n\t);\n}\n\n#define M4SWAP(x, y) \\\n    {float t = x; x = y; y = t; }\n\nvoid transpose(mat4& m) {\n\tM4SWAP(m.yx, m.xy);\n\tM4SWAP(m.zx, m.xz);\n\tM4SWAP(m.tx, m.xw);\n\tM4SWAP(m.zy, m.yz);\n\tM4SWAP(m.ty, m.yw);\n\tM4SWAP(m.tz, m.zw);\n}\n\nmat4 transposed(const mat4& m) {\n\treturn mat4(\n\t\tm.xx, m.yx, m.zx, m.tx,\n\t\tm.xy, m.yy, m.zy, m.ty,\n\t\tm.xz, m.yz, m.zz, m.tz,\n\t\tm.xw, m.yw, m.zw, m.tw\n\t);\n}\n\n#define M4_3X3MINOR(c0, c1, c2, r0, r1, r2) \\\n    (m.v[c0 * 4 + r0] * (m.v[c1 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c1 * 4 + r2] * m.v[c2 * 4 + r1]) - \\\n     m.v[c1 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c2 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c2 * 4 + r1]) + \\\n     m.v[c2 * 4 + r0] * (m.v[c0 * 4 + r1] * m.v[c1 * 4 + r2] - m.v[c0 * 4 + r2] * m.v[c1 * 4 + r1]))\n\nfloat determinant(const mat4& m) {\n\treturn  m.v[0] * M4_3X3MINOR(1, 2, 3, 1, 2, 3)\n\t\t- m.v[4] * M4_3X3MINOR(0, 2, 3, 1, 2, 3)\n\t\t+ m.v[8] * M4_3X3MINOR(0, 1, 3, 1, 2, 3)\n\t\t- m.v[12] * M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n}\n\nmat4 adjugate(const mat4& m) {\n\t// Cofactor(M[i, j]) = Minor(M[i, j]] * pow(-1, i + j)\n\tmat4 cofactor;\n\n\tcofactor.v[0] = M4_3X3MINOR(1, 2, 3, 1, 2, 3);\n\tcofactor.v[1] = -M4_3X3MINOR(1, 2, 3, 0, 2, 3);\n\tcofactor.v[2] = M4_3X3MINOR(1, 2, 3, 0, 1, 3);\n\tcofactor.v[3] = -M4_3X3MINOR(1, 2, 3, 0, 1, 2);\n\n\tcofactor.v[4] = -M4_3X3MINOR(0, 2, 3, 1, 2, 3);\n\tcofactor.v[5] = M4_3X3MINOR(0, 2, 3, 0, 2, 3);\n\tcofactor.v[6] = -M4_3X3MINOR(0, 2, 3, 0, 1, 3);\n\tcofactor.v[7] = M4_3X3MINOR(0, 2, 3, 0, 1, 2);\n\n\tcofactor.v[8] = M4_3X3MINOR(0, 1, 3, 1, 2, 3);\n\tcofactor.v[9] = -M4_3X3MINOR(0, 1, 3, 0, 2, 3);\n\tcofactor.v[10] = M4_3X3MINOR(0, 1, 3, 0, 1, 3);\n\tcofactor.v[11] = -M4_3X3MINOR(0, 1, 3, 0, 1, 2);\n\n\tcofactor.v[12] = -M4_3X3MINOR(0, 1, 2, 1, 2, 3);\n\tcofactor.v[13] = M4_3X3MINOR(0, 1, 2, 0, 2, 3);\n\tcofactor.v[14] = -M4_3X3MINOR(0, 1, 2, 0, 1, 3);\n\tcofactor.v[15] = M4_3X3MINOR(0, 1, 2, 0, 1, 2);\n\n\treturn transposed(cofactor);\n}\n\nmat4 inverse(const mat4& m) {\n\tfloat det = determinant(m);\n\n\tif (det == 0.0f) { // Epsilon check would need to be REALLY small\n\t\treturn mat4();\n\t}\n\tmat4 adj = adjugate(m);\n\n\treturn adj * (1.0f / det);\n}\n\nvoid invert(mat4& m) {\n\tfloat det = determinant(m);\n\n\tif (det == 0.0f) {\n\t\tm = mat4();\n\t\treturn;\n\t}\n\n\tm = adjugate(m) * (1.0f / det);\n}\n\nmat4 frustum(float l, float r, float b, float t, float n, float f) {\n\tif (l == r || t == b || n == f) {\n\t\treturn mat4(); // Error\n\t}\n\treturn mat4(\n\t\t(2.0f * n) / (r - l), 0, 0, 0,\n\t\t0, (2.0f * n) / (t - b), 0, 0,\n\t\t(r + l) / (r - l), (t + b) / (t - b), (-(f + n)) / (f - n), -1,\n\t\t0, 0, (-2 * f * n) / (f - n), 0\n\t);\n}\n\nmat4 perspective(float fov, float aspect, float znear, float zfar) {\n\tfloat ymax = znear * (float)Tan(fov * 3.14159265359f / 360.0f);\n\tfloat xmax = ymax * aspect;\n\n\treturn frustum(-xmax, xmax, -ymax, ymax, znear, zfar);\n}\n\nmat4 ortho(float l, float r, float b, float t, float n, float f) {\n\tif (l == r || t == b || n == f) {\n\t\treturn mat4(); // Error\n\t}\n\treturn mat4(\n\t\t2.0f / (r - l), 0, 0, 0,\n\t\t0, 2.0f / (t - b), 0, 0,\n\t\t0, 0, -2.0f / (f - n), 0,\n\t\t-((r + l) / (r - l)), -((t + b) / (t - b)), -((f + n) / (f - n)), 1\n\t);\n}\n\nmat4 lookAt(const vec3& position, const vec3& target, const vec3& up) {\n\t// Remember, forward is negative z\n\tvec3 f = normalized(target - position) * -1.0f;\n\tvec3 r = cross(up, f); // Right handed\n\tif (r == vec3(0, 0, 0)) {\n\t\treturn mat4(); // Error\n\t}\n\tnormalize(r);\n\tvec3 u = normalized(cross(f, r)); // Right handed\n\n\tvec3 t = vec3(\n\t\t-dot(r, position),\n\t\t-dot(u, position),\n\t\t-dot(f, position)\n\t);\n\n\treturn mat4(\n\t\t// Transpose upper 3x3 matrix to invert it\n\t\tr.x, u.x, f.x, 0,\n\t\tr.y, u.y, f.y, 0,\n\t\tr.z, u.z, f.z, 0,\n\t\tt.x, t.y, t.z, 1\n\t);\n}\n\nquat angleAxis(float angle, const vec3& axis) {\n\tvec3 norm = normalized(axis);\n\tfloat s = FastSin(angle * 0.5f);\n\n\treturn quat(\n\t\tnorm.x * s,\n\t\tnorm.y * s,\n\t\tnorm.z * s,\n\t\tFastCos(angle * 0.5f)\n\t);\n}\n\nquat fromTo(const vec3& from, const vec3& to) {\n\tvec3 f = normalized(from);\n\tvec3 t = normalized(to);\n\n\tif (f == t) {\n\t\treturn quat();\n\t}\n\telse if (f == t * -1.0f) {\n\t\tvec3 ortho = vec3(1, 0, 0);\n\t\tif (Fabsf(f.y) < Fabsf(f.x)) {\n\t\t\tortho = vec3(0, 1, 0);\n\t\t}\n\t\tif (Fabsf(f.z) < Fabsf(f.y) && Fabsf(f.z) < Fabsf(f.x)) {\n\t\t\tortho = vec3(0, 0, 1);\n\t\t}\n\n\t\tvec3 axis = normalized(cross(f, ortho));\n\t\treturn quat(axis.x, axis.y, axis.z, 0);\n\t}\n\n\tvec3 half = normalized(f + t);\n\tvec3 axis = cross(f, half);\n\n\treturn quat(\n\t\taxis.x,\n\t\taxis.y,\n\t\taxis.z,\n\t\tdot(f, half)\n\t);\n}\n\nvec3 getAxis(const quat& quat) {\n\treturn normalized(vec3(quat.x, quat.y, quat.z));\n}\n\nfloat getAngle(const quat& quat) {\n\treturn 2.0f * (1.0f / FastCos(quat.w));\n}\n\nquat operator+(const quat& a, const quat& b) {\n\treturn quat(\n\t\ta.x + b.x,\n\t\ta.y + b.y,\n\t\ta.z + b.z,\n\t\ta.w + b.w\n\t);\n}\n\nquat operator-(const quat& a, const quat& b) {\n\treturn quat(\n\t\ta.x - b.x,\n\t\ta.y - b.y,\n\t\ta.z - b.z,\n\t\ta.w - b.w\n\t);\n}\n\nquat operator*(const quat& a, float b) {\n\treturn quat(\n\t\ta.x * b,\n\t\ta.y * b,\n\t\ta.z * b,\n\t\ta.w * b\n\t);\n}\n\nquat operator-(const quat& q) {\n\treturn quat(\n\t\t-q.x,\n\t\t-q.y,\n\t\t-q.z,\n\t\t-q.w\n\t);\n}\n\nbool operator==(const quat& left, const quat& right) {\n\treturn (Fabsf(left.x - right.x) <= QUAT_EPSILON &&\n\t\tFabsf(left.y - right.y) <= QUAT_EPSILON &&\n\t\tFabsf(left.z - right.z) <= QUAT_EPSILON &&\n\t\tFabsf(left.w - left.w) <= QUAT_EPSILON);\n}\n\nbool operator!=(const quat& a, const quat& b) {\n\treturn !(a == b);\n}\n\nbool sameOrientation(const quat& left, const quat& right) {\n\treturn (Fabsf(left.x - right.x) <= QUAT_EPSILON && Fabsf(left.y - right.y) <= QUAT_EPSILON &&\n\t\tFabsf(left.z - right.z) <= QUAT_EPSILON && Fabsf(left.w - left.w) <= QUAT_EPSILON)\n\t\t|| (Fabsf(left.x + right.x) <= QUAT_EPSILON && Fabsf(left.y + right.y) <= QUAT_EPSILON &&\n\t\t\tFabsf(left.z + right.z) <= QUAT_EPSILON && Fabsf(left.w + left.w) <= QUAT_EPSILON);\n}\n\nfloat dot(const quat& a, const quat& b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}\n\nfloat lenSq(const quat& q) {\n\treturn q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n}\n\nfloat len(const quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn 0.0f;\n\t}\n\treturn Sqrtf(lenSq);\n}\n\nvoid normalize(quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn;\n\t}\n\tfloat i_len = 1.0f / Sqrtf(lenSq);\n\n\tq.x *= i_len;\n\tq.y *= i_len;\n\tq.z *= i_len;\n\tq.w *= i_len;\n}\n\nquat normalized(const quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn quat();\n\t}\n\tfloat i_len = 1.0f / Sqrtf(lenSq);\n\n\treturn quat(\n\t\tq.x * i_len,\n\t\tq.y * i_len,\n\t\tq.z * i_len,\n\t\tq.w * i_len\n\t);\n}\n\nquat conjugate(const quat& q) {\n\treturn quat(\n\t\t-q.x,\n\t\t-q.y,\n\t\t-q.z,\n\t\tq.w\n\t);\n}\n\nquat inverse(const quat& q) {\n\tfloat lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\tif (lenSq < QUAT_EPSILON) {\n\t\treturn quat();\n\t}\n\tfloat recip = 1.0f / lenSq;\n\n\t// conjugate / norm\n\treturn quat(\n\t\t-q.x * recip,\n\t\t-q.y * recip,\n\t\t-q.z * recip,\n\t\tq.w * recip\n\t);\n}\n\n#if 1\nquat operator*(const quat& Q1, const quat& Q2) {\n\treturn quat(\n\t\tQ2.x * Q1.w + Q2.y * Q1.z - Q2.z * Q1.y + Q2.w * Q1.x,\n\t\t-Q2.x * Q1.z + Q2.y * Q1.w + Q2.z * Q1.x + Q2.w * Q1.y,\n\t\tQ2.x * Q1.y - Q2.y * Q1.x + Q2.z * Q1.w + Q2.w * Q1.z,\n\t\t-Q2.x * Q1.x - Q2.y * Q1.y - Q2.z * Q1.z + Q2.w * Q1.w\n\t);\n}\n#else\nquat operator*(const quat& Q1, const quat& Q2) {\n\tquat result;\n\tresult.scalar = Q2.scalar * Q1.scalar - dot(Q2.vector, Q1.vector);\n\tresult.vector = (Q1.vector * Q2.scalar) + (Q2.vector * Q1.scalar) + cross(Q2.vector, Q1.vector);\n\treturn result;\n}\n#endif\n\nvec3 operator*(const quat& q, const vec3& v) {\n\treturn q.vector * 2.0f * dot(q.vector, v) +\n\t\tv * (q.scalar * q.scalar - dot(q.vector, q.vector)) +\n\t\tcross(q.vector, v) * 2.0f * q.scalar;\n}\n\nquat mix(const quat& from, const quat& to, float t) {\n\treturn from * (1.0f - t) + to * t;\n}\n\nquat nlerp(const quat& from, const quat& to, float t) {\n\treturn normalized(from + (to - from) * t);\n}\n\nquat operator^(const quat& q, float f) {\n\tfloat angle = 2.0f * (1.0f / FastCos(q.scalar));\n\tvec3 axis = normalized(q.vector);\n\n\tfloat halfCos = FastCos(f * angle * 0.5f);\n\tfloat halfSin = FastSin(f * angle * 0.5f);\n\n\treturn quat(\n\t\taxis.x * halfSin,\n\t\taxis.y * halfSin,\n\t\taxis.z * halfSin,\n\t\thalfCos\n\t);\n}\n\nquat slerp(const quat& start, const quat& end, float t) {\n\tif (Fabsf(dot(start, end)) > 1.0f - QUAT_EPSILON) {\n\t\treturn nlerp(start, end, t);\n\t}\n\n\treturn normalized(((inverse(start) * end) ^ t) * start);\n}\n\nquat lookRotation(const vec3& direcion, const vec3& up) {\n\t// Find orthonormal basis vectors\n\tvec3 f = normalized(direcion);\n\tvec3 u = normalized(up);\n\tvec3 r = cross(u, f);\n\tu = cross(f, r);\n\n\t// From world forward to object forward\n\tquat f2d = fromTo(vec3(0, 0, 1), f);\n\n\t// what direction is the new object up?\n\tvec3 objectUp = f2d * vec3(0, 1, 0);\n\t// From object up to desired up\n\tquat u2u = fromTo(objectUp, u);\n\n\t// Rotate to forward direction first, then twist to correct up\n\tquat result = f2d * u2u;\n\t// Don\u00ef\u00bf\u00bdt forget to normalize the result\n\treturn normalized(result);\n}\n\nmat4 quatToMat4(const quat& q) {\n\tvec3 r = q * vec3(1, 0, 0);\n\tvec3 u = q * vec3(0, 1, 0);\n\tvec3 f = q * vec3(0, 0, 1);\n\n\treturn mat4(\n\t\tr.x, r.y, r.z, 0,\n\t\tu.x, u.y, u.z, 0,\n\t\tf.x, f.y, f.z, 0,\n\t\t0, 0, 0, 1\n\t);\n}\n\nquat mat4ToQuat(const mat4& m) {\n\tvec3 up = normalized(vec3(m.up.x, m.up.y, m.up.z));\n\tvec3 forward = normalized(vec3(m.forward.x, m.forward.y, m.forward.z));\n\tvec3 right = cross(up, forward);\n\tup = cross(forward, right);\n\n\treturn lookRotation(forward, up);\n}","#ifndef _H_MATH_\n#define _H_MATH_\n\n#define VEC3_EPSILON 0.000001f\n#define MAT4_EPSILON 0.000001f\n#define QUAT_EPSILON 0.000001f\n#define QUAT_DEG2RAD 0.0174533f\n#define QUAT_RAD2DEG 57.2958f\n\nfloat FastSin(float x);\nfloat FastCos(float x);\n\ntemplate<typename T>\nstruct TVec2 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t};\n\t\tT v[2];\n\t};\n\tinline TVec2() : x(T(0)), y(T(0)) { }\n\tinline TVec2(T _x, T _y) :\n\t\tx(_x), y(_y) { }\n\tinline TVec2(T* fv) :\n\t\tx(fv[0]), y(fv[1]) { }\n};\n\ntypedef TVec2<float> vec2;\ntypedef TVec2<int> ivec2;\ntypedef TVec2<unsigned int> uivec2;\n\nstruct vec3 {\n\tunion {\n\t\tstruct {\n\t\t\tfloat x;\n\t\t\tfloat y;\n\t\t\tfloat z;\n\t\t};\n\t\tfloat v[3];\n\t};\n\tinline vec3() : x(0.0f), y(0.0f), z(0.0f) { }\n\tinline vec3(float _x, float _y, float _z) :\n\t\tx(_x), y(_y), z(_z) { }\n\tinline vec3(float* fv) :\n\t\tx(fv[0]), y(fv[1]), z(fv[2]) { }\n};\n\nvec3 operator+(const vec3& l, const vec3& r);\nvec3 operator-(const vec3& l, const vec3& r);\nvec3 operator*(const vec3& v, float f);\nvec3 operator*(const vec3& l, const vec3& r);\nfloat dot(const vec3& l, const vec3& r);\nfloat lenSq(const vec3& v);\nfloat len(const vec3& v);\nvoid normalize(vec3& v);\nvec3 normalized(const vec3& v);\nvec3 project(const vec3& a, const vec3& b);\nvec3 reject(const vec3& a, const vec3& b);\nvec3 reflect(const vec3& a, const vec3& b);\nvec3 cross(const vec3& l, const vec3& r);\nvec3 lerp(const vec3& s, const vec3& e, float t);\nvec3 nlerp(const vec3& s, const vec3& e, float t);\nbool operator==(const vec3& l, const vec3& r);\nbool operator!=(const vec3& l, const vec3& r);\n\ntemplate<typename T>\nstruct TVec4 {\n\tunion {\n\t\tstruct {\n\t\t\tT x;\n\t\t\tT y;\n\t\t\tT z;\n\t\t\tT w;\n\t\t};\n\t\tT v[4];\n\t};\n\tinline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n\tinline TVec4(T _x, T _y, T _z, T _w) :\n\t\tx(_x), y(_y), z(_z), w(_w) { }\n\tinline TVec4(T* fv) :\n\t\tx(fv[0]), y(fv[1]), z(fv[2]), w(fv[3]) { }\n};\n\ntypedef TVec4<float> vec4;\ntypedef TVec4<int> ivec4;\ntypedef TVec4<unsigned int> uivec4;\n\n\nstruct mat4 {\n\tunion {\n\t\tfloat v[16];\n\t\tstruct {\n\t\t\tvec4 right;\n\t\t\tvec4 up;\n\t\t\tvec4 forward;\n\t\t\tvec4 position;\n\t\t};\n\t\tstruct {\n\t\t\t//            row 1     row 2     row 3     row 4\n\t\t\t/* column 1 */float xx; float xy; float xz; float xw;\n\t\t\t/* column 2 */float yx; float yy; float yz; float yw;\n\t\t\t/* column 3 */float zx; float zy; float zz; float zw;\n\t\t\t/* column 4 */float tx; float ty; float tz; float tw;\n\t\t};\n\t\tstruct {\n\t\t\tfloat c0r0; float c0r1; float c0r2; float c0r3;\n\t\t\tfloat c1r0; float c1r1; float c1r2; float c1r3;\n\t\t\tfloat c2r0; float c2r1; float c2r2; float c2r3;\n\t\t\tfloat c3r0; float c3r1; float c3r2; float c3r3;\n\t\t};\n\t\tstruct {\n\t\t\tfloat r0c0; float r1c0; float r2c0; float r3c0;\n\t\t\tfloat r0c1; float r1c1; float r2c1; float r3c1;\n\t\t\tfloat r0c2; float r1c2; float r2c2; float r3c2;\n\t\t\tfloat r0c3; float r1c3; float r2c3; float r3c3;\n\t\t};\n\t};\n\tinline mat4() :\n\t\txx(1), xy(0), xz(0), xw(0),\n\t\tyx(0), yy(1), yz(0), yw(0),\n\t\tzx(0), zy(0), zz(1), zw(0),\n\t\ttx(0), ty(0), tz(0), tw(1) {}\n\n\tinline mat4(float* fv) :\n\t\txx(fv[0]), xy(fv[1]), xz(fv[2]), xw(fv[3]),\n\t\tyx(fv[4]), yy(fv[5]), yz(fv[6]), yw(fv[7]),\n\t\tzx(fv[8]), zy(fv[9]), zz(fv[10]), zw(fv[11]),\n\t\ttx(fv[12]), ty(fv[13]), tz(fv[14]), tw(fv[15]) { }\n\n\tinline mat4(\n\t\tfloat _00, float _01, float _02, float _03,\n\t\tfloat _10, float _11, float _12, float _13,\n\t\tfloat _20, float _21, float _22, float _23,\n\t\tfloat _30, float _31, float _32, float _33) :\n\t\txx(_00), xy(_01), xz(_02), xw(_03),\n\t\tyx(_10), yy(_11), yz(_12), yw(_13),\n\t\tzx(_20), zy(_21), zz(_22), zw(_23),\n\t\ttx(_30), ty(_31), tz(_32), tw(_33) { }\n}; // end mat4 struct\n\nbool operator==(const mat4& a, const mat4& b);\nbool operator!=(const mat4& a, const mat4& b);\nmat4 operator+(const mat4& a, const mat4& b);\nmat4 operator*(const mat4& m, float f);\nmat4 operator*(const mat4& a, const mat4& b);\nvec4 operator*(const mat4& m, const vec4& v);\nvec3 transformVector(const mat4& m, const vec3& v);\nvec3 transformPoint(const mat4& m, const vec3& v);\nvec3 transformPoint(const mat4& m, const vec3& v, float& w);\nvoid transpose(mat4& m);\nmat4 transposed(const mat4& m);\nfloat determinant(const mat4& m);\nmat4 adjugate(const mat4& m);\nmat4 inverse(const mat4& m);\nvoid invert(mat4& m);\nmat4 frustum(float l, float r, float b, float t, float n, float f);\nmat4 perspective(float fov, float aspect, float znear, float zfar);\nmat4 ortho(float l, float r, float b, float t, float n, float f);\nmat4 lookAt(const vec3& position, const vec3& target, const vec3& up);\n\nstruct quat {\n\tunion {\n\t\tstruct {\n\t\t\tfloat x;\n\t\t\tfloat y;\n\t\t\tfloat z;\n\t\t\tfloat w;\n\t\t};\n\t\tstruct {\n\t\t\tvec3 vector;\n\t\t\tfloat scalar;\n\t\t};\n\t\tfloat v[4];\n\t};\n\n\tinline quat() :\n\t\tx(0), y(0), z(0), w(1) { }\n\tinline quat(float _x, float _y, float _z, float _w) :\n\t\tx(_x), y(_y), z(_z), w(_w) {}\n};\n\nquat angleAxis(float angle, const vec3& axis);\nquat fromTo(const vec3& from, const vec3& to);\nvec3 getAxis(const quat& quat);\nfloat getAngle(const quat& quat);\nquat operator+(const quat& a, const quat& b);\nquat operator-(const quat& a, const quat& b);\nquat operator*(const quat& a, float b);\nquat operator-(const quat& q);\nbool operator==(const quat& left, const quat& right);\nbool operator!=(const quat& a, const quat& b);\nbool sameOrientation(const quat& left, const quat& right);\nfloat dot(const quat& a, const quat& b);\nfloat lenSq(const quat& q);\nfloat len(const quat& q);\nvoid normalize(quat& q);\nquat normalized(const quat& q);\nquat conjugate(const quat& q);\nquat inverse(const quat& q);\nquat operator*(const quat& Q1, const quat& Q2);\nvec3 operator*(const quat& q, const vec3& v);\nquat mix(const quat& from, const quat& to, float t);\nquat nlerp(const quat& from, const quat& to, float t);\nquat operator^(const quat& q, float f);\nquat operator^(const quat& q, float f);\nquat slerp(const quat& start, const quat& end, float t);\nquat lookRotation(const vec3& direcion, const vec3& up);\nmat4 quatToMat4(const quat& q);\nquat mat4ToQuat(const mat4& m);\n\n#endif","#include \"../Win32Sample/FileLoaders.h\"\n#include \"math.h\"\n\nnamespace Internal {\n\tvoid CalculateTangentArray(unsigned int vertexCount, vec3* vertex, vec3* normal,\n\t\tvec2* texcoord, vec3* outTangent)\n\t{\n\t\tvec3* tan1 = (vec3*)wasmGraphics_AllocateMem(vertexCount * 2 * sizeof(vec3));\n\t\tvec3* tan2 = tan1 + vertexCount;\n\n\t\tMemory::Set(tan1, 0, vertexCount * 2 * sizeof(vec3), __LOCATION__);\n\n\t\tfor (long a = 0; a < vertexCount; a += 3)\n\t\t{\n\t\t\tvec3 v1 = vertex[a + 0];\n\t\t\tvec3 v2 = vertex[a + 1];\n\t\t\tvec3 v3 = vertex[a + 2];\n\n\t\t\tvec2 w1 = texcoord[a + 0];\n\t\t\tvec2 w2 = texcoord[a + 1];\n\t\t\tvec2 w3 = texcoord[a + 2];\n\n\t\t\tfloat x1 = v2.x - v1.x;\n\t\t\tfloat x2 = v3.x - v1.x;\n\t\t\tfloat y1 = v2.y - v1.y;\n\t\t\tfloat y2 = v3.y - v1.y;\n\t\t\tfloat z1 = v2.z - v1.z;\n\t\t\tfloat z2 = v3.z - v1.z;\n\n\t\t\tfloat s1 = w2.x - w1.x;\n\t\t\tfloat s2 = w3.x - w1.x;\n\t\t\tfloat t1 = w2.y - w1.y;\n\t\t\tfloat t2 = w3.y - w1.y;\n\n\t\t\tfloat r = 1.0f / (s1 * t2 - s2 * t1);\n\t\t\tvec3 sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,\n\t\t\t\t(t2 * z1 - t1 * z2) * r);\n\t\t\tvec3 tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,\n\t\t\t\t(s1 * z2 - s2 * z1) * r);\n\n\t\t\ttan1[a + 0] = tan1[a + 0] + sdir;\n\t\t\ttan1[a + 1] = tan1[a + 1] + sdir;\n\t\t\ttan1[a + 2] = tan1[a + 2] + sdir;\n\n\t\t\ttan2[a + 0] = tan2[a + 0] + tdir;\n\t\t\ttan2[a + 1] = tan2[a + 1] + tdir;\n\t\t\ttan2[a + 2] = tan2[a + 2] + tdir;\n\t\t}\n\n\t\tfor (long a = 0; a < vertexCount; a++) {\n\t\t\tvec3 n = normal[a];\n\t\t\tvec3 t = tan1[a];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\t\t\t\n\t\t\toutTangent[a] = normalized(t - n * dot(n, t));\n\n\t\t\t// Calculate handedness\n\t\t\t//tangent[a].w = (dot(cross(n, t), tan2[a]) < 0.0F) ? -1.0F : 1.0F;\n\t\t}\n\n\t\twasmGraphics_ReleaseMem(tan1);\n\t}\n\n\tu32 StrLen(const char* str) {\n\t\tif (str == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst char *s = str;\n\t\twhile (*s) {\n\t\t\t++s;\n\t\t}\n\t\treturn (s - str);\n\t}\n}\n\nexport void FinishLoadingText(const char* path, OnTextFileLoaded triggerThisCallback, void* withThisData, u32 whichHasThisManyBytes) {\n\tTextFile* result = (TextFile*)wasmGraphics_AllocateMem(sizeof(TextFile));\n\tresult->length = whichHasThisManyBytes;\n\tresult->text = (char*)withThisData;\n\ttriggerThisCallback(path, result);\n}\n\nextern \"C\" void wasmFileLoaderLoadText(const char* path, int len, OnTextFileLoaded callback);\n\nvoid LoadText(const char* path, OnTextFileLoaded onTextLoad) {\n\tu32 path_len = Internal::StrLen(path);\n\n\t// Here we pass the path to load, and the callback to eventually call back to js.\n\t// js will stash that pointer, and load the file. When the file is loaded, \n\t// FinishLoadingText will be called. onTextLoad will be it's first argument,\n\t// It will allocate the proper data to turn the rest of its arguments into a text file.\n\t\n\twasmFileLoaderLoadText(path, path_len, onTextLoad);\n}\n\nvoid ReleaseText(TextFile* file) {\n\twasmGraphics_ReleaseMem(file->text);\n\twasmGraphics_ReleaseMem(file);\n}\n\nexport void FinishLoadingMesh(const char* path, OnMeshLoaded triggerThisCallback, void* withThisData, u32 whichHasThisManyBytes) {\n\tunsigned int* uint_data = (unsigned int*)withThisData;\n\tunsigned int sizes[3];\n\tsizes[0] = uint_data[0];\n\tsizes[1] = uint_data[1];\n\tsizes[2] = uint_data[2];\n\n\tunsigned int mem_needed = sizeof(MeshFile) \n\t\t+ sizeof(float) * 3 * sizes[0]; // tan\n\n\tvoid* mem = wasmGraphics_AllocateMem(mem_needed + 1);\n\tunsigned char* iter = (unsigned char* )mem;\n\t\n\tMeshFile* result = (MeshFile*)iter;\n\titer += sizeof(MeshFile);\n\n\tfloat* pos = (float*)(uint_data + 3);\n\tfloat* nrm = pos + sizes[0] * 3;\n\tfloat* tex = nrm + sizes[1] * 3;\n\n\tresult->tan = (float*)iter;\n\tInternal::CalculateTangentArray(sizes[0], (vec3*)pos, (vec3*)nrm, (vec2*)tex, (vec3*)result->tan);\n\n\tresult->numTan = sizes[0];\n\tresult->numPos = sizes[0];\n\tresult->numNrm = sizes[1];\n\tresult->numTex = sizes[2];\n\tresult->pos = pos;\n\tresult->nrm = nrm;\n\tresult->tex = tex;\n\n\ttriggerThisCallback(path, result);\n}\n\nextern \"C\" void wasmFileLoaderLoadMesh(const char* path, int len, OnMeshLoaded callback);\n\nvoid LoadMesh(const char* path, OnMeshLoaded onMeshLoad) {\n\tu32 path_len = Internal::StrLen(path);\n\n\twasmFileLoaderLoadMesh(path, path_len, onMeshLoad);\n}\n\nvoid ReleaseMesh(MeshFile* file) {\n\twasmGraphics_ReleaseMem(file);\n}\n\nextern \"C\" void wasmFileLoaderLoadTexture(const char* path, int len, OnTextureLoaded callback);\n\nexport void FinishLoadingTexture(const char* path, OnTextureLoaded triggerThisCallback, void* withThisData, u32 whichHasThisManyBytes) {\n\tunsigned int* uint_data = (unsigned int*)withThisData;\n\tunsigned int sizes[3];\n\tsizes[0] = uint_data[0];\n\tsizes[1] = uint_data[1];\n\tsizes[2] = uint_data[2];\n\n\tunsigned int mem_needed = sizeof(TextureFile);\n\tTextureFile* result = (TextureFile*)wasmGraphics_AllocateMem(mem_needed);\n\n\tresult->width = sizes[0];\n\tresult->height = sizes[1];\n\tresult->channels = sizes[2];\n\tresult->data = (unsigned char*)(uint_data + 3);\n\n\ttriggerThisCallback(path, result);\n}\n\nvoid LoadTexture(const char* path, OnTextureLoaded onTextureLoad) {\n\tu32 path_len = Internal::StrLen(path);\n\n\twasmFileLoaderLoadTexture(path, path_len, onTextureLoad);\n}\n\nvoid ReleaseTexture(TextureFile* file) {\n\tGraphicsAssert(file->data != 0, \"Can't free null pointer\");\n\tunsigned int* uint_data = ((unsigned int*)file->data) - 3;\n\tGraphicsAssert(uint_data[0] == file->width, \"Bad width\");\n\tGraphicsAssert(uint_data[1] == file->height, \"Bad height\");\n\tGraphicsAssert(uint_data[2] == file->channels, \"Bad channel count\");\n\twasmGraphics_ReleaseMem(uint_data);\n\twasmGraphics_ReleaseMem(file);\n}\n\n","#include \"Graphics.h\"\n#include \"Win32Sample/math.h\"\n#include \"Win32Sample/FileLoaders.h\"\n\n#define SHADOWMAP_RES 256\n\nGraphics::Index\t\t\tgLightmapMVP;\n\nGraphics::FrameBuffer*  gLightmapFBO;\nGraphics::Texture*\t\tgLightmapDepth;\nGraphics::Texture*\t\tgLightmapColor;\n\nGraphics::Shader*\t\tgLightmapDrawShader;\nGraphics::Shader*\t\tgLightmapBlitShader;\nGraphics::Index\t\t\tgLightmapFboAttachment;\nGraphics::VertexLayout*\tgLightmapMesh;\nGraphics::VertexLayout* gLightmapSkullLayout;\nGraphics::VertexLayout* gLightmapPlaneLayout;\n\nstruct PCMState {\n\tGraphics::Shader* shader;\n\tGraphics::Index modelIndex;\n\tGraphics::Index shadowIndex;\n\tGraphics::Index viewIndex;\n\tGraphics::Index projectionIndex;\n\tGraphics::Index albedoIndex;\n\tGraphics::Index lightmapIndex;\n\tGraphics::Index normalIndex;\n\tGraphics::Index lightDirection;\n\tGraphics::Index lightColor;\n\tGraphics::Index viewPos;\n\tGraphics::Index ambientStrength;\n\tGraphics::Index ambientOnly;\n\tGraphics::VertexLayout* skullMesh;\n\tGraphics::VertexLayout* planeMesh;\n};\n\nPCMState* gPCMState;\nPCMState* gLitNoPCM;\nPCMState* gLitWithPCM;\n\nGraphics::Texture* gPlaneTextureAlbedo;\nGraphics::Texture* gPlaneTextureNormal;\n\nGraphics::Shader* gHemiShader;\nGraphics::VertexLayout* gHemiSkullMesh;\nGraphics::Texture* gSkullTextureAlbedo;\nGraphics::Texture* gSkullTextureNormal;\nGraphics::Index gAlbedoIndex;\nGraphics::Index gNormalIndex;\nGraphics::Index gModelIndex;\nGraphics::Index gViewIndex;\nGraphics::Index gHemiTop;\nGraphics::Index gHemiBottom;\nGraphics::Index gProjectionIndex;\nGraphics::Index gLightDirection;\nGraphics::Index gLightColor;\nGraphics::Index gLightAmbientOnly;\nGraphics::Index gViewPos;\n\n#define NUM_BUFFERS 10\nGraphics::Buffer* gBuffers[NUM_BUFFERS];\n\nbool ShowDepth = true;\nbool IsRunning = true;\nfloat cameraRadius;\nfloat cameraHeight;\nvec3 cameraTarget;\nfloat camTime;\nfloat lightTime;\nfloat lightDir;\nbool enablePCM;\nbool lastPCM;\nfloat ambientOnly;\n\nTextFile* blit_depth_vShader;\nTextFile* blit_depth_fShader;\nTextFile* lightmap_vShader;\nTextFile* lightmap_fShader;\nTextFile* lit_vShader;\nTextFile* lit_fShader;\nTextFile* lit_pcm_fShader;\nTextFile* hemi_vShader;\nTextFile* hemi_fShader;\nMeshFile* skullMesh;\nMeshFile* planeMesh;\nTextureFile* skullNormal;\nTextureFile* planeAlbedo;\nTextureFile* planeNormal;\nTextureFile* skullAlbedo;\nu32 numFilesToLoad;\nbool isFinishedInitializing;\n\nGraphics::Device* globalDevice;\n\n#ifndef GraphicsAssert\nvoid Win32Assert(bool cond, const char* msg) {\n\tif (!cond) {\n\t\tchar* devnull = (char*)0;\n\t\t*devnull = 'a';\n\t}\n}\n#define GraphicsAssert(x, y) Win32Assert(x, y);\n#endif\n\nvoid Initialize(Graphics::Dependencies* platform, Graphics::Device* gfx) {\n\tIsRunning = true;\n\tisFinishedInitializing = false;\n\tambientOnly = 0.0f;\n\n\tcameraRadius = 7.0f;\n\tcameraHeight = 3.0f;\n\tcamTime = lightTime = 0.0f;\n\tlightDir = 1.0f;\n\tcameraTarget.y = 0.0f;\n\n\tglobalDevice = gfx;\n\tgLitNoPCM = (PCMState*)gfx->Allocate(sizeof(PCMState));\n\tgLitWithPCM = (PCMState*)gfx->Allocate(sizeof(PCMState));\n\n\tgLightmapFBO = gfx->CreateFrameBuffer();\n\tgLightmapColor = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, SHADOWMAP_RES, SHADOWMAP_RES);\n\tgLightmapDepth = gfx->CreateTexture(Graphics::TextureFormat::Depth, SHADOWMAP_RES, SHADOWMAP_RES, 0, Graphics::TextureFormat::Depth, false);\n\t\n\tenablePCM = true;\n\tlastPCM   = enablePCM;\n\tif (enablePCM) {\n\t\tgPCMState = gLitWithPCM;\n\t}\n\telse {\n\t\tgPCMState = gLitNoPCM;\n\t}\n\tgLightmapFBO->AttachDepth(*gLightmapDepth, enablePCM);\n\t//gLightmapFBO->AttachColor(*gLightmapColor);\n\n\t//gLightmapFBO->AttachColor(*gLightmapColor);\n\tGraphicsAssert(gLightmapFBO->IsValid(), \"Invalid fbo\");\n\n\tnumFilesToLoad = 15;\n\tLoadText(\"assets/blit-depth.vert\", [](const char* path, TextFile* file) {\n\t\tblit_depth_vShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/blit-depth.frag\", [](const char* path, TextFile* file) {\n\t\tblit_depth_fShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/lightmap.vert\", [](const char* path, TextFile* file) {\n\t\tlightmap_vShader = file;\n\t\tGraphicsAssert(lightmap_vShader->length != 0, \"Empty lightmap.vert\");\n\t\tGraphicsAssert(lightmap_vShader->text != 0, \"No text pointer in lightmap.vert\");\n\t\tGraphicsAssert(*lightmap_vShader->text != 0, \"Empty string in lightmap.vert\");\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/lightmap.frag\", [](const char* path, TextFile* file) {\n\t\tlightmap_fShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/lit.vert\", [](const char* path, TextFile* file) {\n\t\tlit_vShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/lit.frag\", [](const char* path, TextFile* file) {\n\t\tlit_fShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/lit-pcm.frag\", [](const char* path, TextFile* file) {\n\t\tlit_pcm_fShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/hemi.vert\", [](const char* path, TextFile* file) {\n\t\themi_vShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadText(\"assets/hemi.frag\", [](const char* path, TextFile* file) {\n\t\themi_fShader = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadMesh(\"assets/skull.mesh\", [](const char* path, MeshFile* file) {\n\t\tskullMesh = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadMesh(\"assets/plane.mesh\", [](const char* path, MeshFile* file) {\n\t\tplaneMesh = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadTexture(\"assets/Skull_AlbedoSpec.texture\", [](const char* path, TextureFile* file) {\n\t\tskullAlbedo = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadTexture(\"assets/Plane_AlbedoSpec.texture\", [](const char* path, TextureFile* file) {\n\t\tplaneAlbedo = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadTexture(\"assets/Plane_Normal.texture\", [](const char* path, TextureFile* file) {\n\t\tplaneNormal = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n\tLoadTexture(\"assets/Skull_Normal.texture\", [](const char* path, TextureFile* file) {\n\t\tskullNormal = file;\n\t\tnumFilesToLoad -= 1;\n\t\t});\n}\n\nvoid FinishInitializing(Graphics::Device* gfx) {\n\tGraphicsAssert(lightmap_vShader->length != 0, \"2c Empty lightmap.vert\");\n\tGraphicsAssert(lightmap_vShader->text != 0, \"2 No text pointer in lightmap.vert\");\n\tGraphicsAssert(*lightmap_vShader->text != 0, \"2 Empty string in lightmap.vert\");\n\tgLightmapDrawShader = gfx->CreateShader(lightmap_vShader->text, lightmap_fShader->text);\n\tReleaseText(lightmap_vShader);\n\tReleaseText(lightmap_fShader);\n\t\n\tgLightmapBlitShader = gfx->CreateShader(blit_depth_vShader->text, blit_depth_fShader->text);\n\tReleaseText(blit_depth_vShader);\n\tReleaseText(blit_depth_fShader);\n\tgLightmapFboAttachment = gLightmapBlitShader->GetUniform(\"fboAttachment\");\n\n\tgLightmapSkullLayout = gfx->CreateVertexLayout();\n\tGraphics::Index lightmapPositionAttrib = gLightmapDrawShader->GetAttribute(\"position\");\n\t\n\n\tgLightmapPlaneLayout = gfx->CreateVertexLayout();\n\n\tfloat quadVertices[] = {\n\t\t// positions        // texture Coords\n\t\t-1.0f,  1.0f, 0.0f, 0.0f, 1.0f,\n\t\t-1.0f, -1.0f, 0.0f, 0.0f, 0.0f,\n\t\t 1.0f,  1.0f, 0.0f, 1.0f, 1.0f,\n\t\t 1.0f, -1.0f, 0.0f, 1.0f, 0.0f,\n\t};\n\tGraphics::Buffer* lightmapMesh = gfx->CreateBuffer(quadVertices, sizeof(float) * 20);\n\tGraphics::BufferView lightmapMeshPos(3, sizeof(float) * 5, Graphics::BufferType::Float32, 0);\n\tGraphics::BufferView lightmapMeshTex(2, sizeof(float) * 5, Graphics::BufferType::Float32, sizeof(float) * 3);\n\tGraphics::Index lightmapPosIndex = gLightmapBlitShader->GetAttribute(\"position\");\n\tGraphics::Index lightmapTexIndex = gLightmapBlitShader->GetAttribute(\"texCoords\");\n\tgLightmapMesh = gfx->CreateVertexLayout();\n\tgLightmapMesh->Set(lightmapPosIndex, *lightmapMesh, lightmapMeshPos);\n\tgLightmapMesh->Set(lightmapTexIndex, *lightmapMesh, lightmapMeshTex);\n\tgLightmapMesh->SetUserData(4);\n\tgBuffers[9] = lightmapMesh;\n\n\t/// Lit shader\n\n\t//PCMState* gPCMState;\n\t//PCMState* gLitNoPCM;\n\t//PCMState* gLitWithPCM;\n\n\tgLitNoPCM->shader = gfx->CreateShader(lit_vShader->text, lit_fShader->text);\n\tReleaseText(lit_fShader);\n\n\tgLitWithPCM->shader = gfx->CreateShader(lit_vShader->text, lit_pcm_fShader->text);\n\tReleaseText(lit_vShader);\n\tReleaseText(lit_pcm_fShader);\n\n\tgLitNoPCM->modelIndex = gLitNoPCM->shader->GetUniform(\"model\");\n\tgLitWithPCM->modelIndex = gLitWithPCM->shader->GetUniform(\"model\");\n\n\tgLitNoPCM->shadowIndex = gLitNoPCM->shader->GetUniform(\"shadow\");\n\tgLitWithPCM->shadowIndex = gLitWithPCM->shader->GetUniform(\"shadow\");\n\n\tgLitNoPCM->viewIndex = gLitNoPCM->shader->GetUniform(\"view\");\n\tgLitWithPCM->viewIndex = gLitWithPCM->shader->GetUniform(\"view\");\n\n\tgLitNoPCM->projectionIndex = gLitNoPCM->shader->GetUniform(\"projection\");\n\tgLitWithPCM->projectionIndex = gLitWithPCM->shader->GetUniform(\"projection\");\n\n\tgLitNoPCM->albedoIndex = gLitNoPCM->shader->GetUniform(\"uColorSpec\");\n\tgLitWithPCM->albedoIndex = gLitWithPCM->shader->GetUniform(\"uColorSpec\");\n\n\tgLitNoPCM->lightmapIndex = gLitNoPCM->shader->GetUniform(\"uShadowMap\");\n\tgLitWithPCM->lightmapIndex = gLitWithPCM->shader->GetUniform(\"uShadowMap\");\n\t\n\tgLitNoPCM->normalIndex = gLitNoPCM->shader->GetUniform(\"uNormal\");\n\tgLitWithPCM->normalIndex = gLitWithPCM->shader->GetUniform(\"uNormal\");\n\n\tgLitNoPCM->lightDirection = gLitNoPCM->shader->GetUniform(\"LightDirection\");\n\tgLitWithPCM->lightDirection = gLitWithPCM->shader->GetUniform(\"LightDirection\");\n\n\tgLitNoPCM->lightColor = gLitNoPCM->shader->GetUniform(\"LightColor\");\n\tgLitWithPCM->lightColor = gLitWithPCM->shader->GetUniform(\"LightColor\");\n\n\tgLitNoPCM->viewPos = gLitNoPCM->shader->GetUniform(\"ViewPos\");\n\tgLitWithPCM->viewPos = gLitWithPCM->shader->GetUniform(\"ViewPos\");\n\n\tgLitNoPCM->ambientStrength = gLitNoPCM->shader->GetUniform(\"AmbientStrength\");\n\tgLitWithPCM->ambientStrength = gLitWithPCM->shader->GetUniform(\"AmbientStrength\");\n\n\tgLitNoPCM->ambientOnly = gLitNoPCM->shader->GetUniform(\"AmbientOnly\");\n\tgLitWithPCM->ambientOnly = gLitWithPCM->shader->GetUniform(\"AmbientOnly\");\n\n\t/// Initialize skull\n\n\tgHemiShader = gfx->CreateShader(hemi_vShader->text, hemi_fShader->text);\n\tReleaseText(hemi_vShader);\n\tReleaseText(hemi_fShader);\n\t\n\tGraphics::Buffer* positions = gfx->CreateBuffer(skullMesh->pos, sizeof(float) * 3 * skullMesh->numPos);\n\tGraphics::Buffer* texCoords = gfx->CreateBuffer(skullMesh->tex, sizeof(float) * 2 * skullMesh->numTex);\n\tGraphics::Buffer* normals = gfx->CreateBuffer(skullMesh->nrm, sizeof(float) * 3 * skullMesh->numNrm);\n\tGraphics::Buffer* tangents = gfx->CreateBuffer(skullMesh->tan, sizeof(float) * 3 * skullMesh->numTan);\n\tgBuffers[0] = positions;\n\tgBuffers[1] = texCoords;\n\tgBuffers[2] = normals;\n\tgBuffers[3] = tangents;\n\n\tGraphics::Index attribPos = gHemiShader->GetAttribute(\"aPos\");\n\tGraphics::Index attribUv = gHemiShader->GetAttribute(\"aTexCoord\");\n\tGraphics::Index attribNorm = gHemiShader->GetAttribute(\"aNorm\");\n\tGraphics::Index attribTan = gHemiShader->GetAttribute(\"aTan\");\n\n\tGraphics::BufferView posView(3, 0, Graphics::BufferType::Float32, 0);\n\tGraphics::BufferView normView(3, 0, Graphics::BufferType::Float32, 0);\n\tGraphics::BufferView tanView(3, 0, Graphics::BufferType::Float32, 0);\n\tGraphics::BufferView texView(2, 0, Graphics::BufferType::Float32, 0);\n\n\tgHemiSkullMesh = gfx->CreateVertexLayout();\n\tgHemiSkullMesh->Set(attribPos, *positions, posView);\n\tgHemiSkullMesh->Set(attribNorm, *normals, normView);\n\tgHemiSkullMesh->Set(attribTan, *tangents, tanView);\n\tgHemiSkullMesh->Set(attribUv, *texCoords, texView);\n\tgHemiSkullMesh->SetUserData(skullMesh->numPos);\n\n\tgLightmapSkullLayout->Set(lightmapPositionAttrib, *positions, posView);\n\tgLightmapSkullLayout->SetUserData(skullMesh->numPos);\n\n\tpositions = gfx->CreateBuffer(planeMesh->pos, sizeof(float) * 3 * planeMesh->numPos);\n\ttexCoords = gfx->CreateBuffer(planeMesh->tex, sizeof(float) * 2 * planeMesh->numTex);\n\tnormals = gfx->CreateBuffer(planeMesh->nrm, sizeof(float) * 3 * planeMesh->numNrm);\n\ttangents = gfx->CreateBuffer(planeMesh->tan, sizeof(float) * 3 * planeMesh->numTan);\n\n\tgBuffers[4] = positions;\n\tgBuffers[5] = texCoords;\n\tgBuffers[6] = normals;\n\tgBuffers[7] = tangents;\n\n\tgLitNoPCM->planeMesh = gfx->CreateVertexLayout();\n\tattribPos = gLitNoPCM->shader->GetAttribute(\"aPos\");\n\tattribUv = gLitNoPCM->shader->GetAttribute(\"aTexCoord\");\n\tattribNorm = gLitNoPCM->shader->GetAttribute(\"aNorm\");\n\tattribTan = gLitNoPCM->shader->GetAttribute(\"aTan\");\n\tgLitNoPCM->planeMesh->Set(attribPos, *positions, posView);\n\tgLitNoPCM->planeMesh->Set(attribNorm, *normals, normView);\n\tgLitNoPCM->planeMesh->Set(attribTan, *tangents, tanView);\n\tgLitNoPCM->planeMesh->Set(attribUv, *texCoords, texView);\n\tgLitNoPCM->planeMesh->SetUserData(planeMesh->numPos);\n\n\tgLitWithPCM->planeMesh = gfx->CreateVertexLayout();\n\tattribPos = gLitWithPCM->shader->GetAttribute(\"aPos\");\n\tattribUv = gLitWithPCM->shader->GetAttribute(\"aTexCoord\");\n\tattribNorm = gLitWithPCM->shader->GetAttribute(\"aNorm\");\n\tattribTan = gLitWithPCM->shader->GetAttribute(\"aTan\");\n\tgLitWithPCM->planeMesh->Set(attribPos, *positions, posView);\n\tgLitWithPCM->planeMesh->Set(attribNorm, *normals, normView);\n\tgLitWithPCM->planeMesh->Set(attribTan, *tangents, tanView);\n\tgLitWithPCM->planeMesh->Set(attribUv, *texCoords, texView);\n\tgLitWithPCM->planeMesh->SetUserData(planeMesh->numPos);\n\n\tgLightmapPlaneLayout->Set(lightmapPositionAttrib, *positions, posView);\n\tgLightmapPlaneLayout->SetUserData(planeMesh->numPos);\n\n\t{ // Build composite mesh for comparison\n\t\tu32 bytesNeeded = skullMesh->numPos * sizeof(float) * 3 + skullMesh->numNrm * sizeof(float) * 3 + skullMesh->numTex * 2 * sizeof(float) + skullMesh->numTan * 3 * sizeof(float);\n\t\tfloat* float_arr = (float*)gfx->Allocate(bytesNeeded);\n\t\tu32 arr_size = 0;\n\n\t\tfor (u32 i = 0; i < skullMesh->numPos; ++i) {\n\t\t\tfloat_arr[arr_size++] = skullMesh->pos[i * 3 + 0];\n\t\t\tfloat_arr[arr_size++] = skullMesh->pos[i * 3 + 1];\n\t\t\tfloat_arr[arr_size++] = skullMesh->pos[i * 3 + 2];\n\n\t\t\tfloat_arr[arr_size++] = skullMesh->nrm[i * 3 + 0];\n\t\t\tfloat_arr[arr_size++] = skullMesh->nrm[i * 3 + 1];\n\t\t\tfloat_arr[arr_size++] = skullMesh->nrm[i * 3 + 2];\n\n\t\t\tfloat_arr[arr_size++] = skullMesh->tan[i * 3 + 0];\n\t\t\tfloat_arr[arr_size++] = skullMesh->tan[i * 3 + 1];\n\t\t\tfloat_arr[arr_size++] = skullMesh->tan[i * 3 + 2];\n\n\t\t\tfloat_arr[arr_size++] = skullMesh->tex[i * 2 + 0];\n\t\t\tfloat_arr[arr_size++] = skullMesh->tex[i * 2 + 1];\n\t\t}\n\n\t\tposView = Graphics::BufferView(3, sizeof(float) * 11, Graphics::BufferType::Float32, 0);\n\t\tnormView = Graphics::BufferView(3, sizeof(float) * 11, Graphics::BufferType::Float32, sizeof(float) * 3);\n\t\ttanView = Graphics::BufferView(3, sizeof(float) * 11, Graphics::BufferType::Float32, sizeof(float) * 6);\n\t\ttexView = Graphics::BufferView(2, sizeof(float) * 11, Graphics::BufferType::Float32, sizeof(float) * 9);\n\n\t\tgLitNoPCM->skullMesh = gfx->CreateVertexLayout();\n\t\tattribPos = gLitNoPCM->shader->GetAttribute(\"aPos\");\n\t\tattribUv = gLitNoPCM->shader->GetAttribute(\"aTexCoord\");\n\t\tattribNorm = gLitNoPCM->shader->GetAttribute(\"aNorm\");\n\t\tattribTan = gLitNoPCM->shader->GetAttribute(\"aTan\");\n\t\tGraphics::Buffer* compositeBuff = gfx->CreateBuffer(float_arr, arr_size * sizeof(float));\n\t\tgLitNoPCM->skullMesh->Set(attribPos, *compositeBuff, posView);\n\t\tgLitNoPCM->skullMesh->Set(attribNorm, *compositeBuff, normView);\n\t\tgLitNoPCM->skullMesh->Set(attribTan, *compositeBuff, tanView);\n\t\tgLitNoPCM->skullMesh->Set(attribUv, *compositeBuff, texView);\n\t\tgLitNoPCM->skullMesh->SetUserData(skullMesh->numPos);\n\t\tgBuffers[8] = compositeBuff;\n\n\t\tgLitWithPCM->skullMesh = gfx->CreateVertexLayout();\n\t\tattribPos = gLitWithPCM->shader->GetAttribute(\"aPos\");\n\t\tattribUv = gLitWithPCM->shader->GetAttribute(\"aTexCoord\");\n\t\tattribNorm = gLitWithPCM->shader->GetAttribute(\"aNorm\");\n\t\tattribTan = gLitWithPCM->shader->GetAttribute(\"aTan\");\n\t\tgLitWithPCM->skullMesh->Set(attribPos, *compositeBuff, posView);\n\t\tgLitWithPCM->skullMesh->Set(attribNorm, *compositeBuff, normView);\n\t\tgLitWithPCM->skullMesh->Set(attribTan, *compositeBuff, tanView);\n\t\tgLitWithPCM->skullMesh->Set(attribUv, *compositeBuff, texView);\n\t\tgLitWithPCM->skullMesh->SetUserData(skullMesh->numPos);\n\t\tgBuffers[8] = compositeBuff;\n\n\t\tgfx->Release(float_arr);\n\t}\n\tReleaseMesh(skullMesh);\n\tReleaseMesh(planeMesh);\n\n\tgAlbedoIndex = gHemiShader->GetUniform(\"uColorSpec\");\n\tgNormalIndex = gHemiShader->GetUniform(\"uNormal\");\n\tgModelIndex = gHemiShader->GetUniform(\"model\");\n\tgViewIndex = gHemiShader->GetUniform(\"view\");\n\tgHemiTop = gHemiShader->GetUniform(\"HemiTop\");\n\tgHemiBottom = gHemiShader->GetUniform(\"HemiBottom\");\n\tgProjectionIndex = gHemiShader->GetUniform(\"projection\");\n\n\tgLightDirection = gHemiShader->GetUniform(\"LightDirection\");\n\tgLightColor = gHemiShader->GetUniform(\"LightColor\");\n\tgLightAmbientOnly = gHemiShader->GetUniform(\"AmbientOnly\");\n\tgViewPos = gHemiShader->GetUniform(\"ViewPos\");\n\n\tGraphics::TextureFormat format = Graphics::TextureFormat::RGBA8;\n\tif (skullAlbedo->channels == 3) {\n\t\tformat = Graphics::TextureFormat::RGB8;\n\t}\n\tgSkullTextureAlbedo = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, skullAlbedo->width, skullAlbedo->height, skullAlbedo->data, format,true);\n\tReleaseTexture(skullAlbedo);\n\n\tformat = Graphics::TextureFormat::RGBA8;\n\tif (skullNormal->channels == 3) {\n\t\tformat = Graphics::TextureFormat::RGB8;\n\t}\n\tgSkullTextureNormal = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, skullNormal->width, skullNormal->height, skullNormal->data, format, true);\n\tReleaseTexture(skullNormal);\n\t\n\tformat = Graphics::TextureFormat::RGBA8;\n\tif (planeAlbedo->channels == 3) {\n\t\tformat = Graphics::TextureFormat::RGB8;\n\t}\n\tgPlaneTextureAlbedo = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, planeAlbedo->width, planeAlbedo->height, planeAlbedo->data, format, true);\n\tReleaseTexture(planeAlbedo);\n\t\n\t\n\tformat = Graphics::TextureFormat::RGBA8;\n\tif (planeNormal->channels == 3) {\n\t\tformat = Graphics::TextureFormat::RGB8;\n\t}\n\tgPlaneTextureNormal = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, planeNormal->width, planeNormal->height, planeNormal->data, format, true);\n\tReleaseTexture(planeNormal);\n\n\tgfx->SetDepthState(true);\n\n\tgLightmapMVP = gLightmapDrawShader->GetUniform(\"mvp\");\n\tGraphicsAssert(gLightmapMVP.valid, \"INvalid lightmap mvp?\");\n\n\tisFinishedInitializing = true;\n}\n\nvoid Update(Graphics::Device* g, float deltaTime) {\n\tif (!IsRunning) {\n\t\treturn;\n\t}\n\n\tif (numFilesToLoad != 0) {\n\t\treturn;\n\t}\n\n\tif (!isFinishedInitializing) {\n\t\tFinishInitializing(g);\n\t\tisFinishedInitializing = true;\n\t\tGraphicsAssert(gLightmapMVP.valid, \"(3) INvalid lightmap mvp?\");\n\t\treturn;\n\t}\n\tGraphicsAssert(gLightmapMVP.valid, \"(4) INvalid lightmap mvp?\");\n\n#if 1\n\tcamTime += deltaTime * 0.25f;\n\twhile (camTime >= 360.0f) {\n\t\tcamTime -= 360.0f;\n\t}\n\n\tlightTime += deltaTime * lightDir;\n\tif (lightTime > 5.0f) {\n\t\tlightDir *= -1.0f;\n\t\tlightTime = 5.0f;\n\t}\n\telse if (lightTime < 0.0f) {\n\t\tlightDir *= -1.0f;\n\t\tlightTime = 0.0f;\n\t}\n#else\n\tcamTime = 25;\n#endif\n}\n\nvoid Render(Graphics::Device * gfx, int x, int y, int w, int h) {\n\tif (!IsRunning) {\n\t\treturn;\n\t}\n\tif (!isFinishedInitializing) {\n\t\treturn;\n\t}\n\n\tif (lastPCM != enablePCM) {\n\t\tgLightmapFBO->AttachDepth(*gLightmapDepth, enablePCM);\n\t\tif (enablePCM) {\n\t\t\tgPCMState = gLitWithPCM;\n\t\t}\n\t\telse {\n\t\t\tgPCMState = gLitNoPCM;\n\t\t}\n\t\tlastPCM = enablePCM;\n\t}\n\n\tGraphicsAssert(gLightmapMVP.valid, \"(5) INvalid lightmap mvp?\");\n\n\tfloat camX = FastSin(camTime) * cameraRadius;\n\tfloat camZ = FastCos(camTime) * cameraRadius;\n\tvec3 cameraPos = vec3(camX, cameraHeight, camZ);\n\tmat4 view = lookAt(cameraPos, cameraTarget, vec3(0, 1, 0));\n\tmat4 projection = perspective(45.0f, 800.0f / 600.0f, 0.1f, 1000.0f);\n\tmat4 model1 = mat4(0.1f, 0.0, 0.0, 0.0,\n\t\t0.0, 0.1f, 0.0, 0.0,\n\t\t0.0, 0.0, 0.1f, 0.0,\n\t\t1.5f, 0.0f, -0.5, 1.0f);\n\tmat4 model2 = mat4(0.1f, 0.0, 0.0, 0.0,\n\t\t0.0, 0.1f, 0.0, 0.0,\n\t\t0.0, 0.0, 0.1f, 0.0,\n\t\t-0.5f, -1.0f, 1.5, 1.0f);\n\tmat4 model3 = mat4(2.0f, 0.0, 0.0, 0.0,\n\t\t0.0, 2.0f, 0.0, 0.0,\n\t\t0.0, 0.0, 2.0f, 0.0,\n\t\t0.0f, -1.5, 0.0, 1.0f);\n\tvec3 lightDir = vec3(0.2, -1.0, -1);\n\tvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\tfloat ambient = 0.2f;\n\tvec3 HemiTop = vec3(0.3f, 0.3f, 0.3f);\n\tvec3 HemiBottom = vec3(ambient, ambient, ambient);\n\tGraphics::Sampler sampler;\n\n\tGraphics::Sampler depthSampler(Graphics::WrapMode::Clamp, Graphics::WrapMode::Clamp, Graphics::Filter::Nearest, Graphics::Filter::Nearest, Graphics::Filter::Nearest);\n\tif (gPCMState == gLitWithPCM) {\n\t\tdepthSampler = Graphics::Sampler(Graphics::WrapMode::Clamp, Graphics::WrapMode::Clamp, Graphics::Filter::Linear, Graphics::Filter::Linear, Graphics::Filter::Linear);\n\t}\n\n\tvec3 lightCameraPosition = cameraTarget - normalized(lightDir) * 10.0f;\n\tmat4 ShadowView = lookAt(lightCameraPosition, cameraTarget, vec3(0, 1, 0));\n\tmat4 ShadowProjection = ortho(-7.5, 7.5, -7.5, 7.5, 0.01, 20.0);\n\n\tmat4 shadowMapAdjustment(\n\t0.5f, 0.0f, 0.0f, 0.0f,\n\t0.0f, 0.5f, 0.0f, 0.0f,\n\t0.0f, 0.0f, 0.5f, 0.0f,\n\t0.5f, 0.5f, 0.5f - 0.01f, 1.0f);\n\n\t{ // Draw lightmap\n\t\tgfx->SetRenderTarget(gLightmapFBO);\n\t\tgfx->SetViewport(0, 0, SHADOWMAP_RES, SHADOWMAP_RES);\n\t\tgfx->Clear(1.0f);\n\n\t\tgfx->SetFaceCulling(Graphics::CullFace::Front);\n#if 1\n\t\tgfx->Bind(gLightmapDrawShader);\n\t\tmat4 mvp = ShadowProjection * ShadowView * model1;\n\t\tGraphicsAssert(gLightmapMVP.valid, \"(2) INvalid lightmap mvp?\");\n\t\tgfx->Bind(gLightmapMVP, Graphics::UniformType::Float16, mvp.v);\n\t\tGraphicsAssert(gLightmapMVP.valid, \"(a) INvalid lightmap mvp?\");\n\t\tgfx->Draw(*gLightmapSkullLayout, Graphics::DrawMode::Triangles, 0, gLightmapSkullLayout->GetUserData());\n\n\t\tmvp = ShadowProjection* ShadowView* model2;\n\t\tGraphicsAssert(gLightmapMVP.valid, \"(b) INvalid lightmap mvp?\");\n\t\tgfx->Bind(gLightmapMVP, Graphics::UniformType::Float16, mvp.v);\n\t\tGraphicsAssert(gLightmapMVP.valid, \"(c) INvalid lightmap mvp?\");\n\t\tgfx->Draw(*gLightmapSkullLayout, Graphics::DrawMode::Triangles, 0, gLightmapSkullLayout->GetUserData());\n\n\t\tmvp = ShadowProjection * ShadowView * model3;\n\t\tGraphicsAssert(gLightmapMVP.valid, \"(d) INvalid lightmap mvp?\");\n\t\tgfx->Bind(gLightmapMVP, Graphics::UniformType::Float16, mvp.v);\n\t\tGraphicsAssert(gLightmapMVP.valid, \"(e INvalid lightmap mvp?\");\n\t\t//gfx->Draw(*gLightmapPlaneLayout, Graphics::DrawMode::Triangles, 0, gLightmapPlaneLayout->GetUserData());\n#endif\n\t\tgfx->SetFaceCulling(Graphics::CullFace::Back);\n\t}\n\n\tmat4 shadowMatrix1 = shadowMapAdjustment * ShadowProjection * ShadowView * model1;\n\tmat4 shadowMatrix2 = shadowMapAdjustment * ShadowProjection * ShadowView * model2;\n\tmat4 shadowMatrix3 = shadowMapAdjustment * ShadowProjection * ShadowView * model3;\n\n\n\t{ // Draw scene\n\t\tgfx->SetRenderTarget(0);\n\t\tgfx->SetViewport(0, 0, 800, 600);\n\t\tgfx->Clear(0.4, 0.5, 0.6, 1.0);\n\t\tgfx->Bind(gHemiShader);\n\n\t\tgfx->Bind(gLightDirection, Graphics::UniformType::Float3, lightDir.v);\n\t\tgfx->Bind(gLightColor, Graphics::UniformType::Float3, lightColor.v);\n\t\tgfx->Bind(gLightAmbientOnly, Graphics::UniformType::Float1, &ambientOnly);\n\t\tgfx->Bind(gViewPos, Graphics::UniformType::Float3, cameraPos.v);\n\n\t\tgfx->Bind(gAlbedoIndex, *gSkullTextureAlbedo, sampler);\n\t\tgfx->Bind(gNormalIndex, *gSkullTextureNormal, sampler);\n\t\tgfx->Bind(gModelIndex, Graphics::UniformType::Float16, model1.v);\n\t\tgfx->Bind(gViewIndex, Graphics::UniformType::Float16, view.v);\n\t\tgfx->Bind(gHemiTop, Graphics::UniformType::Float3, HemiTop.v);\n\t\tgfx->Bind(gHemiBottom, Graphics::UniformType::Float3, HemiBottom.v);\n\t\tgfx->Bind(gProjectionIndex, Graphics::UniformType::Float16, projection.v);\n\t\tgfx->Draw(*gHemiSkullMesh, Graphics::DrawMode::Triangles, 0, gHemiSkullMesh->GetUserData());\n\n\t\tgfx->Bind(gPCMState->shader);\n\n\t\tgfx->Bind(gPCMState->modelIndex, Graphics::UniformType::Float16, model2.v);\n\t\tgfx->Bind(gPCMState->shadowIndex, Graphics::UniformType::Float16, shadowMatrix2.v);\n\t\tgfx->Bind(gPCMState->viewIndex, Graphics::UniformType::Float16, view.v);\n\t\tgfx->Bind(gPCMState->projectionIndex, Graphics::UniformType::Float16, projection.v);\n\n\t\tgfx->Bind(gPCMState->normalIndex, *gSkullTextureNormal, sampler);\n\t\tgfx->Bind(gPCMState->albedoIndex, *gSkullTextureAlbedo, sampler);\n\t\tGraphicsAssert(gPCMState->normalIndex.id != gPCMState->albedoIndex.id, \"Bad ID's\");\n\t\tgfx->Bind(gPCMState->lightmapIndex, *gLightmapDepth, depthSampler);\n\t\tgfx->Bind(gPCMState->lightDirection, Graphics::UniformType::Float3, lightDir.v);\n\t\tgfx->Bind(gPCMState->lightColor, Graphics::UniformType::Float3, lightColor.v);\n\t\tgfx->Bind(gPCMState->viewPos, Graphics::UniformType::Float3, cameraPos.v);\n\t\tgfx->Bind(gPCMState->ambientStrength, Graphics::UniformType::Float1, &ambient);\n\t\tgfx->Bind(gPCMState->ambientOnly, Graphics::UniformType::Float1, &ambientOnly);\n\t\t\n\t\tgfx->Draw(*gPCMState->skullMesh, Graphics::DrawMode::Triangles, 0, gPCMState->skullMesh->GetUserData());\n\n\t\tambient = 0.0f;\n\t\tgfx->Bind(gPCMState->modelIndex, Graphics::UniformType::Float16, model3.v);\n\t\tgfx->Bind(gPCMState->shadowIndex, Graphics::UniformType::Float16, shadowMatrix3.v);\n\t\tgfx->Bind(gPCMState->albedoIndex, *gPlaneTextureAlbedo, sampler);\n\t\tgfx->Bind(gPCMState->lightmapIndex, *gLightmapDepth, depthSampler);\n\t\tgfx->Bind(gPCMState->normalIndex, *gPlaneTextureNormal, sampler);\n\t\tgfx->Bind(gPCMState->ambientStrength, Graphics::UniformType::Float1, &ambient);\n\t\tgfx->Draw(*gPCMState->planeMesh, Graphics::DrawMode::Triangles, 0, gPCMState->planeMesh->GetUserData());\n\t}\n\n\tif (ShowDepth && !(gPCMState == gLitWithPCM)) { // Draw debug\n\t\tgfx->SetViewport(w - 20 - 256, h - 20 - 256, 266, 266);\n\t\tgfx->SetScissorState(true, w - 20 - 256, h - 20 - 256, 266, 266);\n\t\tgfx->Clear(0, 0, 0, 1);\n\t\tgfx->SetScissorState(false);\n\t\tgfx->SetViewport(w - 10 - 5 - 256, h - 10 - 5 - 256, 256, 256);\n\n\t\tgfx->Bind(gLightmapBlitShader);\n\t\tgfx->Bind(gLightmapFboAttachment, *gLightmapDepth, depthSampler);\n\t\tgfx->Draw(*gLightmapMesh, Graphics::DrawMode::TriangleStrip, 0, gLightmapMesh->GetUserData());\n\t\tgfx->SetViewport(0, 0, 800, 600);\n\t}\n}\n\nvoid Shutdown(Graphics::Device* gfx) {\n\tIsRunning = false;\n\n\tgfx->SetRenderTarget(0);\n\tgfx->Bind(0);\n\n\tfor (u32 i = 0; i < NUM_BUFFERS; ++i) {\n\t\tgfx->Destroy(gBuffers[i]);\n\t}\n\n\tgfx->Destroy(gLightmapPlaneLayout);\n\tgfx->Destroy(gLightmapSkullLayout);\n\tgfx->Destroy(gLightmapMesh);\n\tgfx->Destroy(gLightmapFBO);\n\tgfx->Destroy(gLightmapColor);\n\tgfx->Destroy(gLightmapDepth);\n\tgfx->Destroy(gLightmapBlitShader);\n\tgfx->Destroy(gLightmapDrawShader);\n\tgfx->Destroy(gLitNoPCM->shader);\n\tgfx->Destroy(gLitWithPCM->shader);\n\tgfx->Destroy(gLitNoPCM->skullMesh);\n\tgfx->Destroy(gLitWithPCM->skullMesh);\n\tgfx->Destroy(gLitNoPCM->planeMesh);\n\tgfx->Destroy(gLitWithPCM->planeMesh);\n\tgfx->Destroy(gPlaneTextureAlbedo);\n\tgfx->Destroy(gPlaneTextureNormal);\n\tgfx->Destroy(gHemiShader);\n\tgfx->Destroy(gHemiSkullMesh);\n\tgfx->Destroy(gSkullTextureAlbedo);\n\tgfx->Destroy(gSkullTextureNormal);\n\n\tgfx->Release(gLitNoPCM);\n\tgfx->Release(gLitWithPCM);\n\n\tGraphics::Shutdown(*gfx);\n\tgfx = 0;\n}"],"mappings":"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"}