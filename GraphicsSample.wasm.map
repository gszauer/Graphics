{"version":3,"names":[],"sources":["WasmSampleExpanded.cpp"],"sourcesContent":["// https://stackoverflow.com/questions/72568387/why-is-an-objects-constructor-being-called-in-every-exported-wasm-function\nextern \"C\" void __wasm_call_ctors(void);\n__attribute__((export_name(\"_initialize\")))\nextern \"C\" void _initialize(void) {\n    // The linker synthesizes this to call constructors.\n    __wasm_call_ctors();\n}\n\n\n\n\n typedef unsigned int u32;\n static_assert (sizeof(u32) == 4, \"u32 should be defined as a 4 byte type\");\n\n\n\n\n typedef float f32;\n static_assert (sizeof(f32) == 4, \"f32 should be defined as a 4 byte type\");\n\n\nnamespace Graphics {\n // The only external dependancy is memory allocation\n typedef void* (*fpRequest)(u32 bytes);\n typedef void (*fpRelease)(void* mem);\n\n struct Dependencies {\n  fpRequest Request; // malloc\n  fpRelease Release; // free\n\n  inline Dependencies() {\n   Request = 0;\n   Release = 0;\n  }\n };\n\n class Buffer;\n class Shader;\n class Device;\n class Texture;\n class VertexLayout;\n class FrameBuffer;\n\n enum class Filter {\n  Nearest = 0,\n  Linear = 1\n };\n\n enum class WrapMode {\n  Repeat = 0,\n  Clamp = 1\n };\n\n enum class DepthFunc {\n  Always = 1,\n  Never = 2,\n  Less = 3,\n  Equal = 4,\n  LEqual = 5,\n  Greater = 6,\n  GEqual = 7,\n  NotEqual = 8\n };\n\n enum class DrawMode {\n  Points = 0,\n  Lines = 1,\n  LineStrip = 2,\n  Triangles = 3,\n  TriangleStrip = 4,\n  TriangleFan = 5\n };\n\n enum class BufferType {\n  Float32 = 0,\n  Int8 = 1,\n  UInt8 = 2,\n  Int16 = 3,\n  UInt16 = 4,\n  Int32 = 5,\n  UInt32 = 6\n };\n\n enum class UniformType {\n  Int1 = 0,\n  Int2 = 1,\n  Int3 = 2,\n  Int4 = 3,\n  Float1 = 4,\n  Float2 = 5,\n  Float3 = 6,\n  Float4 = 7,\n  Float9 = 8,\n  Float16 = 9\n };\n\n enum class BlendEquation {\n  Add = 0,\n  Subtract = 1,\n  ReverseSubtract = 2,\n  Min = 3,\n  Max = 4\n };\n\n enum class BlendFunction {\n  Zero = 1,\n  One = 2,\n  SrcColor = 3,\n  OneMinusSrcColor = 4,\n  DstColor = 5,\n  OneMinusDstColor = 6,\n  SrcAlpha = 7,\n  OneMinusSrcAlpha = 8,\n  DstAlpha = 9,\n  OneMinusDstAlpha = 10,\n  ConstColor = 11,\n  OneMinusConstColor = 12,\n  ConstAlpha = 13,\n  OneMinusconstAlpha = 14,\n  SrcAlphaSaturate = 15\n };\n\n enum class CullFace {\n  Off = 0,\n  Back = 1, // Default\n  Front = 2,\n  FrontAndBack = 3\n };\n\n enum class FaceWind {\n  CounterClockwise = 0, // Default\n  Clockwise = 1\n };\n\n enum class TextureFormat { // Rename to texture format\n  R8 = 0,\n  RG8 = 1,\n  RGB8 = 2,\n  RGBA8 = 3,\n\n  R32F = 4,\n  RG32F = 5,\n  RGB32F = 6,\n  RGBA32F = 7,\n\n  Depth = 8\n };\n\n struct Index { // Uniform / Attribute Index\n  u32 id;\n  bool valid;\n\n  inline Index(u32 _id = 0, bool _valid = false) {\n   id = _id;\n   valid = _valid;\n  }\n\n  inline Index(const Index& o) {\n   id = o.id;\n   valid = o.valid;\n  }\n\n  inline Index& operator=(const Index& o) {\n   id = o.id;\n   valid = o.valid;\n   return *this;\n  }\n };\n\n struct Sampler {\n  WrapMode wrapS;\n  WrapMode wrapT;\n  WrapMode wrapR; // Only used for cubemaps\n  Filter min; // Downscale\n  Filter mip; // Mipmap transition\n  Filter mag; // Upscale\n\n  inline Sampler(WrapMode _wrapS = WrapMode::Repeat, WrapMode _wrapT = WrapMode::Repeat, WrapMode _wrapR = WrapMode::Repeat, Filter _min = Filter::Linear, Filter _mip = Filter::Linear, Filter _mag = Filter::Linear) {\n   wrapS = _wrapS;\n   wrapT = _wrapT;\n   wrapR = _wrapR;\n   min = _min;\n   mip = _mip;\n   mag = _mag;\n  }\n\n  inline Sampler(Filter _min, Filter _mip = Filter::Linear, Filter _mag = Filter::Linear) {\n   wrapS = WrapMode::Repeat;\n   wrapT = WrapMode::Repeat;\n   wrapR = WrapMode::Repeat;\n   min = _min;\n   mip = _mip;\n   mag = _mag;\n  }\n\n  inline Sampler(WrapMode _wrap) {\n   wrapS = _wrap;\n   wrapT = _wrap;\n   wrapR = _wrap;\n   min = Filter::Linear;\n   mip = Filter::Linear;\n   mag = Filter::Linear;\n  }\n };\n\n struct BufferView {\n  u32 NumberOfComponents; // (1) float, (2) vec2, (3) vec3, (4) vec4\n  u32 StrideInBytes;\n  BufferType Type; // float or int\n  u32 DataOffsetInBytes; // pointer argument to glVertexAttribLPointer\n\n  inline BufferView( u32 _numberOfComponents = 0,\n       u32 _strideInBytes = 0,\n       BufferType _type = BufferType::Float32,\n       u32 _dataOffsetInBytes = 0) {\n   NumberOfComponents = _numberOfComponents;\n   StrideInBytes = _strideInBytes;\n   Type = _type;\n   DataOffsetInBytes = _dataOffsetInBytes;\n  }\n };\n\n // I'm going to keep the concept of a depth texture for now, and check\n // how to use the extension in webgl. If htat doesn't work, then using a\n // renderbuffer when TextureFormat::Depth instead of a texture object\n // but i don't think compatibility is going to be that big of an issue.\n class Texture { // These are texture objects\n  friend class Device;\n  friend class FrameBuffer;\n protected:\n  u32 mId;\n  u32 mWidth;\n  u32 mHeight;\n  u32 mUserData;\n  bool mIsMipMapped;\n  bool mIsCubeMap;\n  TextureFormat mInternalFormat;\n\n  u32 mCachedMin; // Default: GL_NEAREST_MIPMAP_LINEAR\n  u32 mCachedMag; // Default: GL_LINEAR\n  u32 mCachedS; // Default = GL_REPEAT\n  u32 mCachedR; // Default = GL_REPEAT\n  u32 mCachedT; // Default = GL_REPEAT\n\n  Texture* mAllocPrev;\n  Texture* mAllocNext;\n  Device* mOwner;\n private:\n  Texture() = delete;\n  ~Texture() = delete;\n  Texture(const Texture& other) = delete;\n  Texture& operator=(const Texture& other) = delete;\n public:\n  void Set(void* data, TextureFormat dataFormat, u32 width, u32 height, bool genMipMaps);\n  void SetPCM(bool pcm);\n\n  inline void Set(u32 width, u32 height) {\n   TextureFormat dataFormat = TextureFormat::RGBA8;\n   Set(0, mInternalFormat, width, height, false);\n  }\n\n  void SetCubemap(void* rightData, void* leftData, void* topData, void* bottomData, void* backData, void* frontData,\n   u32 width, u32 height, TextureFormat format, bool genMipMaps);\n\n  inline u32 GetWidth() {\n   return mWidth;\n  }\n\n  inline u32 GetHeight() {\n   return mHeight;\n  }\n\n  inline TextureFormat GetFormat() {\n   return mInternalFormat;\n  }\n\n  inline void SetUserData(u32 data) {\n   mUserData = data;\n  }\n\n  inline u32 GetUserData() {\n   return mUserData;\n  }\n };\n\n namespace Internal {\n  struct TextureUnit {\n   Graphics::Index index;\n   Graphics::Texture* texture; // Null or bound texture\n   u32 target; // TEXTURE_2D, TEXTURE_3D, etc...\n  };\n }\n\n class Buffer {\n  friend class Device;\n  friend class VertexLayout;\n protected:\n  u32 mId;\n  bool mIndexBuffer;\n  u32 mUserData;\n\n  Buffer* mAllocPrev;\n  Buffer* mAllocNext;\n  Device* mOwner;\n private:\n  Buffer() = delete;\n  Buffer(const Buffer&) = delete;\n  Buffer& operator=(const Buffer&) = delete;\n  ~Buffer() = delete;\n public:\n  void Set(void* inputArray, u32 arraySizeInBytes, bool _static = true);\n  void Reset();\n\n  inline void SetUserData(u32 data) {\n   mUserData = data;\n  }\n\n  inline u32 GetUserData() {\n   return mUserData;\n  }\n\n  inline bool IsIndexBuffer() {\n   return mIndexBuffer;\n  }\n };\n\n // Note to self in the future:\n // The way this would work is that a MeshRenderer has a list of materials\n // Each material has a shader. For each material, the mesh renderer needs\n // to create a vertex layout. Then, when drawing a MeshRenderer, loop trough\n // all of it's materials. For each material: bind the shader, and the vertex\n // layout. \n // To do things like normal mapping, A mapping from VertexLayout to arbitrary\n // shaders / materials needs to be doable. \n class VertexLayout {\n  friend class Device;\n protected:\n  u32 mId;\n  bool mHasIndexBuffer;\n  u32 mUserData;\n  BufferType mIndexBufferType;\n\n  VertexLayout* mAllocPrev;\n  VertexLayout* mAllocNext;\n  Device* mOwner;\n private:\n  VertexLayout() = delete;\n  VertexLayout(const VertexLayout&) = delete;\n  VertexLayout& operator=(const VertexLayout&) = delete;\n  ~VertexLayout() = delete;\n public:\n  void Set(const Index& index, const Buffer& buffer, const BufferView& view, u32 instanceDivisor = 0);\n  void Set(const Buffer& indexBuffer, const BufferType& indexType);\n  void Reset();\n\n  inline void SetUserData(u32 data) {\n   mUserData = data;\n  }\n\n  inline u32 GetUserData() {\n   return mUserData;\n  }\n };\n\n class Shader {\n  friend class Device;\n protected:\n  u32 mProgram;\n  u32 mUserData;\n  Shader* mAllocPrev;\n  Shader* mAllocNext;\n  Device* mOwner;\n private:\n  Shader() = delete;\n  Shader(const Shader&) = delete;\n  Shader& operator=(const Shader&) = delete;\n  ~Shader() = delete;\n public:\n  Index GetAttribute(const char* name);\n  Index GetUniform(const char* name);\n\n  inline void SetUserData(u32 data) {\n   mUserData = data;\n  }\n\n  inline u32 GetUserData() {\n   return mUserData;\n  }\n\n  /* I added support for the shader knowing it's uniform names here,\n\t\t* with the idea that a MeshRenderer would need to map the shader to\n\t\t* some vertex buffer format. That's not really important tough. If the\n\t\t* standard streams are known  \"ie, position, normal, tangent, etc\"\n\t\t* then i can just get their Index-es and see if the index is valid\n\t\t* if it is, bind it to the fbo, it it isn't, don't. Anyway, i already added\n\t\t* the code to get the info, so i'm going to keep it alive without \n\t\t* exposing it. If it's not needed, i'll emove it from the final version */\n };\n\n class FrameBuffer {\n  friend class Device;\n protected:\n  u32 mId;\n\n  union {\n   struct {\n    Texture* mColor0;\n    Texture* mColor1;\n    Texture* mColor2;\n    Texture* mColor3;\n    Texture* mColor4;\n    Texture* mColor5;\n   };\n   Texture* mColor[6];\n  };\n\n  Texture* mDepth;\n  u32 mReadBufferConfig;\n\n  u32 mUserData;\n\n  FrameBuffer* mAllocPrev;\n  FrameBuffer* mAllocNext;\n  Device* mOwner;\n private:\n  FrameBuffer() = delete;\n  FrameBuffer(const FrameBuffer&) = delete;\n  FrameBuffer& operator=(const FrameBuffer&) = delete;\n  ~FrameBuffer() = delete;\n public:\n  void AttachColor(Texture& color, u32 attachmentIndex = 0);\n  void AttachDepth(Texture& depth, bool pcm = true);\n\n  void Resize(u32 width, u32 height);\n  bool IsValid();\n\n  u32 TargetCount();\n  u32 GetWidth();\n  u32 GetHeight();\n\n  void ResolveTo(FrameBuffer* target, Filter filter, bool color, bool depth, u32 x0, u32 y0, u32 x1, u32 y1, u32 x2, u32 y2, u32 x3, u32 y3);\n  void ResolveTo(FrameBuffer* target, Filter filter = Filter::Nearest, bool color = true, bool depth = true);\n\n  inline void SetUserData(u32 data) {\n   mUserData = data;\n  }\n\n  inline u32 GetUserData() {\n   return mUserData;\n  }\n };\n\n class Device {\n  friend class FrameBuffer;\n  friend Device* Initialize(Device& outDevice, Dependencies& platform);\n  friend void Shutdown(Device& device);\n protected:\n  Dependencies mPlatform;\n  u32 mUserData;\n  u32 mViewportRect[4];\n\n  u32 mBoundProgram;\n  u32 mBoundFrameBuffer;\n\n  // Texture state\n  Internal::TextureUnit mBoundTextures[32];\n\n  // Cull state\n  CullFace mFaceCulling; // Default back\n  FaceWind mWindingOrder; // Default CCW\n\n  // Blend State\n  bool mBlend; // Default: false\n  f32 mBlendColor[4]; // Default: 0, 0, 0, 0\n  BlendFunction mBlendDstAlpha; // Default BlendFunction::Zero\n  BlendFunction mBlendDstRGB; // Default BlendFunction::Zero\n  BlendEquation mBlendEquationAlpha; // Default: BlendEquation::Add\n  BlendEquation mBlendEquationRGB; // Default: BlendEquation::Add\n  BlendFunction mBlendSrcAlpba; // Default BlendFunction::One\n  BlendFunction mBlendSrcRGB; // Default BlendFunction::One\n\n  // Depth state\n  bool mDepth; // true\n  DepthFunc mDepthFunc; // less\n  f32 mDepthRange[2]; // 0, 1\n\n  // Scissor state\n  bool mScissor;\n  u32 mScissorRect[4];\n\n  // Memory tracking\n  Texture* mAllocatedTextures;\n  Buffer* mAllocatedBuffers;\n  VertexLayout* mAllocatedStates;\n  Shader* mAllocatedShaders;\n  FrameBuffer* mAllocatedFrameBuffers;\n private:\n  Device() = delete;\n  Device(const Device&) = delete;\n  Device& operator=(const Device&) = delete;\n  ~Device() = delete;\n public:\n  inline void* Allocate(u32 bytes) {\n   if (mPlatform.Request != 0) {\n    return mPlatform.Request(bytes);\n   }\n   return 0;\n  }\n  inline void Release(void* mem) {\n   if (mPlatform.Release != 0) {\n    mPlatform.Release(mem);\n   }\n  }\n public:\n  Shader* CreateShader(const char* vertex, const char* fragment);\n  void Destroy(Shader* shader);\n\n  Buffer* CreateBuffer();\n  Buffer* CreateIndexBuffer();\n  inline Buffer* CreateBuffer(void* array, u32 sizeInBytes, bool _static = true) {\n   Buffer* result = CreateBuffer();\n   result->Set(array, sizeInBytes, _static);\n   return result;\n  }\n  inline Buffer* CreateIndexBuffer(void* array, u32 sizeInBytes, bool _static = true) {\n   Buffer* result = CreateIndexBuffer();\n   result->Set(array, sizeInBytes, _static);\n   return result;\n  }\n  void Destroy(Buffer* buff);\n\n  VertexLayout* CreateVertexLayout();\n  void Destroy(VertexLayout* map);\n\n  FrameBuffer* CreateFrameBuffer();\n  void Destroy(FrameBuffer* buffer);\n\n  Texture* CreateTexture(TextureFormat format);\n\n  inline Texture* CreateTexture(TextureFormat format, u32 width, u32 height, void* data, TextureFormat dataFormat, bool genMipMaps) {\n   Texture* result = CreateTexture(format);\n   result->Set(data, dataFormat, width, height, genMipMaps);\n   return result;\n  }\n  inline Texture* CreateTexture(TextureFormat format, u32 width, u32 height) {\n   Texture* result = CreateTexture(format);\n   result->Set(width, height);\n   return result;\n  }\n  void Destroy(Texture* buff);\n\n  void Bind(Shader* shader); // Binds shader & allows for Bind(0)\n  inline void Bind(Shader& shader) {\n   Bind(&shader);\n  }\n\n  // Frame buffers should persist between Bind calls, even if null is bound\n  void SetRenderTarget(FrameBuffer* frameBuffer);\n  inline void SetRenderTarget(FrameBuffer& frameBuffer) {\n   SetRenderTarget(&frameBuffer);\n  }\n\n  void Bind(Index& slot, UniformType type, void* data, u32 count = 1); // Binds uniform\n  void Bind(Index& uniformSlot, Texture& texture, Sampler& sampler); // Binds texture (uniform still)\n\n  void Draw(const VertexLayout& attributes, DrawMode drawMode, u32 startIndex, u32 indexCount, u32 instanceCount = 1);\n public: // State management\n  // Blend state\n  void SetBlendState(bool blend, f32* optBlendColor,\n   BlendFunction blendDstRgb, BlendFunction blendDstAlpha,\n   BlendEquation blendEquationRgb, BlendEquation blendEquationAlpha,\n   BlendFunction blendSrcRgb, BlendFunction blendSrcAlpha);\n\n  inline void SetBlendState(f32* color, BlendFunction blendDst, BlendEquation blendEq, BlendFunction blendSrc) {\n   SetBlendState(true, color, blendDst, blendDst, blendEq, blendEq, blendSrc, blendSrc);\n  }\n  inline void SetBlendState(BlendFunction dst, BlendEquation eq, BlendFunction src) {\n   SetBlendState(true, 0, dst, dst, eq, eq, src, src);\n  }\n  inline void SetBlendState(BlendFunction dst, BlendFunction src) {\n   SetBlendState(true, 0, dst, dst, BlendEquation::Add, BlendEquation::Add, src, src);\n  }\n  inline void SetBlendState(BlendEquation eq) {\n   SetBlendState(true, 0, BlendFunction::Zero, BlendFunction::Zero, eq, eq, BlendFunction::One, BlendFunction::One);\n  }\n  inline void SetBlendState(bool blend) {\n   SetBlendState(blend, 0, BlendFunction::Zero, BlendFunction::Zero, BlendEquation::Add, BlendEquation::Add, BlendFunction::One, BlendFunction::One);\n  }\n  // End Blend state\n\n  // Cull state\n  void SetFaceVisibility(CullFace cull, FaceWind wind = FaceWind::CounterClockwise);\n  // End cull state\n\n  // Depth State\n  void SetDepthState(bool enable, DepthFunc depthFunc, f32* depthRange = 0);\n  inline void SetDepthState(DepthFunc depthFunc) {\n   SetDepthState(true, depthFunc, 0);\n  }\n  inline void SetDepthState(bool enable) {\n   SetDepthState(enable, DepthFunc::Less, 0);\n  }\n  // End depth state\n\n  // Scissor State\n  void SetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h);\n  inline void SetScissorState(bool enable) {\n   SetScissorState(enable, mScissorRect[0], mScissorRect[1], mScissorRect[2], mScissorRect[3]);\n  }\n  // End Scissor state\n\n\n  void WriteMask(bool r, bool g, bool b, bool a, bool depth);\n  void SetViewport(u32 x, u32 y, u32 w, u32 h);\n\n  void Clear(f32 r, f32 g, f32 b, f32 depth);\n  void Clear(f32 r, f32 g, f32 b);\n  void Clear(f32 depth);\n  void Clear(bool color, bool depth);\n\n  inline void SetUserData(u32 data) {\n   mUserData = data;\n  }\n\n  inline u32 GetUserData() {\n   return mUserData;\n  }\n\n  inline Dependencies* GetPlatform() {\n   return &mPlatform;\n  }\n };\n\n Device* Initialize(Device& outDevice, Dependencies& platform);\n inline Device* Initialize(Dependencies& platform) {\n  Device* result = (Device*)platform.Request(sizeof(Graphics::Device));\n  Initialize(*result, platform);\n  return result;\n }\n void Shutdown(Device& device);\n}\n typedef int i32;\n static_assert (sizeof(i32) == 4, \"i32 should be defined as a 4 byte type\");\n\n\ntypedef int GLenum;\n\nextern \"C\" void wasmGraphics_Log(const char* loc, int locLen, const char* msg, int msgLen);\nextern \"C\" void wasmGraphics_SetTexturePCM(int glTextureId, int glTextureAttachTarget, int glCompareMode, int glCompareFunc);\nextern \"C\" void wasmGraphics_TextureSetData(int glTextureId, int glInternalFormat, int width, int height, int glDataFormat, int glDataFormatType, void* data, bool genMipMaps);\nextern \"C\" void wasmGraphics_TextureSetCubemap(int glTextureId, int glInternalFormat, int width, int height, int glDataFormat, int glDataType, void* rightData, void* leftData, void* topData, void* bottomData, void* backData, void* frontData, bool genMipMaps);\nextern \"C\" void wasmGraphics_DeviceSetFaceVisibility(bool enableCullFace, bool disableCullFace, int cullFaceType, bool changeFace, int faceWind);\nextern \"C\" void wasmGraphics_DeviceClearRGBAD(float r, float g, float b, float d);\nextern \"C\" void wasmGraphics_SetDepthState(bool changeDepthState, int depthState, bool changeDepthFunc, int func, bool changeDepthRange, float depthRangeMin, float depthRangeMax);\nextern \"C\" void wasmGraphics_DeviceClearBufferBits(bool color, bool depth);\nextern \"C\" void wasmGraphics_DeviceWriteMask(bool r, bool g, bool b, bool a, bool depth);\nextern \"C\" void wasmGraphics_SetGLBlendFuncEnabled(bool state);\nextern \"C\" void wasmGraphics_UpdateGLBlendColor(float r, float g, float b, float a);\nextern \"C\" void wasmGraphics_ChangeGLBlendFuncSame(int srcRgb, int dstRgb);\nextern \"C\" void wasmGraphics_ChangeGLBlendFuncSeperate(int srcRgb, int dstRgb, int srcAlpha, int dstAlpha);\nextern \"C\" void wasmGraphics_ChangeGLBlendEquation(int rgbEquation);\nextern \"C\" void wasmGraphics_ChangeGLBlendEquationSeparate(int rgbEquation, int alphaEquation);\nextern \"C\" void wasmGraphics_DeviceClearColor(float r, float g, float b);\nextern \"C\" void wasmGraphics_DeviceClearDepth(float depth);\nextern \"C\" void wasmGraphics_SetGLViewport(int x, int y, int w, int h);\nextern \"C\" void wasmGraphics_DeviceSetScissorState(bool enableScissor, bool disableScissor, bool updateRect, int x, int y, int w, int h);\nextern \"C\" int wasmGraphics_GLGenFrameBuffer();\nextern \"C\" void wasmGraphics_DestroyFrameBuffer(int bufferId);\nextern \"C\" int wasmGraphics_GLGenBuffer();\nextern \"C\" void wasmGraphics_GLDestroyBuffer(int bufferId);\nextern \"C\" int wasmGraphics_GLCreateVAO();\nextern \"C\" void wasmGraphics_GLDestroyVAO(int vaoID);\nextern \"C\" int wasmGraphics_CreateTexture();\nextern \"C\" void wasmGraphics_GLDestroyTexture(int texId);\nextern \"C\" void wasmGraphics_GLDestroyShader(int shaderId);\nextern \"C\" void wasmGraphics_DeviceSetRenderTarget(int frameBufferId, int numAttachments);\nextern \"C\" void wasmGraphics_DeviceDraw(int glVao, bool indexed, int instanceCount, int drawMode, int startIndex, int indexCount, int bufferType);\nextern \"C\" void wasmGraphics_VertexLayoutSet(int glVaoId, int glBufferId, int slotId, int numComponents, int type, int stride, int offset, int divisor);\nextern \"C\" void wasmGraphics_VertexLayoutSetIndexBuffer(int glVaoId, int glElementArrayBufferId);\nextern \"C\" void wasmGraphics_FramebufferAttachColor(int attachTarget, int frameBufferId, int textureId, int attachmentIndex);\nextern \"C\" void wasmGraphics_FrameBufferAttachDepth(int target, int frameBufferId, int textureId, bool pcm);\nextern \"C\" bool wasmGraphics_FrameBufferIsValid(int frameBufferId);\nextern \"C\" void wasmGraphics_FrameBufferResolveTo(int readBuffer, int drawBuffer, int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, bool colorBit, bool depthBit, int filter);\nextern \"C\" int wasmGraphics_BufferReset(int bufferId);\nextern \"C\" void wasmGraphics_BufferSet(bool indexBuffer, int bufferId, int arraySizeInByfes, void* inputArray, bool isStatic);\nextern \"C\" int wasmGraphics_ShaderGetUniform(int program, const char* name, int name_len);\nextern \"C\" int wasmGraphics_ShaderGetAttribute(int program, const char* name, int name_len);\nextern \"C\" int wasmGraphics_ResetVertexLayout(int id);\nextern \"C\" void wasmGraphics_BindVAO(int vaoId);\nextern \"C\" void wasmGraphics_DeviceBindTexture(int textureUnitEnum, int textureUnitNumber, int textureTarget, int textureId, int uniformSlot, int minFilter, int magFilter, int wrapS, int wrapT, int wrapR, bool updateSampler);\nextern \"C\" void wasmGraphics_DeviceSetUniform(int type, int slotId, int count, void* data);\nextern \"C\" void wasmGraphics_DeviceBindShader(int programId, unsigned int boundTextures);\nextern \"C\" void wasmGraphics_SetDefaultGLState();\nextern \"C\" void wasmGraphics_GetScissorAndViewport(void* scissorPtr, void* viewPtr); // Might need to make a \"SetRect\" function to support in wasm\nextern \"C\" int wasmGraphics_CompileShader(const void* vShader, int vShaderLen, const void* fShader, int fShaderLen);\n\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#standard_webgl_1_constants\n// Helpers\nnamespace Graphics {\n namespace Internal {\n  void Assert(bool cond, const char* location, const char* msg) {\n   if (cond == false) {\n    u32 msgLen = 0;\n    for (const char* i = msg; msg != 0 && *i != '\\0'; ++i, ++msgLen);\n    u32 locLen = 0;\n    for (const char* i = location; location != 0 && *i != '\\0'; ++i, ++locLen);\n\n    wasmGraphics_Log(location, locLen, msg, msgLen);\n    __builtin_trap();\n   }\n  }\n\n  struct TextureFormatResult {\n   GLenum dataType;\n   GLenum dataFormat;\n  };\n\n  struct ShaderCompileResult {\n   bool success;\n   u32 program;\n   char* uniforms;\n   char* attributes;\n   u32 numAttribs;\n   u32 numUniforms;\n\n   ShaderCompileResult() {\n    success = false;\n    program = 0;\n    uniforms = 0;\n    attributes = 0;\n    numAttribs = 0;\n    numUniforms = 0;\n   }\n  };\n\n  inline GLenum DepthFuncToEnum(DepthFunc f) {\n   if (f == DepthFunc::Always) {\n    return 0x0207;\n   }\n   else if (f == DepthFunc::Never) {\n    return 0x0200;\n   }\n   else if (f == DepthFunc::Equal) {\n    return 0x0202;\n   }\n   else if (f == DepthFunc::LEqual) {\n    return 0x0203;\n   }\n   else if (f == DepthFunc::Greater) {\n    return 0x0204;\n   }\n   else if (f == DepthFunc::GEqual) {\n    return 0x0206;\n   }\n   else if (f == DepthFunc::NotEqual) {\n    return 0x0205;\n   }\n\n   return 0x0201;\n  }\n\n  inline GLenum GetTextureUnit(u32 index) {\n   Graphics::Internal::Assert(index <= 32, \"On line: \" \"219\" \", in file: \" \"./GraphicsWASM.cpp\", \"Only supports up to GL_TEXTURE16\");\n\n   return 0x84C0 + index;\n  }\n\n  inline GLenum BlendEqToEnum(BlendEquation b) {\n   if (b == BlendEquation::Subtract) {\n    return 0x800A;\n   }\n   else if (b == BlendEquation::ReverseSubtract) {\n    return 0x800B;\n   }\n   else if (b == BlendEquation::Min) {\n    return 0x8007;\n   }\n   else if (b == BlendEquation::Max) {\n    return 0x8008;\n   }\n\n   return 0x8006;\n  }\n\n  inline GLenum BlendfuncToEnum(BlendFunction b) {\n   GLenum result = 0;\n   if (b == BlendFunction::One) {\n    result = 1;\n   }\n   else if (b == BlendFunction::SrcColor) {\n    result = 0x0300;\n   }\n   else if (b == BlendFunction::OneMinusSrcColor) {\n    result = 0x0301;\n   }\n   else if (b == BlendFunction::DstColor) {\n    result = 0x0306;\n   }\n   else if (b == BlendFunction::OneMinusDstColor) {\n    result = 0x0307;\n   }\n   else if (b == BlendFunction::SrcAlpha) {\n    result = 0x0302;\n   }\n   else if (b == BlendFunction::OneMinusSrcAlpha) {\n    result = 0x0303;\n   }\n   else if (b == BlendFunction::DstAlpha) {\n    result = 0x0304;\n   }\n   else if (b == BlendFunction::OneMinusDstAlpha) {\n    result = 0x0305;\n   }\n   else if (b == BlendFunction::ConstColor) {\n    result = 0x8001;\n   }\n   else if (b == BlendFunction::OneMinusConstColor) {\n    result = 0x8002;\n   }\n   else if (b == BlendFunction::ConstAlpha) {\n    result = 0x8003;\n   }\n   else if (b == BlendFunction::OneMinusconstAlpha) {\n    result = 0x8004;\n   }\n   else if (b == BlendFunction::SrcAlphaSaturate) {\n    result = 0x0308;\n   }\n   return result;\n  }\n\n  inline GLenum DrawModeToEnum(DrawMode drawMode) {\n   GLenum mode = 0x0004;\n   if (drawMode == DrawMode::Points) {\n    mode = 0x0000;\n   }\n   else if (drawMode == DrawMode::Lines) {\n    mode = 0x0001;\n   }\n   else if (drawMode == DrawMode::LineStrip) {\n    mode = 0x0003;\n   }\n   else if (drawMode == DrawMode::TriangleStrip) {\n    mode = 0x0005;\n   }\n   else if (drawMode == DrawMode::TriangleFan) {\n    mode = 0x0006;\n   }\n   return mode;\n  }\n\n  inline GLenum TextureGetInternalFormatFromEnum(TextureFormat component) {\n   if (component == TextureFormat::R8) {\n    return 0x8229;\n   }\n   else if (component == TextureFormat::RG8) {\n    return 0x822B;\n   }\n   if (component == TextureFormat::RGB8) {\n    return 0x8051;\n   }\n   if (component == TextureFormat::RGBA8) {\n    return 0x8058;\n   }\n\n   if (component == TextureFormat::R32F) {\n    return 0x822E;\n   }\n   else if (component == TextureFormat::RG32F) {\n    return 0x8230;\n   }\n   if (component == TextureFormat::RGB32F) {\n    return 0x8815;\n   }\n   if (component == TextureFormat::RGBA32F) {\n    return 0x8814;\n   }\n\n   return 0x81A6; // Default to depth i guess\n  }\n\n  inline TextureFormatResult TextureGetDataFormatFromEnum(TextureFormat component) {\n   GLenum dataFormat = 0x81A6;\n   GLenum dataType = 0x1405;\n\n   if (component == TextureFormat::R8) {\n    dataFormat = 0x1903;\n    dataType = 0x1401;\n   }\n   else if (component == TextureFormat::RG8) {\n    dataFormat = 0x822B;\n    dataType = 0x1401;\n   }\n   if (component == TextureFormat::RGB8) {\n    dataFormat = 0x1907;\n    dataType = 0x1401;\n   }\n   if (component == TextureFormat::RGBA8) {\n    dataFormat = 0x1908;\n    dataType = 0x1401;\n   }\n\n   if (component == TextureFormat::R32F) {\n    dataFormat = 0x1903;\n    dataType = 0x1406;\n   }\n   else if (component == TextureFormat::RG32F) {\n    dataFormat = 0x8230;\n    dataType = 0x1406;\n   }\n   if (component == TextureFormat::RGB32F) {\n    dataFormat = 0x1907;\n    dataType = 0x1406;\n   }\n   if (component == TextureFormat::RGBA32F) {\n    dataFormat = 0x1908;\n    dataType = 0x1406;\n   }\n\n   TextureFormatResult result;\n   result.dataFormat = dataFormat;\n   result.dataType = dataType;\n   return result;\n  }\n\n  inline GLenum BufferTypeToEnum(BufferType bufferType) {\n   GLenum type = 0x1406;\n\n   if (bufferType == BufferType::Int8) {\n    type = 0x1400;\n   }\n   else if (bufferType == BufferType::UInt8) {\n    type = 0x1401;\n   }\n   else if (bufferType == BufferType::Int16) {\n    type = 0x1402;\n   }\n   else if (bufferType == BufferType::UInt16) {\n    type = 0x1403;\n   }\n   else if (bufferType == BufferType::Int32) {\n    type = 0x1404;\n   }\n   else if (bufferType == BufferType::UInt32) {\n    type = 0x1405;\n   }\n\n   return type;\n  }\n\n  ShaderCompileResult CompileOpenGLShader(const char* vertexSource, const char* fragmentSource, Dependencies* platform) {\n   ShaderCompileResult result;\n   result.program = 0;\n\n   int vLen = 0;\n   Graphics::Internal::Assert(vertexSource != 0, \"On line: \" \"412\" \", in file: \" \"./GraphicsWASM.cpp\", \"Empty vertex pointer\");\n   for (const char* i = vertexSource; *i != '\\0'; ++i, ++vLen);\n   const char* vp1 = vertexSource + 1;\n   Graphics::Internal::Assert(vLen != 0, \"On line: \" \"415\" \", in file: \" \"./GraphicsWASM.cpp\", \"Empty vertex shader\");\n\n   int fLen = 0;\n   Graphics::Internal::Assert(fragmentSource != 0, \"On line: \" \"418\" \", in file: \" \"./GraphicsWASM.cpp\", \"Empty fragment pointer\");\n   for (const char* i = fragmentSource; *i != '\\0'; ++i, ++fLen);\n   Graphics::Internal::Assert(fLen != 0, \"On line: \" \"420\" \", in file: \" \"./GraphicsWASM.cpp\", \"Empty fragment shader\");\n\n   result.program = wasmGraphics_CompileShader(vertexSource, vLen, fragmentSource, fLen);\n   result.success = result.program != 0;\n   Graphics::Internal::Assert(result.success, \"On line: \" \"424\" \", in file: \" \"./GraphicsWASM.cpp\", \"Could not compile shader\");\n\n   return result;\n  }\n }\n}\n\n/// Texture\nvoid Graphics::Texture::SetPCM(bool pcm) {\n GLenum attachTarget = 0x0DE1;\n if (mIsCubeMap) {\n  attachTarget = 0x8513;\n }\n\n GLenum compareMode = 0;\n GLenum compareFunc = 0;\n if (pcm) {\n  compareMode = 0x884E;\n  compareFunc = 0x0203;\n }\n\n\n wasmGraphics_SetTexturePCM(mId, attachTarget, compareMode, compareFunc);\n}\n\nvoid Graphics::Texture::Set(void* data, TextureFormat dataFormat, u32 width, u32 height, bool genMipMaps) {\n GLenum internalFormat = Internal::TextureGetInternalFormatFromEnum(mInternalFormat);\n Internal::TextureFormatResult f = Internal::TextureGetDataFormatFromEnum(dataFormat);\n\n mWidth = width;\n mHeight = height;\n mIsCubeMap = false;\n mIsMipMapped = genMipMaps;\n\n wasmGraphics_TextureSetData(mId, internalFormat, width, height, f.dataFormat, f.dataType, data, genMipMaps);\n}\n\nvoid Graphics::Texture::SetCubemap(void* rightData, void* leftData, void* topData, void* bottomData, void* backData, void* frontData,\n u32 width, u32 height, TextureFormat texFormat, bool genMipMaps) {\n\n GLenum internalFormat = Internal::TextureGetInternalFormatFromEnum(mInternalFormat);\n Internal::TextureFormatResult f = Internal::TextureGetDataFormatFromEnum(texFormat);\n\n mWidth = width;\n mHeight = height;\n mIsCubeMap = true;\n mIsMipMapped = genMipMaps;\n\n wasmGraphics_TextureSetCubemap(mId, internalFormat, width, height, f.dataFormat, f.dataType, rightData, leftData, topData, bottomData, backData, frontData, genMipMaps);\n}\n\n/// Device\n\nvoid Graphics::Device::SetFaceVisibility(CullFace cull, FaceWind wind) {\n bool enableCullFace = false;\n bool disableCullFace = false;\n GLenum cullFaceType = 0x0405;\n bool changeFace = false;\n GLenum faceWind = 0x0901;\n\n if (mFaceCulling != cull) {\n  if (cull == CullFace::Back) {\n   if (mFaceCulling == CullFace::Off) {\n    enableCullFace = true;\n   }\n   cullFaceType = 0x0405;\n  }\n  else if (cull == CullFace::Front) {\n   if (mFaceCulling == CullFace::Off) {\n    enableCullFace = true;\n   }\n   cullFaceType = 0x0404;\n  }\n  else if (cull == CullFace::FrontAndBack) {\n   if (mFaceCulling == CullFace::Off) {\n    enableCullFace = true;\n   }\n   cullFaceType = 0x0408;\n  }\n  else { // Off\n   if (mFaceCulling != CullFace::Off) {\n    disableCullFace = true;\n   }\n  }\n  mFaceCulling = cull;\n }\n\n if (mWindingOrder != wind) {\n  changeFace = true;\n  if (wind == FaceWind::CounterClockwise) {\n   faceWind = 0x0901;\n  }\n  else {\n   faceWind = 0x0900;\n  }\n  mWindingOrder = wind;\n }\n\n if (enableCullFace || disableCullFace || changeFace) {\n  wasmGraphics_DeviceSetFaceVisibility(enableCullFace, disableCullFace, cullFaceType, changeFace, faceWind);\n }\n}\n\nvoid Graphics::Device::SetDepthState(bool enable, DepthFunc depthFunc, f32* depthRange) {\n bool changeDepthState = false;\n GLenum depthState = 0x0B71;\n bool changeDepthFunc = false;\n GLenum func = 0;\n bool changeDepthRange = false;\n float depthRangeMin = 0.0f;\n float depthRangeMax = 0.0f;\n\n if (mDepth != enable) {\n  changeDepthState = true;\n  if (enable) {\n   depthState = 0x0B71;\n  }\n  else {\n   depthState = 0; // Disabled\n  }\n  mDepth = enable;\n }\n\n if (mDepthFunc != depthFunc) {\n  changeDepthFunc = true;\n  func = Internal::DepthFuncToEnum(depthFunc);\n  mDepthFunc = depthFunc;\n }\n\n if (depthRange != 0) {\n  changeDepthRange = true;\n  mDepthRange[0] = depthRangeMin = depthRange[0];\n  mDepthRange[1] = depthRangeMax = depthRange[1];\n }\n\n if (changeDepthState || changeDepthFunc || changeDepthRange) {\n  wasmGraphics_SetDepthState(changeDepthState, depthState, changeDepthFunc, func, changeDepthRange, depthRangeMin, depthRangeMax);\n }\n}\n\nvoid Graphics::Device::SetBlendState(bool blend, f32* blendColor,\n BlendFunction blendDstRgb, BlendFunction blendDstAlpha,\n BlendEquation blendEquationRgb, BlendEquation blendEquationAlpha,\n BlendFunction blendSrcRGB, BlendFunction blendSrcAlpha) {\n\n if (blend != mBlend) {\n  if (blend) {\n   wasmGraphics_SetGLBlendFuncEnabled(false);\n  }\n  else {\n   wasmGraphics_SetGLBlendFuncEnabled(true);\n  }\n  mBlend = blend;\n }\n\n if (blendColor != 0) {\n  mBlendColor[0] = blendColor[0];\n  mBlendColor[1] = blendColor[1];\n  mBlendColor[2] = blendColor[2];\n  mBlendColor[3] = blendColor[3];\n  wasmGraphics_UpdateGLBlendColor(mBlendColor[0], mBlendColor[1], mBlendColor[2], mBlendColor[3]);\n }\n\n if (mBlendDstAlpha != blendDstAlpha || mBlendDstRGB != blendDstRgb ||\n  mBlendSrcAlpba != blendSrcAlpha || mBlendSrcRGB != blendSrcRGB) {\n  GLenum srcAlpha = Internal::BlendfuncToEnum(blendSrcAlpha);\n  GLenum srcRgb = Internal::BlendfuncToEnum(blendSrcRGB);\n  GLenum dstAlpha = Internal::BlendfuncToEnum(blendDstAlpha);\n  GLenum dstRgb = Internal::BlendfuncToEnum(blendDstRgb);\n\n  if (blendDstAlpha == blendDstRgb && blendSrcAlpha == blendSrcRGB) { // Same\n   wasmGraphics_ChangeGLBlendFuncSame(srcRgb, dstRgb);\n  }\n  else { // Seperate\n   wasmGraphics_ChangeGLBlendFuncSeperate(srcRgb, dstRgb, srcAlpha, dstAlpha);\n  }\n  mBlendDstAlpha = blendDstAlpha;\n  mBlendDstRGB = blendDstRgb;\n  mBlendSrcAlpba = blendSrcAlpha;\n  mBlendSrcRGB = blendSrcRGB;\n }\n\n if (mBlendEquationAlpha != blendEquationAlpha || mBlendEquationRGB != blendEquationRgb) {\n  GLenum alphaEquation = Internal::BlendEqToEnum(blendEquationAlpha);\n  GLenum rgbEquation = Internal::BlendEqToEnum(blendEquationRgb);\n\n  if (blendEquationAlpha == blendEquationRgb) { // Same\n   wasmGraphics_ChangeGLBlendEquation(rgbEquation);\n  }\n  else { // Seperate\n   wasmGraphics_ChangeGLBlendEquationSeparate(rgbEquation, alphaEquation);\n  }\n\n  mBlendEquationAlpha = blendEquationAlpha;\n  mBlendEquationRGB = blendEquationRgb;\n }\n}\n\nvoid Graphics::Device::Clear(f32 r, f32 g, f32 b, f32 depth) {\n wasmGraphics_DeviceClearRGBAD(r, g, b, depth);\n}\n\nvoid Graphics::Device::Clear(bool color, bool depth) {\n wasmGraphics_DeviceClearBufferBits(color, depth);\n}\n\nvoid Graphics::Device::WriteMask(bool r, bool g, bool b, bool a, bool depth) {\n wasmGraphics_DeviceWriteMask(r, g, b, a, depth);\n}\n\nvoid Graphics::Device::Clear(f32 r, f32 g, f32 b) {\n wasmGraphics_DeviceClearColor(r, g, b);\n}\n\nvoid Graphics::Device::Clear(f32 depth) {\n wasmGraphics_DeviceClearDepth(depth);\n}\n\nvoid Graphics::Device::SetViewport(u32 x, u32 y, u32 w, u32 h) {\n if (x != mViewportRect[0] || y != mViewportRect[1] ||\n  w != mViewportRect[2] || h != mViewportRect[3]) {\n  wasmGraphics_SetGLViewport(x, y, w, h);\n  mViewportRect[0] = x;\n  mViewportRect[1] = y;\n  mViewportRect[2] = w;\n  mViewportRect[3] = h;\n }\n}\n\nvoid Graphics::Device::SetScissorState(bool enable, u32 x, u32 y, u32 w, u32 h) {\n bool enableScissor = false;\n bool disableScissor = false;\n bool updateRect = false;\n\n\n if (enable != mScissor) {\n  if (enable) {\n   enableScissor = true;\n  }\n  else {\n   disableScissor = true;\n  }\n\n  mScissor = enable;\n }\n\n if (x != mScissorRect[0] || y != mScissorRect[1] || w != mScissorRect[2] || h != mScissorRect[3]) {\n  mScissorRect[0] = x;\n  mScissorRect[1] = y;\n  mScissorRect[2] = w;\n  mScissorRect[3] = h;\n }\n\n if (enableScissor || disableScissor || updateRect) {\n  wasmGraphics_DeviceSetScissorState(enableScissor, disableScissor, updateRect, x, y, w, h);\n }\n}\n\nGraphics::FrameBuffer* Graphics::Device::CreateFrameBuffer() {\n Graphics::FrameBuffer* result = (Graphics::FrameBuffer*)mPlatform.Request(sizeof(Graphics::FrameBuffer));\n result->mId = wasmGraphics_GLGenFrameBuffer();\n result->mColor0 = 0;\n result->mColor1 = 0;\n result->mColor2 = 0;\n result->mColor3 = 0;\n result->mColor4 = 0;\n result->mColor5 = 0;\n result->mDepth = 0;\n result->mUserData = 0;\n result->mOwner = this;\n result->mAllocPrev = 0;\n result->mAllocNext = mAllocatedFrameBuffers;\n if (mAllocatedFrameBuffers != 0) {\n  mAllocatedFrameBuffers->mAllocPrev = result;\n }\n mAllocatedFrameBuffers = result;\n result->mReadBufferConfig = 0x0404;\n\n return result;\n}\n\nvoid Graphics::Device::Destroy(FrameBuffer* buffer) {\n wasmGraphics_DestroyFrameBuffer(buffer->mId);\n mBoundFrameBuffer = 0;\n\n if (buffer->mAllocPrev != 0) { // Not head\n  buffer->mAllocPrev->mAllocNext = buffer->mAllocNext;\n  if (buffer->mAllocNext != 0) {\n   buffer->mAllocNext->mAllocPrev = buffer->mAllocPrev;\n  }\n }\n else { // Head\n  mAllocatedFrameBuffers = mAllocatedFrameBuffers->mAllocNext;\n  if (mAllocatedFrameBuffers != 0) {\n   mAllocatedFrameBuffers->mAllocPrev = 0;\n  }\n }\n\n mPlatform.Release(buffer);\n}\n\nGraphics::Buffer* Graphics::Device::CreateBuffer() {\n Graphics::Buffer* result = (Graphics::Buffer*)mPlatform.Request(sizeof(Graphics::Buffer));\n result->mId = wasmGraphics_GLGenBuffer();\n result->mIndexBuffer = false;\n result->mUserData = 0;\n result->mOwner = this;\n result->mAllocPrev = 0;\n result->mAllocNext = mAllocatedBuffers;\n if (mAllocatedBuffers != 0) {\n  mAllocatedBuffers->mAllocPrev = result;\n }\n mAllocatedBuffers = result;\n\n return result;\n}\n\nGraphics::Buffer* Graphics::Device::CreateIndexBuffer() {\n Graphics::Buffer* result = (Graphics::Buffer*)mPlatform.Request(sizeof(Graphics::Buffer));\n result->mId = wasmGraphics_GLGenBuffer();\n result->mIndexBuffer = true;\n result->mUserData = 0;\n result->mOwner = this;\n result->mAllocPrev = 0;\n result->mAllocNext = mAllocatedBuffers;\n if (mAllocatedBuffers != 0) {\n  mAllocatedBuffers->mAllocPrev = result;\n }\n mAllocatedBuffers = result;\n\n return result;\n}\n\nvoid Graphics::Device::Destroy(Buffer* buff) {\n wasmGraphics_GLDestroyBuffer(buff->mId);\n\n if (buff->mAllocPrev != 0) { // Not head\n  buff->mAllocPrev->mAllocNext = buff->mAllocNext;\n  if (buff->mAllocNext != 0) {\n   buff->mAllocNext->mAllocPrev = buff->mAllocPrev;\n  }\n }\n else { // Head\n  mAllocatedBuffers = mAllocatedBuffers->mAllocNext;\n  if (mAllocatedBuffers != 0) {\n   mAllocatedBuffers->mAllocPrev = 0;\n  }\n }\n\n mPlatform.Release(buff);\n}\n\nGraphics::VertexLayout* Graphics::Device::CreateVertexLayout() {\n Graphics::VertexLayout* result = (Graphics::VertexLayout*)mPlatform.Request(sizeof(Graphics::VertexLayout));\n\n result->mId = wasmGraphics_GLCreateVAO();\n result->mUserData = 0;\n result->mIndexBufferType = Graphics::BufferType::UInt32;\n result->mHasIndexBuffer = false;\n\n result->mAllocPrev = 0;\n result->mAllocNext = mAllocatedStates;\n if (mAllocatedStates != 0) {\n  mAllocatedStates->mAllocPrev = result;\n }\n mAllocatedStates = result;\n\n return result;\n}\n\nvoid Graphics::Device::Destroy(VertexLayout* map) {\n wasmGraphics_GLDestroyVAO(map->mId);\n\n if (map->mAllocPrev != 0) { // Not head\n  map->mAllocPrev->mAllocNext = map->mAllocNext;\n  if (map->mAllocNext != 0) {\n   map->mAllocNext->mAllocPrev = map->mAllocPrev;\n  }\n }\n else { // Head\n  mAllocatedStates = mAllocatedStates->mAllocNext;\n  if (mAllocatedStates != 0) {\n   mAllocatedStates->mAllocPrev = 0;\n  }\n }\n\n mPlatform.Release(map);\n}\n\nGraphics::Texture* Graphics::Device::CreateTexture(TextureFormat format) {\n Graphics::Texture* result = (Graphics::Texture*)mPlatform.Request(sizeof(Graphics::Texture));\n\n result->mId = wasmGraphics_CreateTexture();\n\n result->mWidth = 0;\n result->mHeight = 0;\n result->mInternalFormat = format;\n result->mIsMipMapped = false;\n result->mIsCubeMap = false;\n result->mUserData = 0;\n\n result->mCachedMin = 0x2702;\n result->mCachedMag = 0x2601;\n\n result->mCachedS = 0x2901;\n result->mCachedR = 0x2901;\n result->mCachedT = 0x2901;\n\n result->mOwner = this;\n result->mAllocPrev = 0;\n result->mAllocNext = mAllocatedTextures;\n if (mAllocatedTextures != 0) {\n  mAllocatedTextures->mAllocPrev = result;\n }\n mAllocatedTextures = result;\n\n return result;\n}\n\nvoid Graphics::Device::Destroy(Texture* buff) {\n wasmGraphics_GLDestroyTexture(buff->mId);\n\n if (buff->mAllocPrev != 0) { // Not head\n  buff->mAllocPrev->mAllocNext = buff->mAllocNext;\n  if (buff->mAllocNext != 0) {\n   buff->mAllocNext->mAllocPrev = buff->mAllocPrev;\n  }\n }\n else { // Head\n  mAllocatedTextures = mAllocatedTextures->mAllocNext;\n  if (mAllocatedTextures != 0) {\n   mAllocatedTextures->mAllocPrev = 0;\n  }\n }\n\n mPlatform.Release(buff);\n}\n\nGraphics::Shader* Graphics::Device::CreateShader(const char* vertex, const char* fragment) {\n Graphics::Shader* result = 0;\n\n Graphics::Internal::ShaderCompileResult compileStatus =\n Graphics::Internal::CompileOpenGLShader(vertex, fragment, &mPlatform);\n Graphics::Internal::Assert(compileStatus.success, \"On line: \" \"867\" \", in file: \" \"./GraphicsWASM.cpp\", \"Failed to compile shader\");\n\n if (compileStatus.success) {\n  result = (Graphics::Shader*)mPlatform.Request(sizeof(Graphics::Shader));\n  result->mProgram = compileStatus.program;\n }\n\n result->mUserData = 0;\n result->mOwner = this;\n result->mAllocPrev = 0;\n result->mAllocNext = mAllocatedShaders;\n if (mAllocatedShaders != 0) {\n  mAllocatedShaders->mAllocPrev = result;\n }\n mAllocatedShaders = result;\n\n\n return result;\n}\n\nvoid Graphics::Device::Destroy(Shader* shader) {\n wasmGraphics_GLDestroyShader(shader->mProgram);\n mBoundProgram = 0;\n shader->mProgram = 0;\n\n if (shader->mAllocPrev != 0) { // Not head\n  shader->mAllocPrev->mAllocNext = shader->mAllocNext;\n  if (shader->mAllocNext != 0) {\n   shader->mAllocNext->mAllocPrev = shader->mAllocPrev;\n  }\n }\n else { // Head\n  mAllocatedShaders = mAllocatedShaders->mAllocNext;\n  if (mAllocatedShaders != 0) {\n   mAllocatedShaders->mAllocPrev = 0;\n  }\n }\n\n mPlatform.Release(shader);\n}\n\nvoid Graphics::Device::SetRenderTarget(FrameBuffer* frameBuffer) {\n const u32 attachments[8] = {\n  0x8CE0,\n  0x8CE1,\n  0x8CE2,\n  0x8CE3,\n  0x8CE4,\n  0x8CE5,\n  0x8CE6,\n  0x8CE7,\n };\n\n int frameBufferId = 0;\n int numAttachments = 0;\n\n if (frameBuffer != 0) {\n  frameBufferId = frameBuffer->mId;\n  mBoundFrameBuffer = frameBuffer->mId;\n  numAttachments = frameBuffer->TargetCount();\n  if (numAttachments == 0) {\n   frameBuffer->mReadBufferConfig = 0;\n  }\n  else {\n   frameBuffer->mReadBufferConfig = 0x0404;\n  }\n  Graphics::Internal::Assert(numAttachments <= 8, \"On line: \" \"933\" \", in file: \" \"./GraphicsWASM.cpp\", \"Only supports up to 8 color attachments\");\n }\n else if (mBoundFrameBuffer != 0) {\n  const u32 back_attach[1] = {0x0405};\n  frameBufferId = 0;\n  mBoundFrameBuffer = 0;\n  numAttachments = 1;\n }\n\n wasmGraphics_DeviceSetRenderTarget(frameBufferId, numAttachments);\n}\n\nvoid Graphics::Device::Bind(Shader* shader) {\n u32 program = 0;\n if (shader != 0) {\n  program = shader->mProgram;\n }\n\n if (mBoundProgram != program) {\n  mBoundProgram = program;\n  u32 bound = 0;\n  { // Unbind any previously bound textures\n   for (u32 i = 0; i < 32; ++i) {\n    if (mBoundTextures[i].texture != 0) {\n     mBoundTextures[i].texture = 0;\n     mBoundTextures[i].target = 0;\n     mBoundTextures[i].index.id = 0;\n     mBoundTextures[i].index.valid = false;\n     bound |= (1U << i);\n    }\n   }\n  }\n  wasmGraphics_DeviceBindShader(program, bound);\n }\n}\n\nvoid Graphics::Device::Bind(Index& slot, UniformType type, void* data, u32 count) {\n Graphics::Internal::Assert(slot.valid, \"On line: \" \"970\" \", in file: \" \"./GraphicsWASM.cpp\", \"Setting invalid uniform\");\n Graphics::Internal::Assert(slot.valid || (!slot.valid && slot.id != 0), \"On line: \" \"971\" \", in file: \" \"./GraphicsWASM.cpp\", \"Something messed with slot\");\n wasmGraphics_DeviceSetUniform((int)type, slot.id, count, data);\n}\n\nvoid Graphics::Device::Bind(Index& uniformSlot, Texture& texture, Sampler& sampler) {\n GLenum min = 0x2600;\n GLenum mag = 0x2601;\n\n if (texture.mIsMipMapped) {\n  if (sampler.min == Filter::Nearest) {\n   if (sampler.mip == Filter::Nearest) {\n    min = 0x2700;\n   }\n   else {\n    min = 0x2702;\n   }\n  }\n  else {\n   if (sampler.mip == Filter::Nearest) {\n    min = 0x2701;\n   }\n   else {\n    min = 0x2703;\n   }\n  }\n }\n else {\n  if (sampler.min == Filter::Linear) {\n   min = 0x2601;\n  }\n }\n\n if (sampler.mag == Filter::Nearest) {\n  mag = 0x2600;\n }\n\n GLenum wrapS = 0x2901;\n GLenum wrapT = 0x2901;\n GLenum wrapR = 0x2901;\n\n if (sampler.wrapS == WrapMode::Clamp) {\n  wrapS = 0x812F;\n }\n\n if (sampler.wrapT == WrapMode::Clamp) {\n  wrapT = 0x812F;\n }\n\n if (sampler.wrapR == WrapMode::Clamp) {\n  wrapR = 0x812F;\n }\n\n GLenum target = 0x0DE1;\n if (texture.mIsCubeMap) {\n  target = 0x8513;\n }\n\n // Find texture unit\n u32 textureUnit = 33;\n u32 firstFree = 33;\n for (u32 i = 0; i < 32; ++i) {\n  if (mBoundTextures[i].texture != 0) { // Something is bound\n   if (mBoundTextures[i].index.valid && mBoundTextures[i].index.id == uniformSlot.id) { // Re-use\n    textureUnit = i;\n    Graphics::Internal::Assert(target == mBoundTextures[i].target, \"On line: \" \"1035\" \", in file: \" \"./GraphicsWASM.cpp\", \"Binding invalid texture types\");\n    break;\n   }\n  }\n  else if (firstFree == 33) {\n   Graphics::Internal::Assert(!mBoundTextures[i].index.valid, \"On line: \" \"1040\" \", in file: \" \"./GraphicsWASM.cpp\", \"free slot should not be valid\");\n   firstFree = i;\n  }\n }\n if (textureUnit == 33) {\n  textureUnit = firstFree;\n  mBoundTextures[firstFree].index = uniformSlot;\n  Graphics::Internal::Assert(mBoundTextures[firstFree].index.valid, \"On line: \" \"1047\" \", in file: \" \"./GraphicsWASM.cpp\", \"Found invalid index\");\n  mBoundTextures[firstFree].target = target;\n  mBoundTextures[firstFree].texture = &texture;\n }\n Graphics::Internal::Assert(textureUnit < 33, \"On line: \" \"1051\" \", in file: \" \"./GraphicsWASM.cpp\", \"Invalid texture unit\");\n\n\n GLenum enumTextureUnit = Internal::GetTextureUnit(textureUnit);\n\n bool updateSampler = false;\n // Set min and mag filter\n if (texture.mCachedMin != min) {\n  updateSampler = true;\n  texture.mCachedMin = min;\n }\n if (texture.mCachedMag != mag) {\n  updateSampler = true;\n  texture.mCachedMag = mag;\n }\n\n // Set Wrap Mode\n if (texture.mCachedS != wrapS) {\n  updateSampler = true;\n  texture.mCachedS = wrapS;\n }\n if (texture.mCachedT != wrapT) {\n  updateSampler = true;\n  texture.mCachedT = wrapT;\n }\n if (texture.mIsCubeMap) {\n  if (texture.mCachedR != wrapR) {\n   updateSampler = true;\n   texture.mCachedR = wrapR;\n  }\n }\n\n wasmGraphics_DeviceBindTexture(enumTextureUnit, textureUnit, target, texture.mId, uniformSlot.id, min, mag, wrapS, wrapT, wrapR, updateSampler);\n}\n\nvoid Graphics::Device::Draw(const VertexLayout& attributes, DrawMode drawMode, u32 startIndex, u32 indexCount, u32 instanceCount) {\n GLenum type = Internal::BufferTypeToEnum(attributes.mIndexBufferType);\n GLenum _drawMode = Internal::DrawModeToEnum(drawMode);\n\n wasmGraphics_DeviceDraw(attributes.mId, attributes.mHasIndexBuffer, instanceCount, _drawMode, startIndex, indexCount, type);\n}\n\nGraphics::Device* Graphics::Initialize(Device& outDevice, Dependencies& alloc) {\n outDevice.mPlatform = alloc;\n outDevice.mBoundProgram = 0;\n outDevice.mBoundFrameBuffer = 0;\n\n for (u32 i = 0; i < 32; ++i) {\n  outDevice.mBoundTextures[i].index.id = 0;\n  outDevice.mBoundTextures[i].index.valid = false;\n  outDevice.mBoundTextures[i].texture = 0;\n  outDevice.mBoundTextures[i].target = 0;\n }\n\n outDevice.mUserData = 0;\n outDevice.mAllocatedTextures = 0;\n outDevice.mAllocatedBuffers = 0;\n outDevice.mAllocatedStates = 0;\n outDevice.mAllocatedShaders = 0;\n outDevice.mAllocatedFrameBuffers = 0;\n\n // Blend State\n outDevice.mBlend = false;\n\n outDevice.mBlendColor[0] = 0.0f;\n outDevice.mBlendColor[1] = 0.0f;\n outDevice.mBlendColor[2] = 0.0f;\n outDevice.mBlendColor[3] = 0.0f;\n\n outDevice.mBlendSrcAlpba = BlendFunction::One;\n outDevice.mBlendSrcRGB = BlendFunction::One;\n outDevice.mBlendDstAlpha = BlendFunction::Zero;\n outDevice.mBlendDstRGB = BlendFunction::Zero;\n\n outDevice.mBlendEquationAlpha = BlendEquation::Add;\n outDevice.mBlendEquationRGB = BlendEquation::Add;\n\n // Cull state\n outDevice.mFaceCulling = CullFace::Back;\n outDevice.mWindingOrder = FaceWind::CounterClockwise;\n\n // Depth state\n outDevice.mDepth = true;\n outDevice.mDepthFunc = DepthFunc::Less;\n outDevice.mDepthRange[0] = 0.0f;\n outDevice.mDepthRange[1] = 1.0f;\n\n // Scissor state\n wasmGraphics_SetDefaultGLState();\n wasmGraphics_GetScissorAndViewport(outDevice.mScissorRect, outDevice.mViewportRect);\n outDevice.mScissor = false;\n\n return &outDevice;\n}\n\nvoid Graphics::Shutdown(Device& device) {\n device.Bind(0);\n wasmGraphics_BindVAO(0);\n\n Graphics::Internal::Assert(device.mAllocatedTextures == 0, \"On line: \" \"1150\" \", in file: \" \"./GraphicsWASM.cpp\", \"Not all memory has been released\");\n Graphics::Internal::Assert(device.mAllocatedBuffers == 0, \"On line: \" \"1151\" \", in file: \" \"./GraphicsWASM.cpp\", \"Not all memory has been released\");\n Graphics::Internal::Assert(device.mAllocatedStates == 0, \"On line: \" \"1152\" \", in file: \" \"./GraphicsWASM.cpp\", \"Not all memory has been released\");\n Graphics::Internal::Assert(device.mAllocatedShaders == 0, \"On line: \" \"1153\" \", in file: \" \"./GraphicsWASM.cpp\", \"Not all memory has been released\");\n Graphics::Internal::Assert(device.mAllocatedFrameBuffers == 0, \"On line: \" \"1154\" \", in file: \" \"./GraphicsWASM.cpp\", \"Not all memory has been released\");\n\n device.mPlatform.Request = 0;\n device.mPlatform.Release = 0;\n}\n\n// Pipeline state\nvoid Graphics::VertexLayout::Set(const Index& index, const Buffer& buffer, const BufferView& view, u32 instanceDivisor) {\n GLenum type = Internal::BufferTypeToEnum(view.Type);\n wasmGraphics_VertexLayoutSet(mId, buffer.mId, index.id, view.NumberOfComponents, type, view.StrideInBytes, view.DataOffsetInBytes, instanceDivisor);\n}\n\nvoid Graphics::VertexLayout::Set(const Buffer& indexBuffer, const BufferType& indexType) {\n mHasIndexBuffer = true;\n mIndexBufferType = indexType;\n wasmGraphics_VertexLayoutSetIndexBuffer(mId, indexBuffer.mId);\n}\n\nvoid Graphics::VertexLayout::Reset() {\n mHasIndexBuffer = false;\n mId = wasmGraphics_ResetVertexLayout(mId);\n}\n\n// Shader\n\nGraphics::Index Graphics::Shader::GetAttribute(const char* name) {\n u32 wasmLen = 0;\n for (const char* i = name; name != 0 && *i != '\\0'; ++i, ++wasmLen);\n\n int location = wasmGraphics_ShaderGetAttribute(mProgram, name, wasmLen);\n Index result;\n result.id = 0;\n result.valid = false;\n\n if (location >= 0) {\n  result.id = location;\n  result.valid = true;\n }\n\n return result;\n}\n\nGraphics::Index Graphics::Shader::GetUniform(const char* name) {\n u32 wasmLen = 0;\n for (const char* i = name; name != 0 && *i != '\\0'; ++i, ++wasmLen);\n\n int location = wasmGraphics_ShaderGetUniform(mProgram, name, wasmLen);\n\n Index result;\n result.id = 0;\n result.valid = false;\n\n if (location >= 0) {\n  result.id = location;\n  result.valid = true;\n }\n\n return result;\n}\n\n\n/// Buffer\n\nvoid Graphics::Buffer::Set(void* inputArray, u32 arraySizeInBytes, bool _static) {\n wasmGraphics_BufferSet(mIndexBuffer, mId, arraySizeInBytes, inputArray, _static);\n}\n\nvoid Graphics::Buffer::Reset() {\n mId = wasmGraphics_BufferReset(mId);\n}\n\nu32 Graphics::FrameBuffer::TargetCount() {\n u32 count = 0;\n for (u32 i = 0; i < 6; ++i) {\n  if (mColor[i] != 0) {\n   count += 1;\n  }\n }\n return count;\n}\n\nu32 Graphics::FrameBuffer::GetWidth() {\n for (u32 i = 0; i < 6; ++i) {\n  if (mColor[i] != 0) {\n   return mColor[i]->GetWidth();\n  }\n }\n if (mDepth != 0) {\n  return mDepth->GetWidth();\n }\n return 0;\n}\n\nu32 Graphics::FrameBuffer::GetHeight() {\n for (u32 i = 0; i < 6; ++i) {\n  if (mColor[i] != 0) {\n   return mColor[i]->GetHeight();\n  }\n }\n if (mDepth != 0) {\n  return mDepth->GetHeight();\n }\n return 0;\n}\n\n/// Frame Buffer\nvoid Graphics::FrameBuffer::AttachColor(Texture& color, u32 attachmentIndex) {\n if (attachmentIndex > 5) { // Limit to 6 color attachments\n  attachmentIndex = 5;\n }\n\n GLenum attachTarget = 0x0DE1;\n if (color.mIsCubeMap) {\n  attachTarget = 0x8513;\n }\n\n color.mCachedMin = 0x2601;\n color.mCachedMag = 0x2601;\n\n mColor[attachmentIndex] = &color;\n mOwner->mBoundFrameBuffer = 0;\n wasmGraphics_FramebufferAttachColor(attachTarget, mId, color.mId, attachmentIndex);\n}\n\nvoid Graphics::FrameBuffer::AttachDepth(Texture& depth, bool pcm) {\n GLenum attachTarget = 0x0DE1;\n if (depth.mIsCubeMap) {\n  attachTarget = 0x8513;\n }\n\n depth.mCachedMin = 0x2601;\n depth.mCachedMag = 0x2601;\n\n mDepth = &depth;\n mOwner->mBoundFrameBuffer = 0;\n\n wasmGraphics_FrameBufferAttachDepth(attachTarget, mId, depth.mId, pcm);\n}\n\nbool Graphics::FrameBuffer::IsValid() {\n mOwner->mBoundFrameBuffer = 0;\n return wasmGraphics_FrameBufferIsValid(mId);\n}\n\nvoid Graphics::FrameBuffer::ResolveTo(FrameBuffer* target, Filter filter, bool color, bool depth, u32 x0, u32 y0, u32 x1, u32 y1, u32 x2, u32 y2, u32 x3, u32 y3) {\n u32 targetId = 0;\n u32 targetHasColor = true;\n u32 targetHasDepth = true;\n if (target != 0) {\n  targetId = target->mId;\n  targetHasColor = target->TargetCount() != 0;\n  targetHasDepth = target->mDepth != 0;\n }\n\n bool hasColor = TargetCount() != 0;\n bool hasDepth = mDepth != 0;\n\n bool colorBit = false;\n bool depthBit = false;\n if (hasColor && targetHasColor && color) {\n  colorBit = true;\n }\n if (hasDepth && targetHasDepth && depth) {\n  depthBit = true;\n }\n\n GLenum gl_filter = 0x2600;\n if (filter == Filter::Linear) {\n  gl_filter = 0x2601;\n }\n\n mOwner->mBoundFrameBuffer = 0;\n wasmGraphics_FrameBufferResolveTo(mId, targetId, x0, y0, x1, y1, x2, y2, x3, y3, colorBit, depthBit, gl_filter);\n}\n\nvoid Graphics::FrameBuffer::ResolveTo(FrameBuffer* target, Filter filter, bool color, bool depth) {\n u32 width = GetWidth();\n u32 height = GetHeight();\n\n Graphics::Internal::Assert(GetWidth() == target->GetWidth(), \"On line: \" \"1333\" \", in file: \" \"./GraphicsWASM.cpp\", \"Invalid resolve\");\n Graphics::Internal::Assert(GetHeight() == target->GetHeight(), \"On line: \" \"1334\" \", in file: \" \"./GraphicsWASM.cpp\", \"Invalid resolve\");\n\n ResolveTo(target, filter, color, depth, 0, 0, width, height, 0, 0, width, height);\n}\n\nvoid Graphics::FrameBuffer::Resize(u32 width, u32 height) {\n for (u32 i = 0; i < 6; ++i) {\n  if (mColor[i] != 0) {\n   mColor[i]->Set(width, height);\n  }\n }\n mDepth->Set(width, height);\n}\n\n\n\n\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void wasmGraphics_Assert(bool cond, const char* loc, const char* msg) {\n Graphics::Internal::Assert(cond, loc, msg);\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" Graphics::Device* wasm_Graphics_Initialize(Graphics::fpRequest allocPtr, Graphics::fpRelease releasePtr) {\n Graphics::Dependencies platform;\n platform.Request = allocPtr;\n platform.Release = releasePtr;\n Graphics::Device* device = (Graphics::Device*)allocPtr(sizeof(Graphics::Device));\n return Graphics::Initialize(*device, platform);\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void wasm_Graphics_Shutdown(Graphics::Device* device) {\n Graphics::Shutdown(*device);\n}\n\n\n/*\nGame Memory Allocator:\n\n\tGame Allocator is a generic memory manager intended for games, embedded devices, and web assembly.\n\tGiven a large array of memory, the library provides functions to allocate and release that memory similar to malloc / free.\n\tThe memory will be broken up into pages (4 KiB by default) and tracked at the page granularity. \n\tA sub-allocator provided which breaks the page up into a fast free list for smaller allocation.\n\nUsage:\n\n\tLet's assume you have a void* to some large area of memory and know how many bytes large that area is.\n\n\tCall the Memory::Initialize function to create an allocator. The first two arguments are the memory and size, \n\tthe third argument is the page size with which the memory should be managed. The default page size is 4 KiB\n\n\tThe memory being passed it should be 8 byte aligned, and the size of the memory should be a multiple of pageSize.\n\tThe Memory::AlignAndTrim helper function will align a region of memory so it's ready for initialize.\n\tIt modifies the memory and size variables that are passed to the function. AlignAndTrim returns the number of bytes lost.\n\n\tAllocate memory with the allocator objects Allocate function, and release memory with the its Release function. \n\tAllocate takes an optional alignment, which by default is 0. Only unaligned allocations utilize a fast free list allocator.\n\tBoth functions also take a const char* which is optionally the location of the allocation.\n\n\tNew and delete functions are also provided, these will invoke the constructor / destructor of the class they are\n\tbeing invoked on. New will forward up to three arguments and takes an optional location pointer.\n\n\tWhen you are finished with an allocator, clean it up by calling Memory::Shutdown. The shutdown function \n\twill assert in debug builds if there are any memory leaks.\n\nExample:\n\n\tvoid run() {\n\t\t// Declare how much memory to use\n\t\t// Adding (DefaultPageSize - 1) to size ensures that there is enough space for padding\n\t\tunsigned int size = MB(512) + (DefaultPageSize - 1); \n\n\t\t// Allocate memory from the operating system\n\t\tLPVOID memory = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); // Windows\n\n\t\t// Initialize the global allocator\n\t\tu32 lost = Memory::AlignAndTrim(&m, &size, Memory::DefaultPageSize);\n\t\tMemory::Allocator* allocator = Memory::Initialize(m, size, Memory::DefaultPageSize);\n\n\t\t// Allocate & release memory\n\t\tint* number = allocator->Allocate(sizeof(int)); // Only the number of bytes is required\n\t\tallocator->Release(number); // Only the void* is required\n\n\t\t// New and delete can also be used:\n\t\tSomeClass* obj = allocator->New<SomeClass>(\"arguments\");\n\t\tallocator->Delete(obj);\n\n\t\t// Cleanup the global allocator\n\t\tMemory::Shutdown(Memory::GlobalAllocator);\n\t\tMemory::GlobalAllocator = 0;\n\n\t\t// Release memory back to operating system\n\t\tVirtualFree(memory, 0, MEM_RELEASE);\n\t}\n\nCompile flags:\n\n\tMEM_FIRST_FIT         -> This affects how fast memory is allocated. If it's set then every allocation\n\t                         searches for the first available page from the start of the memory. If it's not\n\t\t\t\t\t         set, then an allocation header is maintained. It's advanced with each allocation,\n\t\t\t\t\t         and new allocations search for memory from the allocation header.\n\tMEM_CLEAR_ON_ALLOC    -> When set, memory will be cleared to 0 before being returned from Memory::Allocate\n\t                         If both clear and debug on alloc are set, clear will take precedence\n\tMEM_DEBUG_ON_ALLOC    -> If set, full page allocations will fill the padding of the page with \"-MEMORY\"\n\tMEM_USE_SUBALLOCATORS -> If set, small allocations will be made using a free list allocaotr. There are free list\n\t                         allocators for 64, 128, 256, 512, 1024 and 2049 byte allocations. Only allocations that\n\t\t\t\t\t\t\t don't specify an alignment can use the fast free list allocator. The sub-allocator will\n\t\t\t\t\t\t\t provide better page utilization, for example a 4096 KiB page can hold 32 128 bit allocations.\n\tMEM_TRACK_LOCATION    -> If set, a const char* will be added to Memory::Allocation which tracks the __LINE__ and __FILE__\n\t                         of each allocation. Setting this bit will add 8 bytes to the Memory::Allocation struct.\n\nDebugging:\n\n\tThere are a few debug functions exposed in the Memory::Debug namespace. When an allocator is initialized, the page\n\timmediateley before the first allocatable page is reserved as a debug page. You can fill this page with whatever \n\tdata is needed. Any function in Memory::Debug might overwrite the contents of the debug page. You can get a pointer\n\tto the debug page of an allocator with the RequestDbgPage function. Be sure to release the page after you are dont\n\tusing it by calling ReleaseDbgPage();\n\n\tThe Memory::Debug::MemInfo function can be used to retrieve information about the state of the memory allocator.\n\tIt provides meta data like how many pages are in use, a list of active allocations, and a visual bitmap chart to\n\tmake debugging the memory bitmask easy. You can write this information to a file like so:\n\n\tDeleteFile(L\"MemInfo.txt\");\n\tHANDLE hFile = CreateFile(L\"MemInfo.txt\", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);\n\tMemory::Debug::MemInfo(Memory::GlobalAllocator, [](const u8* mem, u32 size, void* fileHandle) {\n\t\tHANDLE file = *(HANDLE*)fileHandle;\n\t\tDWORD bytesWritten;\n\t\tWriteFile(file, mem, size, &bytesWritten, nullptr);\n\t}, &hFile);\n\tCloseHandle(hFile);\n\t\n\tThere is a similar Memory::Debug::PageContent, which given a page number will dump the binary conent of a page.\n\nResources:\n\n\tCompile without CRT \n\t\thttps://yal.cc/cpp-a-very-tiny-dll/\n\n\tReady Set Allocate:\n\t\thttps://web.archive.org/web/20120419125628/http://www.altdevblogaday.com/2011/04/11/ready-set-allocate-part-1/\n\t\thttps://web.archive.org/web/20120419125404/http://www.altdevblogaday.com/2011/04/26/ready-set-allocate-part-2/\n\t\thttps://web.archive.org/web/20120419010208/http://www.altdevblogaday.com/2011/05/15/ready-set-allocate-part-3/\n\t\thttps://web.archive.org/web/20120418212016/http://www.altdevblogaday.com/2011/05/26/ready-set-allocate-part-4/\n\t\thttps://web.archive.org/web/20120413201435/http://www.altdevblogaday.com/2011/06/08/ready-set-allocate-part-5/\n\t\thttps://web.archive.org/web/20120321205231/http://www.altdevblogaday.com/2011/06/30/ready-set-allocate-part-6/\n\n\tHow to combine __LINE__ and __FILE__ into a c string:\n\t\thttps://stackoverflow.com/questions/2653214/stringification-of-a-macro-value\n\n\tC++ overload new, new[], delete, and delete[]\n\t\thttps://cplusplus.com/reference/new/operator%20new/\n\t\thttps://cplusplus.com/reference/new/operator%20delete/\n\t\thttps://cplusplus.com/reference/new/operator%20new[]/\n\t\thttps://cplusplus.com/reference/new/operator%20delete[]/\n\n\tMemory alignment discussion:\n\t\thttps://stackoverflow.com/questions/227897/how-to-allocate-aligned-memory-only-using-the-standard-library\n\n\tScott Schurr's const string\n\t\thttps://www.youtube.com/watch?v=BUnNA2dLRsU\n*/\n\n#pragma warning(disable:28251)\n\n// When allocating new memory, if MEM_FIRST_FIT is defined and set to 1 every allocation will scan\n// the available memory from the first bit to the last bit looking for enough space to satisfy the\n// allocation. If MEM_FIRST_FIT is set to 0, then the memory is searched iterativley. Ie, when we \n// allocate the position in memory after the allocation is saved, and the next allocation starts\n// searching from there.\n\n\n// If set to 1, the allocator will clear or fill memory when allocating it\n\n\n\n// Disables sub-allocators if defined\n\n\n// If true, adds char* to each allocation\n\n\n\n\n typedef unsigned char u8;\n static_assert (sizeof(u8) == 1, \"u8 should be defined as a 1 byte type\");\n typedef unsigned long long u64;\n static_assert (sizeof(u64) == 8, \"u64 should be defined as an 8 byte type\");\n\n\n\n\n typedef long long i64;\n static_assert (sizeof(i64) == 8, \"i64 should be defined as an 8 byte type\");\n // _WASM32\n\n\n\n\n\n namespace Memory {\n  typedef unsigned long ptr_type;\n  typedef long diff_type;\n  static_assert (sizeof(ptr_type) == 4, \"ptr_type should be defined as a 4 byte type on a 32 bit system\");\n  static_assert (sizeof(diff_type) == 4, \"diff_type should be defined as a 4 byte type on a 32 bit system\");\n }\n\n\n\n\ninline void* operator new (Memory::ptr_type n, void* ptr) {\n return ptr;\n};\n\nnamespace Memory {\n // The callback allocator can be used to register a callback with each allocator. It's the same callback signature for both Allocate and Release\n typedef void (*Callback)(struct Allocator* allocator, void* allocationHeaderAddress, u32 bytesRequested, u32 bytesServed, u32 firstPage, u32 numPages);\n\n // Allocation struct uses a 32 bit offset instead of a pointer. This makes the maximum amount of memory GameAllocator can manage be 4 GiB\n typedef u32 Offset32;\n\n struct Allocation {\n\n  const char* location;\n\n  u32 padding_32bit; // Keep sizeof(Allocation) consistent between x64 & x86\n\n\n  Offset32 prevOffset; // Offsets are the number of bytes from allocator\n  Offset32 nextOffset;\n  u32 size; // Unpadded allocation size, ie what you pass to malloc\n  u32 alignment;\n };\n\n // Unlike Allocation, Allocator uses pointers. There is only ever one allocator\n // and saving a few bytes here isn't that important. Similarly, the free list\n // pointers exist even if MEM_USE_SUBALLOCATORS is off. This is done to keep the\n // size of this struct consistent for debugging.\n struct Allocator {\n  Callback allocateCallback; // Callback for malloc / new\n  Callback releaseCallback; // Callback for free / delete\n\n  Allocation* free_64; // The max size for each of these lists is whatever the number after the\n  Allocation* free_128; // underscore is, minus the size of the Allocation structure, which is \n  Allocation* free_256; // either 16 or 24 bytes (depenging if the location is tracked or not).\n  Allocation* free_512; // For exampe, the largest allocation the 64 byte free list can hold is 50 bytes\n  Allocation* free_1024; // There isn't much significance to these numbers, tune them to better match your structs\n  Allocation* free_2048; // Only unaligned allocations (alignment of 0) can utilize the sub allocators.\n\n  Allocation* active; // Memory that has been allocated, but not released\n\n  u32 size; // In bytes, how much total memory is the allocator managing\n  u32 requested; // How many bytes where requested (raw)\n  u32 pageSize; // Default is 4096, but each allocator can have a unique size\n  u32 scanBit; // Only used if MEM_FIRST_FIT is off\n\n  u32 numPagesUsed;\n  u32 peekPagesUsed; // Use this to monitor how much memory your application actually needs\n  u32 mask;\n  u32 mask_padding;\n\n\n  u32 padding_32bit[9]; // Padding to make sure the struct stays the same size in x64 / x86 builds\n\n\n  void* Allocate(u32 bytes, u32 alignemnt = 0, const char* location = 0);\n  void Release(void* t, const char* location = 0);\n\n  u8* RequestDbgPage();\n  void ReleaseDbgPage();\n\n  template<class T, typename A1>\n  inline T* New(A1&& a1, const char* location = 0) {\n   const u32 bytes = sizeof(T);\n   const u32 alignment = 0;\n   void* memory = this->Allocate(bytes, alignment, location);\n   T* object = ::new (memory) T(a1);\n   return object;\n  }\n\n  template<class T, typename A1, typename A2>\n  inline T* New(A1&& a1, A2&& a2, const char* location = 0) {\n   const u32 bytes = sizeof(T);\n   const u32 alignment = 0;\n   void* memory = this->Allocate(bytes, alignment, location);\n   T* object = ::new (memory) T(a1, a2);\n   return object;\n  }\n\n  template<class T, typename A1, typename A2, typename A3>\n  inline T* New(A1&& a1, A2&& a2, A3&& a3, const char* location = 0) {\n   const u32 bytes = sizeof(T);\n   const u32 alignment = 0;\n   void* memory = this->Allocate(bytes, alignment, location);\n   T* object = ::new (memory) T(a1, a2, a3);\n   return object;\n  }\n\n  template<class T>\n  inline T* New(const char* location = 0) {\n   const u32 bytes = sizeof(T);\n   const u32 alignment = 0;\n   void* memory = this->Allocate(bytes, alignment, location);\n   T* object = ::new (memory) T();\n   return object;\n  }\n\n  template<class T>\n  inline void Delete(T* ptr, const char* location = 0) {\n   T* obj = (T*)ptr;\n   obj->T::~T();\n   this->Release(ptr, location);\n  }\n };\n\n // 4 KiB is a good default page size. Most of your small allocations will go trough the sub-allocators\n // so this page size is mostly important for larger allocations. Feel free to change to something more\n // appropriate if needed.\n const u32 DefaultPageSize = 4096;\n\n // Don't change tracking unit size. The bitmask that tracks which pages are free is stored as an\n // array of 32 bit integers. Changing this number would require changing how mem.cpp is implemented\n const u32 TrackingUnitSize = 32;\n // Don't change allocator alignment. Every allocator should start at an 8 byte aligned memory address.\n // Internally the allocator uses offsets to access some data, the start alignment is important.\n const u32 AllocatorAlignment = 8; // Should stay 8, even on 32 bit platforms\n\n // Call AlignAndTrim before Initialize to make sure that memory is aligned to alignment\n // and to make sure that the size of the memory (after it's been aligned) is a multiple of pageSize\n // both arguments are modified, the return value is how many bytes where removed\n u32 AlignAndTrim(void** memory, u32* size, u32 alignment = AllocatorAlignment, u32 pageSize = DefaultPageSize);\n\n // The initialize function will place the Allocator struct at the start of the provided memory. \n // The allocaotr struct is followed by a bitmask, in which each bit tracks if a page is in use or not.\n // The bitmask is a bit u32 array. If the end of the bitmask is in the middle of a page, the rest of that\n // page is lost as padding. The next page is a debug page that you can use for anything, only functions in\n // the Memory::Debug namespace mess with the debug page, anything in Memory:: doesn't touch it.\n // The allocator that's returned should be used to set the global allocator.\n Allocator* Initialize(void* memory, u32 bytes, u32 pageSize = DefaultPageSize);\n\n // After you are finished with an allocator, shut it down. The shutdown function will assert in a debug build\n // if you have any memory that was allocated but not released. This function doesn't do much, it exists\n // to provide a bunch of asserts that ensure that an application is shutting down cleanly.\n void Shutdown(Allocator* allocator);\n\n // Memset and Memcpy utility functions. One big difference is that this set function only takes a u8.\n // both of these functions work on larger data types, then work their way down. IE: they try to set or\n // copy the memory using u64's, then u32's, then u16's, and finally u8's\n void* Set(void* memory, u8 value, u32 size, const char* location = 0);\n void Copy(void* dest, const void* source, u32 size, const char* location = 0);\n\n // The debug namespace let's you access information about the current state of the allocator,\n // gives you access to the contents of a page for debugging, and contains a debug page that\n // you can use for whatever. Be careful tough, MemInfo and PageContent might write to the\n // debug page, invalidating what was previously in there.\n namespace Debug {\n  typedef void (*WriteCallback)(const u8* mem, u32 size, void* userdata);\n\n  void MemInfo(Allocator* allocator, WriteCallback callback, void* userdata = 0);\n  void PageContent(Allocator* allocator, u32 page, WriteCallback callback, void* userdata = 0);\n }\n}\n\n\n\n// Some compile time asserts to make sure that all our memory is sized correctly and aligns well\nstatic_assert (sizeof(Memory::Allocator) % 8 == 0, \"Memory::Allocator size needs to be 8 byte alignable for the allocation mask to start on u64 alignment without any padding\");\nstatic_assert (Memory::TrackingUnitSize% Memory::AllocatorAlignment == 0, \"Memory::MaskTrackerSize must be a multiple of 8 (bits / byte)\");\nstatic_assert (sizeof(Memory::Allocator) == 96 + 8, \"Memory::Allocator is not the expected size\");\n\n static_assert (sizeof(Memory::Allocation) == 24, \"Memory::Allocation should be 24 bytes (192 bits)\");\n\n\n\n\n// Use the __LOCATION__ macro to pack both __LINE__ and __FILE__ into a c string\n\n\n\n\n// Make sure hte platform is set\n\n\n\n\n\n\n#pragma warning(default:28251)\n\n#pragma warning(disable:6011)\n#pragma warning(disable:28182)\n\n\n\n typedef unsigned short u16;\n static_assert (sizeof(u16) == 2, \"u16 should be defined as a 2 byte type\");\nnamespace Memory {\n Allocator* wasmGlobalAllocator = 0;\n}\n\n\nextern \"C\" void* __cdecl memset(void* _mem, i32 _value, Memory::ptr_type _size) {\n return Memory::Set(_mem, (u8)_value, (u32)_size, \"internal - memset\");\n}\nextern \"C\" void wasmGraphics_Log(const char* loc, int locLen, const char* msg, int msgLen);\n\nnamespace Memory {\n namespace Debug {\n  u32 u32toa(u8* dest, u32 destSize, u32 num);\n }\n static void Assert(bool condition, const char* msg, u32 line, const char* file) {\n\n  if (condition == false) {\n            u32 msg_len = 0;\n            for (const char* i = msg; msg != 0 && *i != '\\0'; ++i, ++msg_len);\n   u32 loc_len = 0;\n            for (const char* i = file; file != 0 && *i != '\\0'; ++i, ++loc_len);\n            wasmGraphics_Log(file, loc_len, msg, msg_len);\n            __builtin_trap();\n  }\n\n\n\n\n\n\n }\n\n static inline u32 AllocatorPaddedSize() {\n  static_assert (sizeof(Memory::Allocator) % AllocatorAlignment == 0, \"Memory::Allocator size needs to be 8 byte aligned for the allocation mask to start on this alignment without any padding\");\n  return sizeof(Allocator);\n }\n\n static inline u8* AllocatorPageMask(Allocator* allocator) {\n  static_assert (sizeof(Memory::Allocator) % AllocatorAlignment == 0, \"Memory::Allocator size needs to be 8 byte aligned for the allocation mask to start on this alignment without any padding\");\n  return ((u8*)allocator) + sizeof(Allocator);\n }\n\n static inline u32 AllocatorPageMaskSize(Allocator* allocator) { // This is the number of u8's that make up the AllocatorPageMask array\n  const u32 allocatorNumberOfPages = allocator->size / allocator->pageSize; // 1 page = (probably) 4096 bytes, how many are needed\n  Memory::Assert(allocator->size % allocator->pageSize == 0, \"Allocator size should line up with page size\", 62, \"./mem.cpp\");\n  // allocatorNumberOfPages is the number of bits that are required to track memory\n\n  // Pad out to sizeof(32) (if MaskTrackerSize is 32). This is because AllocatorPageMask will often be used as a u32 array\n  // and we want to make sure that enough space is reserved.\n  const u32 allocatorPageArraySize = allocatorNumberOfPages / TrackingUnitSize + (allocatorNumberOfPages % TrackingUnitSize ? 1 : 0);\n  return allocatorPageArraySize * (TrackingUnitSize / 8); // In bytes, not bits\n }\n\n static inline void RemoveFromList(Allocator* allocator, Allocation** list, Allocation* allocation) {\n  u32 allocationOffset = (u32)((u8*)allocation - (u8*)allocator);\n  u32 listOffset = (u32)((u8*)(*list) - (u8*)allocator);\n\n  Allocation* head = *list;\n\n  if (head == allocation) { // Removing head\n   if (head->nextOffset != 0) { // There is a next\n    Allocation* allocNext = 0;\n    if (allocation->nextOffset != 0) {\n     allocNext = (Allocation*)((u8*)allocator + allocation->nextOffset);\n    }\n    Allocation* headerNext = 0;\n    if (head->nextOffset != 0) {\n     headerNext = (Allocation*)((u8*)allocator + head->nextOffset);\n    }\n    Memory::Assert(allocNext == headerNext, \"On line: \" \"87\" \", in file: \" \"./mem.cpp\", 87, \"./mem.cpp\");\n    Memory::Assert(headerNext->prevOffset == allocationOffset, \"On line: \" \"88\" \", in file: \" \"./mem.cpp\", 88, \"./mem.cpp\");\n    headerNext->prevOffset = 0;\n   }\n   Allocation* next = 0;\n   if (head != 0 && head->nextOffset != 0) {\n    next = (Allocation*)((u8*)allocator + head->nextOffset);\n   }\n   *list = next;\n  }\n  else {\n   if (allocation->nextOffset != 0) {\n    Allocation* _next = (Allocation*)((u8*)allocator + allocation->nextOffset);\n    Memory::Assert(_next->prevOffset == allocationOffset, \"On line: \" \"100\" \", in file: \" \"./mem.cpp\", 100, \"./mem.cpp\");\n    _next->prevOffset = allocation->prevOffset;\n   }\n   if (allocation->prevOffset != 0) {\n    Allocation* _prev = (Allocation*)((u8*)allocator + allocation->prevOffset);\n    Memory::Assert(_prev->nextOffset == allocationOffset, \"On line: \" \"105\" \", in file: \" \"./mem.cpp\", 105, \"./mem.cpp\");\n    _prev->nextOffset = allocation->nextOffset;\n   }\n  }\n\n  allocation->prevOffset = 0;\n  allocation->nextOffset = 0;\n }\n\n static inline void AddtoList(Allocator* allocator, Allocation** list, Allocation* allocation) {\n  u32 allocationOffset = (u32)((u8*)allocation - (u8*)allocator);\n  u32 listOffset = (u32)((u8*)(*list) - (u8*)allocator);\n  Allocation* head = *list;\n\n  allocation->prevOffset = 0;\n  allocation->nextOffset = 0;\n  if (head != 0) {\n   allocation->nextOffset = listOffset;\n   head->prevOffset = allocationOffset;\n  }\n  *list = allocation;\n }\n\n // Returns 0 on error. Since the first page is always tracking overhead it's invalid for a range\n static inline u32 FindRange(Allocator* allocator, u32 numPages, u32 searchStartBit) {\n  Memory::Assert(allocator != 0, \"On line: \" \"130\" \", in file: \" \"./mem.cpp\", 130, \"./mem.cpp\");\n  Memory::Assert(numPages != 0, \"On line: \" \"131\" \", in file: \" \"./mem.cpp\", 131, \"./mem.cpp\");\n\n  u32 * mask = (u32*)AllocatorPageMask(allocator);\n  u32 numBitsInMask = AllocatorPageMaskSize(allocator) * 8;\n  u32 numElementsInMask = AllocatorPageMaskSize(allocator) / (TrackingUnitSize / 8);\n  Memory::Assert(allocator->size % allocator->pageSize == 0, \"Memory::FindRange, the allocators size must be a multiple of Memory::PageSize, otherwise there would be a partial page at the end\", 136, \"./mem.cpp\");\n  Memory::Assert(mask != 0, \"On line: \" \"137\" \", in file: \" \"./mem.cpp\", 137, \"./mem.cpp\");\n  Memory::Assert(numBitsInMask != 0, \"On line: \" \"138\" \", in file: \" \"./mem.cpp\", 138, \"./mem.cpp\");\n\n  u32 startBit = 0;\n  u32 numBits = 0;\n\n  for (u32 i = searchStartBit; i < numBitsInMask; ++i) {\n   u32 m = i / TrackingUnitSize;\n   u32 b = i % TrackingUnitSize;\n\n   Memory::Assert(m < numElementsInMask, \"indexing mask out of range\", 147, \"./mem.cpp\");\n   bool set = mask[m] & (1 << b);\n\n   if (!set) {\n    if (startBit == 0) {\n     startBit = i;\n     numBits = 1;\n    }\n    else {\n     numBits++;\n    }\n   }\n   else {\n    startBit = 0;\n    numBits = 0;\n   }\n\n   if (numBits == numPages) {\n    break;\n   }\n  }\n\n  if (numBits != numPages || startBit == 0) {\n   startBit = 0;\n   numBits = 0;\n\n   for (u32 i = 0; i < searchStartBit; ++i) {\n    u32 m = i / TrackingUnitSize;\n    u32 b = i % TrackingUnitSize;\n\n    bool set = mask[m] & (1 << b);\n\n    if (!set) {\n     if (startBit == 0) {\n      startBit = i;\n      numBits = 1;\n     }\n     else {\n      numBits++;\n     }\n    }\n    else {\n     startBit = 0;\n     numBits = 0;\n    }\n\n    if (numBits == numPages) {\n     break;\n    }\n   }\n  }\n\n  allocator->scanBit = startBit + numPages;\n\n  Memory::Assert(numBits == numPages, \"Memory::FindRange Could not find enough memory to fufill request\", 201, \"./mem.cpp\");\n  Memory::Assert(startBit != 0, \"Memory::FindRange Could not memory fufill request\", 202, \"./mem.cpp\");\n  if (numBits != numPages || startBit == 0 || allocator->size % allocator->pageSize != 0) {\n   Memory::Assert(false, \"On line: \" \"204\" \", in file: \" \"./mem.cpp\", 204, \"./mem.cpp\");\n   return 0;\n  }\n\n  return startBit;\n }\n\n static inline void SetRange(Allocator* allocator, u32 startBit, u32 bitCount) {\n  Memory::Assert(allocator != 0, \"On line: \" \"212\" \", in file: \" \"./mem.cpp\", 212, \"./mem.cpp\");\n  Memory::Assert(bitCount != 0, \"On line: \" \"213\" \", in file: \" \"./mem.cpp\", 213, \"./mem.cpp\");\n\n  u32* mask = (u32*)AllocatorPageMask(allocator);\n  Memory::Assert(allocator->size % allocator->pageSize == 0, \"Memory::FindRange, the allocators size must be a multiple of Memory::PageSize, otherwise there would be a partial page at the end\", 216, \"./mem.cpp\");\n  Memory::Assert(mask != 0, \"On line: \" \"217\" \", in file: \" \"./mem.cpp\", 217, \"./mem.cpp\");\n\n\n  u32 numBitsInMask = AllocatorPageMaskSize(allocator) * 8;\n  Memory::Assert(numBitsInMask != 0, \"On line: \" \"221\" \", in file: \" \"./mem.cpp\", 221, \"./mem.cpp\");\n\n  u32 numElementsInMask = AllocatorPageMaskSize(allocator) / (TrackingUnitSize / 8);\n\n  for (u32 i = startBit; i < startBit + bitCount; ++i) {\n\n   u32 m = i / TrackingUnitSize;\n   u32 b = i % TrackingUnitSize;\n\n   Memory::Assert(m < numElementsInMask, \"indexing mask out of range\", 230, \"./mem.cpp\");\n\n   Memory::Assert(i < numBitsInMask, \"On line: \" \"232\" \", in file: \" \"./mem.cpp\", 232, \"./mem.cpp\");\n   bool set = mask[m] & (1 << b);\n   Memory::Assert(!set, \"On line: \" \"234\" \", in file: \" \"./mem.cpp\", 234, \"./mem.cpp\");\n\n\n   mask[m] |= (1 << b);\n  }\n\n  Memory::Assert(allocator->numPagesUsed <= numBitsInMask, \"Memory::FindRange, over allocating\", 240, \"./mem.cpp\");\n  Memory::Assert(allocator->numPagesUsed + bitCount <= numBitsInMask, \"Memory::FindRange, over allocating\", 241, \"./mem.cpp\");\n  allocator->numPagesUsed += bitCount;\n  if (allocator->numPagesUsed > allocator->peekPagesUsed) {\n   allocator->peekPagesUsed = allocator->numPagesUsed;\n  }\n }\n\n static inline void ClearRange(Allocator* allocator, u32 startBit, u32 bitCount) {\n  Memory::Assert(allocator != 0, \"On line: \" \"249\" \", in file: \" \"./mem.cpp\", 249, \"./mem.cpp\");\n  Memory::Assert(bitCount != 0, \"On line: \" \"250\" \", in file: \" \"./mem.cpp\", 250, \"./mem.cpp\");\n\n  u32* mask = (u32*)AllocatorPageMask(allocator);\n  Memory::Assert(allocator->size % allocator->pageSize == 0, \"Memory::FindRange, the allocators size must be a multiple of Memory::PageSize, otherwise there would be a partial page at the end\", 253, \"./mem.cpp\");\n  Memory::Assert(mask != 0, \"On line: \" \"254\" \", in file: \" \"./mem.cpp\", 254, \"./mem.cpp\");\n\n\n  u32 numBitsInMask = AllocatorPageMaskSize(allocator) * 8;\n  Memory::Assert(numBitsInMask != 0, \"On line: \" \"258\" \", in file: \" \"./mem.cpp\", 258, \"./mem.cpp\");\n\n\n  u32 numElementsInMask = AllocatorPageMaskSize(allocator) / (TrackingUnitSize / 8);\n\n  for (u32 i = startBit; i < startBit + bitCount; ++i) {\n\n   u32 m = i / TrackingUnitSize;\n   u32 b = i % TrackingUnitSize;\n\n   Memory::Assert(m < numElementsInMask, \"indexing mask out of range\", 268, \"./mem.cpp\");\n\n\n   Memory::Assert(i < numBitsInMask, \"On line: \" \"271\" \", in file: \" \"./mem.cpp\", 271, \"./mem.cpp\");\n   bool set = mask[m] & (1 << b);\n   Memory::Assert(set, \"On line: \" \"273\" \", in file: \" \"./mem.cpp\", 273, \"./mem.cpp\");\n\n\n   mask[m] &= ~(1 << b);\n  }\n\n  Memory::Assert(allocator->numPagesUsed != 0, \"On line: \" \"279\" \", in file: \" \"./mem.cpp\", 279, \"./mem.cpp\");\n  Memory::Assert(allocator->numPagesUsed >= bitCount != 0, \"underflow\", 280, \"./mem.cpp\");\n  allocator->numPagesUsed -= bitCount;\n }\n\n\n // This function will chop the provided page into several blocks. Since the block size is constant, we\n // know that headers will be laid out at a stride of blockSize. There is no additional tracking needed.\n void* SubAllocate(u32 requestedBytes, u32 blockSize, Allocation** freeList, const char* location, Allocator* allocator) {\n  Memory::Assert(blockSize < allocator->pageSize, \"Block size must be less than page size\", 288, \"./mem.cpp\");\n\n  // There is no blocks of the requested size available. Reserve 1 page, and carve it up into blocks.\n  bool grabNewPage = *freeList == 0;\n  if (*freeList == 0) {\n   // Find and reserve 1 free page\n\n   const u32 page = FindRange(allocator, 1, 0);\n\n\n\n   SetRange(allocator, page, 1);\n\n   // Zero out the pages memory\n   u8* mem = (u8*)allocator + allocator->pageSize * page;\n   Set(mem, 0, allocator->pageSize, \"On line: \" \"303\" \", in file: \" \"./mem.cpp\");\n\n   // Figure out how many blocks fit into this page\n   const u32 numBlocks = allocator->pageSize / blockSize;\n   Memory::Assert(numBlocks > 0, \"On line: \" \"307\" \", in file: \" \"./mem.cpp\", 307, \"./mem.cpp\");\n   Memory::Assert(numBlocks < 128, \"On line: \" \"308\" \", in file: \" \"./mem.cpp\", 308, \"./mem.cpp\");\n\n   // For each block in this page, initialize it's header and add it to the free list\n   for (u32 i = 0; i < numBlocks; ++i) {\n    Allocation* alloc = (Allocation*)mem;\n    mem += blockSize;\n\n    // Initialize the allocation header\n    alloc->prevOffset = 0;\n    alloc->nextOffset = 0;\n    alloc->size = 0;\n    alloc->alignment = 0;\n\n    alloc->location = location;\n\n\n    AddtoList(allocator, freeList, alloc);\n   }\n  }\n  Memory::Assert(*freeList != 0, \"The free list literally can't be zero here...\", 327, \"./mem.cpp\");\n\n  // At this point we know the free list has some number of blocks in it. \n  // Save a reference to the current header & advance the free list\n  // Advance the free list, we're going to be using this one.\n  Allocation* block = *freeList;\n  if ((*freeList)->nextOffset != 0) { // Advance one\n   Allocation* _next = (Allocation*)((u8*)allocator + (*freeList)->nextOffset);\n   _next->prevOffset = 0;\n   *freeList = (Allocation*)((u8*)allocator + (*freeList)->nextOffset); // freeList = freeList.next\n  }\n  else {\n   *freeList = 0;\n  }\n\n  block->prevOffset = 0;\n  block->size = requestedBytes;\n  block->alignment = 0;\n\n  block->location = location;\n\n\n  AddtoList(allocator, &allocator->active, block); // Sets block->next\n\n  if (allocator->allocateCallback != 0) {\n   u32 firstPage = ((u32)((u8*)block - (u8*)allocator)) / allocator->pageSize;\n   allocator->allocateCallback(allocator, block, requestedBytes, blockSize, firstPage, grabNewPage? 1 : 0);\n  }\n\n  // Memory always follows the header\n  return (u8*)block + sizeof(Allocation);\n }\n\n\n\n void SubRelease(void* memory, u32 blockSize, Allocation** freeList, const char* location, Allocator* allocator) {\n  // Find the allocation header and mark it as free. Early out on double free to avoid breaking.\n  Allocation* header = (Allocation*)((u8*)memory - sizeof(Allocation));\n  Memory::Assert(header->size != 0, \"Double Free!\", 377, \"./mem.cpp\"); // Make sure it's not a double free\n  if (header->size == 0) {\n   Memory::Assert(false, \"On line: \" \"379\" \", in file: \" \"./mem.cpp\", 379, \"./mem.cpp\");\n   return;\n  }\n  u32 oldSize = header->size;\n  header->size = 0;\n\n  // Now remove from the active list.\n  RemoveFromList(allocator, &allocator->active, header);\n  // Add memory back into the free list\n  AddtoList(allocator, freeList, header);\n\n  header->location = \"SubRelease released this block\";\n\n\n  // Find the first allocation inside the page\n  u32 startPage = (u32)((u8*)header - (u8*)allocator) / allocator->pageSize;\n\n  u8* mem =(u8*)allocator + startPage * allocator->pageSize;\n\n  // Each sub allocator page contains multiple blocks. check if all of the blocks \n  // belonging to a single page are free, if they are, release the page.\n  bool releasePage = true;\n\n  const u32 numAllocationsPerPage = allocator->pageSize / blockSize;\n  Memory::Assert(numAllocationsPerPage >= 1, \"On line: \" \"403\" \", in file: \" \"./mem.cpp\", 403, \"./mem.cpp\");\n  for (u32 i = 0; i < numAllocationsPerPage; ++i) {\n   Allocation* alloc = (Allocation*)mem;\n   if (alloc->size > 0) {\n    releasePage = false;\n    break;\n   }\n   mem += blockSize;\n  }\n\n  // If appropriate, release entire page\n  if (releasePage) {\n   // Remove from free list\n   mem = (u8*)allocator + startPage * allocator->pageSize;\n   for (u32 i = 0; i < numAllocationsPerPage; ++i) {\n    Allocation* iter = (Allocation*)mem;\n    mem += blockSize;\n    Memory::Assert(iter != 0, \"On line: \" \"420\" \", in file: \" \"./mem.cpp\", 420, \"./mem.cpp\");\n\n    RemoveFromList(allocator, freeList, iter);\n   }\n\n   // Clear the tracking bits\n   Memory::Assert(startPage > 0, \"On line: \" \"426\" \", in file: \" \"./mem.cpp\", 426, \"./mem.cpp\");\n   ClearRange(allocator, startPage, 1);\n  }\n\n  if (allocator->releaseCallback != 0) {\n   allocator->releaseCallback(allocator, header, oldSize, blockSize, startPage, releasePage ? 1 : 0);\n  }\n }\n\n} // Namespace Memory\n\n\n\n\n extern unsigned char __heap_base;\n extern unsigned char __data_end;\n\n // These are wasm shim functions\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmHeapSize(int memSize) {\n  void* heapPtr = &__heap_base;\n\n  Memory::ptr_type heapAddr = (Memory::ptr_type)heapPtr;\n  Memory::ptr_type maxAddr = (Memory::ptr_type)memSize;\n\n  Memory::ptr_type heapSize = maxAddr - heapAddr;\n  return (int)heapSize;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" Memory::Allocator* GameAllocator_wasmInitialize(int heapSize) {\n  void* memory = &__heap_base;\n  u32 size = (u32)heapSize; //GameAllocator_wasmHeapSize(totalMemorySize);\n\n  Memory::AlignAndTrim(&memory, &size);\n  Memory::Allocator* allocator = Memory::Initialize(memory, size);\n  Memory::wasmGlobalAllocator = allocator;\n\n  return allocator;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" void GameAllocator_wasmShutdown(Memory::Allocator* allocator) {\n  Memory::Shutdown(allocator);\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" void* GameAllocator_wasmAllocate(Memory::Allocator* allocator, int bytes, int alignment) {\n  return Memory::wasmGlobalAllocator->Allocate(bytes, alignment, \"GameAllocator_wasmAllocate\");\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" void GameAllocator_wasmRelease(Memory::Allocator* allocator, void* mem) {\n  Memory::wasmGlobalAllocator->Release(mem, \"GameAllocator_wasmAllocate\");\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" void GameAllocator_wasmSet(void* mem, int val, int size) {\n  Memory::Set(mem, (u8)val, (u32)size, \"GameAllocator_wasmAllocate\");\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" void GameAllocator_wasmCopy(void* dst, const void* src, int size) {\n  Memory::Copy(dst, src, (u32)size, \"GameAllocator_wasmAllocate\");\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmGetNumPages(Memory::Allocator* a) {\n        return a->size / a->pageSize;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmGetNumPagesInUse(Memory::Allocator* a) {\n        return a->numPagesUsed;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmGetPeekPagesUsed(Memory::Allocator* a) {\n        return a->peekPagesUsed;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmGetRequestedBytes(Memory::Allocator* a) {\n        return a->requested;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmGetServedBytes(Memory::Allocator* a) {\n  u32 maskSize = AllocatorPageMaskSize(a) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n  u32 metaDataSizeBytes = sizeof(Memory::Allocator) + (maskSize * sizeof(u32));\n  u32 numberOfMasksUsed = metaDataSizeBytes / a->pageSize;\n  if (metaDataSizeBytes % a->pageSize != 0) {\n   numberOfMasksUsed += 1;\n  }\n  metaDataSizeBytes = numberOfMasksUsed * a->pageSize; // This way, allocatable will start on a page boundary\n  // Account for meta data\n  metaDataSizeBytes += a->pageSize;\n  numberOfMasksUsed += 1;\n\n  u32 numPages = a->size / a->pageSize;\n  u32 usedPages = a->numPagesUsed;\n  u32 freePages = numPages - usedPages;\n  u32 overheadPages = metaDataSizeBytes / a->pageSize;\n\n  return (usedPages - overheadPages) * a->pageSize;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmIsPageInUse(Memory::Allocator* a, int page) {\n  u32 m = page / Memory::TrackingUnitSize;\n  u32 b = page % Memory::TrackingUnitSize;\n  u32 * mask = (u32*)Memory::AllocatorPageMask(a);\n\n  bool set = mask[m] & (1 << b);\n  return set;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmGetSize(Memory::Allocator* a) {\n        return a->size;\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmGetNumOverheadPages(Memory::Allocator* a) {\n  u32 maskSize = Memory::AllocatorPageMaskSize(a) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n  u32 metaDataSizeBytes = Memory::AllocatorPaddedSize() + (maskSize * sizeof(u32));\n  u32 numberOfMasksUsed = metaDataSizeBytes / a->pageSize;\n  if (metaDataSizeBytes % a->pageSize != 0) {\n   numberOfMasksUsed += 1;\n  }\n  metaDataSizeBytes = numberOfMasksUsed * a->pageSize; // This way, allocatable will start on a page boundary\n  // Account for meta data\n  metaDataSizeBytes += a->pageSize;\n  numberOfMasksUsed += 1;\n\n  u32 overheadPages = metaDataSizeBytes / a->pageSize;\n\n  return (int)overheadPages;\n }\n\n // Helper functions\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" int GameAllocator_wasmStrLen(const char* str) {\n  if (str == 0) {\n   return 0;\n  }\n\n  const char *s = str;\n  while (*s) {\n   ++s;\n  }\n  return (s - str);\n }\n\n    extern \"C\" void GameAllocator_jsBuildMemState(const u8* msg, int len);\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" void GameAllocator_wasmDumpState(Memory::Allocator* allocator) {\n  Memory::Debug::MemInfo(allocator, [](const u8* mem, u32 size, void* userdata) {\n   GameAllocator_jsBuildMemState(mem, (int)size);\n  }, 0);\n }\n\n __attribute__ (( visibility( \"default\" ) )) extern \"C\" void* GameAllocator_wasmGetAllocationDebugName(Memory::Allocator* allocator, void* _m) {\n  const char* l = \"mem_GetAllocationDebugName\";\n\n  u8* debugPage = allocator->RequestDbgPage();\n  u32 debugSize = allocator->pageSize;\n\n  // Reset memory buffer\n  Memory::Set(debugPage, 0, debugSize, l);\n  u8* i_to_a_buff = debugPage; // Used to convert numbers to strings\n  const u32 i_to_a_buff_size = GameAllocator_wasmStrLen((const char*)\"18446744073709551615\") + 1; // u64 max\n\n  u8* mem = i_to_a_buff + i_to_a_buff_size;\n  u32 memSize = allocator->pageSize - i_to_a_buff_size;\n\n  u8* m = (u8*)_m - sizeof(Memory::Allocation);\n  Memory::Allocation* iter = (Memory::Allocation*)m;\n\n  Memory::Copy(mem, \"Address: \", 9, l);\n  mem += 9; memSize -= 9;\n\n  u32 allocationOffset = (u32)((u8*)iter - (u8*)allocator);\n  i32 i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, allocationOffset);\n  Memory::Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  Memory::Copy(mem, \", size: \", 8, l);\n  mem += 8; memSize -= 8;\n\n  i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->size);\n  Memory::Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  Memory::Copy(mem, \", padded: \", 10, l);\n  mem += 10; memSize -= 10;\n\n  u32 alignment = iter->alignment;\n  u32 allocationHeaderPadding = 0;\n  if (alignment != 0) { // Add padding to the header to compensate for alignment\n   allocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n  }\n\n  u32 realSize = iter->size + (u32)(sizeof(Memory::Allocation)) + allocationHeaderPadding;\n  i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, realSize);\n  Memory::Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  Memory::Copy(mem, \", alignment: \", 13, l);\n  mem += 13; memSize -= 13;\n\n  i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->alignment);\n  Memory::Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  Memory::Copy(mem, \", first page: \", 14, l);\n  mem += 14; memSize -= 14;\n\n  i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, (allocationOffset) / allocator->pageSize);\n  Memory::Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  Memory::Copy(mem, \", prev: \", 8, l);\n  mem += 8; memSize -= 8;\n\n  i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->prevOffset);\n  Memory::Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  Memory::Copy(mem, \", next: \", 8, l);\n  mem += 8; memSize -= 8;\n\n  i_len = Memory::Debug::u32toa(i_to_a_buff, i_to_a_buff_size, iter->nextOffset);\n  Memory::Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  u32 pathLen = 0;\n\n  if (iter->location != 0) {\n   pathLen = GameAllocator_wasmStrLen((const char*)iter->location);\n  }\n\n\n  Memory::Copy(mem, \", location: \", 12, l);\n  mem += 12; memSize -= 12;\n\n\n  if (iter->location == 0) {\n\n\n\n   Memory::Copy(mem, \"null\", 4, l);\n   mem += 4; memSize -= 4;\n  }\n\n  else {\n   Memory::Copy(mem, iter->location, pathLen, l);\n   mem += pathLen;\n   memSize -= pathLen;\n  }\n\n\n  *mem = '\\0';\n\n  allocator->ReleaseDbgPage();\n\n  return debugPage + i_to_a_buff_size;\n }\n\n\n\nu32 Memory::AlignAndTrim(void** memory, u32* size, u32 alignment, u32 pageSize) {\n\n\n\n u32 ptr = (u32)((const void*)(*memory));\n\n\n\n u32 delta = 0;\n\n    if (alignment != 0) {\n        // Align to 8 byte boundary. This is so the mask array lines up on a u64\n        u32 alignmentDelta = alignment - (u32)(ptr % alignment);\n        Memory::Assert(alignmentDelta <= (*size), \"On line: \" \"702\" \", in file: \" \"./mem.cpp\", 702, \"./mem.cpp\");\n        if (alignmentDelta > *size) { // In release mode, we want to fail on asserts\n            *memory = 0;\n            *size = 0;\n            return 0;\n        }\n\n        if (ptr % alignment != 0) {\n            u8* mem = (u8*)(*memory);\n\n            delta += alignmentDelta;\n            mem += alignmentDelta;\n            *size -= alignmentDelta;\n            *memory = mem;\n        }\n    }\n\n // Trim to page size (4096) to make sure the provided memory can be chunked up perfectly\n if ((*size) % pageSize != 0) {\n  u32 diff = (*size) % pageSize;\n  Memory::Assert(*size >= diff, \"On line: \" \"722\" \", in file: \" \"./mem.cpp\", 722, \"./mem.cpp\");\n        if (*size < diff) { // In release mode, fail on assert\n            *memory = 0;\n            *size = 0;\n            return 0;\n        }\n  *size -= diff;\n  delta += diff;\n }\n\n return delta;\n}\n\nMemory::Allocator* Memory::Initialize(void* memory, u32 bytes, u32 pageSize) {\n Memory::Assert(pageSize % AllocatorAlignment == 0, \"Memory::Initialize, Page boundaries are expected to be on 8 bytes\", 736, \"./mem.cpp\");\n // First, make sure that the memory being passed in is aligned well\n\n\n\n u32 ptr = (u32)((const void*)memory);\n\n\n\n Memory::Assert(ptr % AllocatorAlignment == 0, \"Memory::Initialize, Memory being managed should be 8 byte aligned. Consider using Memory::AlignAndTrim\", 745, \"./mem.cpp\");\n Memory::Assert(bytes % pageSize == 0, \"Memory::Initialize, the size of the memory being managed must be aligned to Memory::PageSize\", 746, \"./mem.cpp\");\n Memory::Assert(bytes / pageSize >= 10, \"Memory::Initialize, minimum memory size is 10 pages, page size is Memory::PageSize\", 747, \"./mem.cpp\");\n\n // Set up the allocator\n Allocator* allocator = (Allocator*)memory;\n Set(memory, 0, sizeof(Allocator), \"Memory::Initialize\");\n allocator->size = bytes;\n allocator->pageSize = pageSize;\n allocator->mask = 0;\n\n // Set up the mask that will track our allocation data\n u32* mask = (u32*)AllocatorPageMask(allocator);\n u32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n Set(mask, 0, sizeof(u32) * maskSize, \"On line: \" \"759\" \", in file: \" \"./mem.cpp\");\n\n // Find how many pages the meta data for the header + allocation mask will take up. \n // Store the offset to first allocatable, \n u32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n u32 numberOfMasksUsed = metaDataSizeBytes / pageSize;\n if (metaDataSizeBytes % pageSize != 0) {\n  numberOfMasksUsed += 1;\n }\n metaDataSizeBytes = numberOfMasksUsed * pageSize; // This way, allocatable will start on a page boundary\n\n // Add a debug page at the end\n metaDataSizeBytes += pageSize;\n numberOfMasksUsed += 1;\n\n //allocator->offsetToAllocatable = metaDataSizeBytes;\n allocator->scanBit = 0;\n SetRange(allocator, 0, numberOfMasksUsed);\n allocator->requested = 0;\n\n if (ptr % AllocatorAlignment != 0 || bytes % pageSize != 0 || bytes / pageSize < 10) {\n  Memory::Assert(false, \"On line: \" \"780\" \", in file: \" \"./mem.cpp\", 780, \"./mem.cpp\");\n  return 0;\n }\n\n return (Allocator*)memory;\n}\n\nvoid Memory::Shutdown(Allocator* allocator) {\n Memory::Assert(allocator != 0, \"Memory::Shutdown called without it being initialized\", 788, \"./mem.cpp\");\n u32* mask = (u32*)AllocatorPageMask(allocator);\n u32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n Memory::Assert(allocator->size > 0, \"Memory::Shutdown, trying to shut down an un-initialized allocator\", 791, \"./mem.cpp\");\n\n // Unset tracking bits\n u32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n u32 numberOfMasksUsed = metaDataSizeBytes / allocator->pageSize;\n if (metaDataSizeBytes % allocator->pageSize != 0) {\n  numberOfMasksUsed += 1;\n }\n metaDataSizeBytes = numberOfMasksUsed * allocator->pageSize;\n\n // There is a debug between the memory bitmask and allocatable memory\n metaDataSizeBytes += allocator->pageSize;\n numberOfMasksUsed += 1;\n\n ClearRange(allocator, 0, numberOfMasksUsed);\n Memory::Assert(allocator->requested == 0, \"Memory::Shutdown, not all memory has been released\", 806, \"./mem.cpp\");\n\n Memory::Assert(allocator->active == 0, \"There are active allocations in Memory::Shutdown, leaking memory\", 808, \"./mem.cpp\");\n Memory::Assert(allocator->free_64 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\", 809, \"./mem.cpp\");\n Memory::Assert(allocator->free_128 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\", 810, \"./mem.cpp\");\n Memory::Assert(allocator->free_256 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\", 811, \"./mem.cpp\");\n Memory::Assert(allocator->free_512 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\", 812, \"./mem.cpp\");\n Memory::Assert(allocator->free_1024 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\", 813, \"./mem.cpp\");\n Memory::Assert(allocator->free_2048 == 0, \"Free list is not empty in Memory::Shutdown, leaking memory\", 814, \"./mem.cpp\");\n\n\n // In debug mode only, we will scan the entire mask to make sure all memory has been free-d\n for (u32 i = 0; i < maskSize; ++i) {\n  Memory::Assert(mask[i] == 0, \"Page tracking unit isn't empty in Memory::Shutdown, leaking memory.\", 819, \"./mem.cpp\");\n }\n\n}\n\nvoid Memory::Copy(void* dest, const void* source, u32 size, const char* location) {\n\n\n\n\n\n u32 dst_ptr = (u32)((const void*)(dest));\n u32 src_ptr = (u32)((const void*)(source));\n u32 alignment = sizeof(u32);\n\n\n\n\n if (dst_ptr % alignment != 0 || src_ptr % alignment != 0) {\n  // Memory is not aligned well, fall back on slow copy\n  u8* dst = (u8*)dest;\n  const u8* src = (const u8*)source;\n  for (u32 i = 0; i < size; ++i) {\n   dst[i] = src[i];\n  }\n  return;\n }\n u32 size_32 = size / sizeof(u32);\n u32* dst_32 = (u32*)dest;\n const u32* src_32 = (u32*)source;\n\n for (u32 i = 0; i < size_32; ++i) {\n  dst_32[i] = src_32[i];\n }\n\n\n\n\n u32 size_16 = (size - size_32 * sizeof(u32)) / sizeof(u16);\n\n u16* dst_16 = (u16*)(dst_32 + size_32);\n const u16* src_16 = (const u16*)(src_32 + size_32);\n for (u32 i = 0; i < size_16; ++i) {\n  dst_16[i] = src_16[i];\n }\n\n\n\n\n u32 size_8 = (size - size_32 * sizeof(u32) - size_16 * sizeof(u16));\n\n u8* dst_8 = (u8*)(dst_16 + size_16);\n const u8* src_8 = (const u8*)(src_16 + size_16);\n for (u32 i = 0; i < size_8; ++i) {\n  dst_8[i] = src_8[i];\n }\n\n\n\n\n Memory::Assert(size_32 * sizeof(u32) + size_16 * sizeof(u16) + size_8 == size, \"Number of pages not adding up\", 894, \"./mem.cpp\");\n\n\n\n}\n\n// MSVC generates a recursive memset with this implementation. The naive one works fine.\n//#pragma optimize( \"\", off )\nvoid* Memory::Set(void* memory, u8 value, u32 size, const char* location) {\n if (memory == 0) {\n  return 0; // Can't set null!\n }\n\n\n\n\n\n u32 ptr = (u32)((const void*)(memory));\n u32 alignment = sizeof(u32);\n\n\n\n\n if (size <= alignment) {\n  u8* mem = (u8*)memory;\n  /* MSCV was optimizing this loop into a recursive call?\n\t\tfor (u32 i = 0; i < size; ++i) {\n\t\t\tmem[i] = value;\n\t\t}*/\n  while ((alignment--) > 0) {\n   *mem = value;\n  }\n  return memory;\n }\n\n // Algin memory if needed\n Memory::Assert(alignment >= (ptr % alignment), \"On line: \" \"930\" \", in file: \" \"./mem.cpp\", 930, \"./mem.cpp\");\n u32 alignDelta = (u32)(alignment - (ptr % alignment));\n Memory::Assert(alignDelta <= alignment, \"On line: \" \"932\" \", in file: \" \"./mem.cpp\", 932, \"./mem.cpp\");\n Memory::Assert(size >= alignDelta, \"On line: \" \"933\" \", in file: \" \"./mem.cpp\", 933, \"./mem.cpp\");\n\n u8* mem = (u8*)(memory);\n if (alignDelta != 0) {\n  if (alignDelta > size) {\n   alignDelta = size;\n  }\n  for (u32 iter = 0; iter < alignDelta; ++iter) {\n   mem[iter] = value;\n  }\n\n  mem += alignDelta;\n  size -= alignDelta;\n }\n u32 size_32 = size / sizeof(u32);\n u32* ptr_32 = (u32*)memory;\n\n u32 val_32 = (((u32)value) << 8) | (((u32)value) << 16) | (((u32)value) << 24) | ((u32)value);\n for (u32 i = 0; i < size_32; ++i) {\n  ptr_32[i] = val_32;\n }\n\n\n\n\n u32 size_16 = (size - size_32 * sizeof(u32)) / sizeof(u16);\n\n u16* ptr_16 = (u16*)(ptr_32 + size_32);\n u32 val_16 = (((u16)value) << 8) | ((u16)value);\n for (u32 i = 0; i < size_16; ++i) {\n  ptr_16[i] = val_16;\n }\n\n\n\n\n u32 size_8 = (size - size_32 * sizeof(u32) - size_16 * sizeof(u16));\n\n u8* ptr_8 = (u8*)(ptr_16 + size_16);\n for (u32 i = 0; i < size_8; ++i) {\n  ptr_8[i] = value;\n }\n\n\n\n\n Memory::Assert(size_32 * sizeof(u32) + size_16 * sizeof(u16) + size_8 == size, \"Number of pages not adding up\", 994, \"./mem.cpp\");\n\n\n\n\n return memory;\n}\n//#pragma optimize( \"\", on )\n\nu8* Memory::Allocator::RequestDbgPage() {\n Memory::Allocator* allocator = this;\n\n Memory::Assert(allocator->mask == 0, \"Debug page already in use\", 1006, \"./mem.cpp\");\n allocator->mask = 1;\n\n // Set up the mask that will track our allocation data\n u32* mask = (u32*)AllocatorPageMask(allocator);\n u32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n\n // Find how many pages the meta data for the header + allocation mask will take up. \n // Store the offset to first allocatable, \n u32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n u32 numberOfMasksUsed = metaDataSizeBytes / allocator->pageSize;\n if (metaDataSizeBytes % allocator->pageSize != 0) {\n  numberOfMasksUsed += 1;\n }\n metaDataSizeBytes = numberOfMasksUsed * allocator->pageSize; // This way, allocatable will start on a page boundary\n\n // Add a debug page at the end\n metaDataSizeBytes += allocator->pageSize;\n numberOfMasksUsed += 1;\n\n u8* debugPage = (u8*)allocator + metaDataSizeBytes - allocator->pageSize; // Debug page is always one page before allocatable\n return debugPage;\n}\n\nvoid Memory::Allocator::ReleaseDbgPage() {\n Memory::Allocator* allocator = this;\n\n Memory::Assert(allocator->mask != 0, \"Debug page not in use\", 1033, \"./mem.cpp\");\n allocator->mask = 0;\n}\n\nvoid* Memory::Allocator::Allocate(u32 bytes, u32 alignment, const char* location) {\n if (bytes == 0) {\n  bytes = 1; // At least one byte required\n }\n Memory::Allocator* allocator = this;\n Memory::Assert(bytes < allocator->size, \"Memory::Allocate trying to allocate more memory than is available\", 1042, \"./mem.cpp\");\n Memory::Assert(bytes < allocator->size - allocator->requested, \"Memory::Allocate trying to allocate more memory than is available\", 1043, \"./mem.cpp\");\n\n u32 allocationHeaderPadding = 0;\n if (alignment != 0) { // Add paddnig to make sure we can align the memory\n  allocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n }\n u32 allocationHeaderSize = sizeof(Allocation) + allocationHeaderPadding;\n\n // Add the header size to our allocation size\n u32 allocationSize = bytes; // Add enough space to pad out for alignment\n allocationSize += allocationHeaderSize;\n\n // Figure out how many pages are going to be needed to hold that much memory\n u32 numPagesRequested = allocationSize / allocator->pageSize + (allocationSize % allocator->pageSize ? 1 : 0);\n Memory::Assert(numPagesRequested > 0, \"Memory::Allocate needs to request at least 1 page\", 1057, \"./mem.cpp\");\n\n // We can record the request here. It's made before the allocation callback, and is valid for sub-allocations too.\n allocator->requested += bytes;\n Memory::Assert(allocator->requested < allocator->size, \"On line: \" \"1061\" \", in file: \" \"./mem.cpp\", 1061, \"./mem.cpp\");\n\n\n if (alignment == 0) {\n  if (allocationSize <= 64) {\n   return SubAllocate(bytes, 64, &allocator->free_64, location, allocator);\n  }\n  else if (allocationSize <= 128) {\n   return SubAllocate(bytes, 128, &allocator->free_128, location, allocator);\n  }\n  else if (allocationSize <= 256) {\n   return SubAllocate(bytes, 256, &allocator->free_256, location, allocator);\n  }\n  else if (allocationSize <= 512) {\n   return SubAllocate(bytes, 512, &allocator->free_512, location, allocator);\n  }\n  else if (allocationSize <= 1024) {\n   return SubAllocate(bytes, 1024, &allocator->free_1024, location, allocator);\n  }\n  else if (allocationSize <= 2048) {\n   return SubAllocate(bytes, 2048, &allocator->free_2048, location, allocator);\n  }\n }\n\n\n // Find enough memory to allocate\n\n u32 firstPage = FindRange(allocator, numPagesRequested, 0);\n\n\n\n Memory::Assert(firstPage != 0, \"Memory::Allocate failed to find enough pages to fufill allocation\", 1092, \"./mem.cpp\");\n\n SetRange(allocator, firstPage, numPagesRequested);\n\n if (firstPage == 0 || allocator->size % allocator->pageSize != 0) {\n  Memory::Assert(false, \"On line: \" \"1097\" \", in file: \" \"./mem.cpp\", 1097, \"./mem.cpp\");\n  return 0; // Fail this allocation in release mode\n }\n\n // Fill out header\n u8* mem = (u8*)allocator + firstPage * allocator->pageSize;\n\n u32 alignmentOffset = 0;\n if (alignment != 0) {\n\n\n\n  u32 mem_addr = (u32)((void*)mem) + sizeof(Allocation);\n\n\n\n  if (mem_addr % alignment != 0) {\n   mem_addr = (mem_addr + (alignment - 1)) / alignment * alignment;\n   mem = (u8*)(mem_addr - sizeof(Allocation));\n  }\n }\n\n Allocation* allocation = (Allocation*)mem;\n mem += sizeof(Allocation);\n\n allocation->alignment = alignment;\n allocation->size = bytes;\n allocation->prevOffset = 0;\n allocation->nextOffset = 0;\n\n allocation->location = location;\n\n\n // Track allocated memory\n Memory::Assert(allocation != allocator->active, \"On line: \" \"1131\" \", in file: \" \"./mem.cpp\", 1131, \"./mem.cpp\"); // Should be impossible, but we could have bugs...\n AddtoList(allocator, &allocator->active, allocation);\n\n // Return memory\n if (allocator->allocateCallback != 0) {\n  u8* _mem = (u8*)allocator + firstPage * allocator->pageSize;\n  _mem += allocationHeaderPadding;\n  Allocation* _allocation = (Allocation*)_mem;\n  allocator->allocateCallback(allocator, _allocation, bytes, allocationSize, firstPage, numPagesRequested);\n }\n\n return mem;\n}\n\nvoid Memory::Allocator::Release(void* memory, const char* location) {\n Memory::Assert(memory != 0, \"Memory:Free can't free a null pointer\", 1156, \"./mem.cpp\");\n Allocator* allocator = this;\n\n // Retrieve allocation information from header. The allocation header always\n // preceeds the allocation.\n u8* mem = (u8*)memory;\n mem -= sizeof(Allocation);\n Allocation* allocation = (Allocation*)mem;\n Memory::Assert(allocation != 0, \"Can't free null\", 1164, \"./mem.cpp\");\n u32 alignment = allocation->alignment;\n\n u32 allocationSize = allocation->size; // Add enough space to pad out for alignment\n\n u32 allocationHeaderPadding = 0;\n if (alignment != 0) { // Add padding to the header to compensate for alignment\n  allocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n }\n u32 paddedAllocationSize = allocationSize + allocationHeaderPadding + sizeof(Allocation);\n Memory::Assert(allocationSize != 0, \"Memory::Free, double free\", 1174, \"./mem.cpp\");\n\n Memory::Assert(allocator->requested >= allocation->size, \"Memory::Free releasing more memory than was requested\", 1176, \"./mem.cpp\");\n Memory::Assert(allocator->requested != 0, \"Memory::Free releasing more memory, but there is nothing to release\", 1177, \"./mem.cpp\");\n allocator->requested -= allocation->size;\n\n\n if (alignment == 0) {\n  if (paddedAllocationSize <= 64) {\n   SubRelease(memory, 64, &allocator->free_64, location, allocator);\n   return;\n  }\n  else if (paddedAllocationSize <= 128) {\n   SubRelease(memory, 128, &allocator->free_128, location, allocator);\n   return;\n  }\n  else if (paddedAllocationSize <= 256) {\n   SubRelease(memory, 256, &allocator->free_256, location, allocator);\n   return;\n  }\n  else if (paddedAllocationSize <= 512) {\n   SubRelease(memory, 512, &allocator->free_512, location, allocator);\n   return;\n  }\n  else if (paddedAllocationSize <= 1024) {\n   SubRelease(memory, 1024, &allocator->free_1024, location, allocator);\n   return;\n  }\n  else if (paddedAllocationSize <= 2048) {\n   SubRelease(memory, 2048, &allocator->free_2048, location, allocator);\n   return;\n  }\n }\n\n\n // Clear the bits that where tracking this memory\n u8* firstMemory = (u8*)allocator;\n u32 address = (u32)((u8*)mem - (u8*)firstMemory);\n\n u32 firstPage = address / allocator->pageSize;\n u32 numPages = paddedAllocationSize / allocator->pageSize + (paddedAllocationSize % allocator->pageSize ? 1 : 0);\n ClearRange(allocator, firstPage, numPages);\n\n // Unlink tracking\n RemoveFromList(allocator, &allocator->active, allocation);\n\n // Set the size to 0, to indicate that this header has been free-d\n u32 oldSize = allocation->size;\n allocation->size = 0;\n\n if (allocator->releaseCallback != 0) {\n  allocator->releaseCallback(allocator, allocation, oldSize, paddedAllocationSize, firstPage, numPages);\n }\n}\n\nnamespace Memory {\n namespace Debug {\n  class str_const { // constexpr string\n  private:\n   const char* const p_;\n   const ptr_type sz_;\n  private:\n   str_const& operator= (const str_const& other) = delete;\n   str_const(const str_const&& other) = delete;\n   str_const& operator= (const str_const&& other) = delete;\n  public:\n   template<ptr_type N>\n   constexpr str_const(const char(&a)[N]) noexcept : // ctor\n    p_(a), sz_(N - 1) {\n   }\n   constexpr char operator[](ptr_type n) const noexcept { // []\n\n    if (n >= sz_) {\n     Assert(false, \"n >= sz\", 1247, \"./mem.cpp\");\n    }\n    return p_[n];\n\n\n\n   }\n   constexpr u32 size() const noexcept { // string length\n    return (u32)sz_;\n   } // size()\n   const char* begin() const noexcept { // start iterator\n    return p_;\n   } // begin()\n   const char* end() const noexcept { // End iterator\n    return p_ + sz_;\n   } // end()\n   template<typename T>\n   T& operator<<(T& stream) { // Stream op\n    stream << p_;\n    return stream;\n   } // <<\n  };\n\n  u32 u32toa(u8* dest, u32 destSize, u32 num) { // Returns length of string\n   Set(dest, 0, destSize, \"Memory::Debug::u32toa\");\n\n   u32 count = 0;\n   u32 tmp = num;\n   while (tmp != 0) {\n    tmp = tmp / 10;\n    count = count + 1;\n   }\n\n   if (count == 0) {\n    *dest = '0';\n    return 1;\n   }\n\n   u8* last = dest + count - 1;\n   while (num != 0) {\n    u32 digit = num % 10;\n    num = num / 10;\n\n    *last-- = '0' + digit;\n   }\n\n   return count;\n  }\n\n  u32 strlen(const u8* str) {\n   const u8* s;\n   for (s = str; *s; ++s);\n   return (u32)(s - str);\n  }\n } // namespace Debug\n} // namespace Memory\n\nvoid Memory::Debug::MemInfo(Allocator* allocator, WriteCallback callback, void* userdata) {\n const char* l = \"Memory::Debug::DumpAllocationHeaders\";\n\n u8* debugPage = allocator->RequestDbgPage();\n u32 debugSize = allocator->pageSize;\n\n // Reset memory buffer\n Set(debugPage, 0, debugSize, l);\n u8* i_to_a_buff = debugPage; // Used to convert numbers to strings\n const u32 i_to_a_buff_size = strlen((const u8*)\"18446744073709551615\") + 1; // u64 max\n u8* mem = i_to_a_buff + i_to_a_buff_size;\n u32 memSize = allocator->pageSize - i_to_a_buff_size;\n\n { // Tracking %d Pages, %d KiB (%d MiB)\n  constexpr str_const out0(\"Tracking \");\n  Copy(mem, out0.begin(), out0.size(), l);\n  mem += out0.size();\n  memSize -= out0.size();\n\n  u32 numPages = allocator->size / allocator->pageSize;\n  Memory::Assert(allocator->size % allocator->pageSize == 0, l, 1324, \"./mem.cpp\");\n\n  u32 i_len = u32toa(i_to_a_buff, i_to_a_buff_size, numPages);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out1(\" pages, Page size: \");\n  Copy(mem, out1.begin(), out1.size(), l);\n  mem += out1.size();\n  memSize -= out1.size();\n\n  i_len = u32toa(i_to_a_buff, i_to_a_buff_size, allocator->pageSize);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out11(\" bytes\\nTotal memory size: \");\n  Copy(mem, out11.begin(), out11.size(), l);\n  mem += out11.size();\n  memSize -= out11.size();\n\n  u32 kib = allocator->size / 1024;\n  i_len = u32toa(i_to_a_buff, i_to_a_buff_size, kib);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out2(\" KiB (\");\n  Copy(mem, out2.begin(), out2.size(), l);\n  mem += out2.size();\n  memSize -= out2.size();\n\n  u32 mib = kib / 1024;\n  i_len = u32toa(i_to_a_buff, i_to_a_buff_size, mib);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out3(\" MiB)\\n\");\n  Copy(mem, out3.begin(), out3.size(), l);\n  mem += out3.size();\n  memSize -= out3.size();\n }\n\n // Dump what's been written so far\n mem = i_to_a_buff + i_to_a_buff_size;\n callback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n // Reset memory buffer\n Set(debugPage, 0, debugSize, l);\n i_to_a_buff = debugPage; // Used to convert numbers to strings\n mem = i_to_a_buff + i_to_a_buff_size;\n memSize = allocator->pageSize - i_to_a_buff_size;\n\n { // Pages: %d free, %d used, %d overhead\n  constexpr str_const out0(\"Page state: \");\n  Copy(mem, out0.begin(), out0.size(), l);\n  mem += out0.size();\n  memSize -= out0.size();\n\n  u32 maskSize = AllocatorPageMaskSize(allocator) / (sizeof(u32) / sizeof(u8)); // convert from u8 to u32\n  u32 metaDataSizeBytes = AllocatorPaddedSize() + (maskSize * sizeof(u32));\n  u32 numberOfMasksUsed = metaDataSizeBytes / allocator->pageSize;\n  if (metaDataSizeBytes % allocator->pageSize != 0) {\n   numberOfMasksUsed += 1;\n  }\n  metaDataSizeBytes = numberOfMasksUsed * allocator->pageSize; // This way, allocatable will start on a page boundary\n  // Account for meta data\n  metaDataSizeBytes += allocator->pageSize;\n  numberOfMasksUsed += 1;\n\n  u32 numPages = allocator->size / allocator->pageSize;\n  Memory::Assert(allocator->size % allocator->pageSize == 0, l, 1397, \"./mem.cpp\");\n  u32 usedPages = allocator->numPagesUsed;\n  Memory::Assert(usedPages <= numPages, l, 1399, \"./mem.cpp\");\n  u32 freePages = numPages - usedPages;\n  u32 overheadPages = metaDataSizeBytes / allocator->pageSize;\n  Memory::Assert(usedPages >= overheadPages, l, 1402, \"./mem.cpp\");\n  usedPages -= overheadPages;\n\n  u32 i_len = u32toa(i_to_a_buff, i_to_a_buff_size, freePages);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out1(\" free, \");\n  Copy(mem, out1.begin(), out1.size(), l);\n  mem += out1.size();\n  memSize -= out1.size();\n\n  i_len = u32toa(i_to_a_buff, i_to_a_buff_size, usedPages);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out2(\" used, \");\n  Copy(mem, out2.begin(), out2.size(), l);\n  mem += out2.size();\n  memSize -= out2.size();\n\n  i_len = u32toa(i_to_a_buff, i_to_a_buff_size, overheadPages);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out3(\" overhead\\nRequested: \");\n  Copy(mem, out3.begin(), out3.size(), l);\n  mem += out3.size();\n  memSize -= out3.size();\n\n  i_len = u32toa(i_to_a_buff, i_to_a_buff_size, allocator->requested);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out4(\" bytes, Served: \");\n  Copy(mem, out4.begin(), out4.size(), l);\n  mem += out4.size();\n  memSize -= out4.size();\n\n  i_len = u32toa(i_to_a_buff, i_to_a_buff_size, usedPages * allocator->pageSize);\n  Copy(mem, i_to_a_buff, i_len, l);\n  mem += i_len;\n  memSize -= i_len;\n\n  constexpr str_const out5(\" bytes\\n\");\n  Copy(mem, out5.begin(), out5.size(), l);\n  mem += out5.size();\n  memSize -= out5.size();\n }\n\n // Dump what's been written so far\n mem = i_to_a_buff + i_to_a_buff_size;\n callback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n // Reset memory buffer\n Set(debugPage, 0, debugSize, l);\n i_to_a_buff = debugPage; // Used to convert numbers to strings\n mem = i_to_a_buff + i_to_a_buff_size;\n memSize = allocator->pageSize - i_to_a_buff_size;\n\n { // Dump active list\n  constexpr str_const out0(\"\\nActive allocations:\\n\");\n  Copy(mem, out0.begin(), out0.size(), l);\n  mem += out0.size();\n  memSize -= out0.size();\n\n  for (Allocation* iter = allocator->active; iter != 0; iter = (iter->nextOffset == 0)? 0 : (Allocation*)((u8*)allocator + iter->nextOffset)) {\n   //u64 address = (u64)((void*)iter);\n   u64 alloc_address = (u64)((void*)allocator);\n\n   constexpr str_const out5(\"\\t\");\n   Copy(mem, out5.begin(), out5.size(), l);\n   mem += out5.size();\n   memSize -= out5.size();\n\n   u32 allocationOffset = (u32)((u8*)iter - (u8*)allocator);\n   i32 i_len = u32toa(i_to_a_buff, i_to_a_buff_size, allocationOffset);\n   Copy(mem, i_to_a_buff, i_len, l);\n   mem += i_len;\n   memSize -= i_len;\n\n   constexpr str_const out2(\", size: \");\n   Copy(mem, out2.begin(), out2.size(), l);\n   mem += out2.size();\n   memSize -= out2.size();\n\n   i_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->size);\n   Copy(mem, i_to_a_buff, i_len, l);\n   mem += i_len;\n   memSize -= i_len;\n\n   constexpr str_const out3(\", padded: \");\n   Copy(mem, out3.begin(), out3.size(), l);\n   mem += out3.size();\n   memSize -= out3.size();\n\n   u32 alignment = iter->alignment;\n   u32 allocationHeaderPadding = 0;\n   if (alignment != 0) { // Add padding to the header to compensate for alignment\n    allocationHeaderPadding = alignment - 1; // Somewhere in this range, we will be aligned\n   }\n\n   u32 realSize = iter->size + (u32)(sizeof(Allocation)) + allocationHeaderPadding;\n   i_len = u32toa(i_to_a_buff, i_to_a_buff_size, realSize);\n   Copy(mem, i_to_a_buff, i_len, l);\n   mem += i_len;\n   memSize -= i_len;\n\n   constexpr str_const out6(\", alignment: \");\n   Copy(mem, out6.begin(), out6.size(), l);\n   mem += out6.size();\n   memSize -= out6.size();\n\n   i_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->alignment);\n   Copy(mem, i_to_a_buff, i_len, l);\n   mem += i_len;\n   memSize -= i_len;\n\n   constexpr str_const outfp(\", first page: \");\n   Copy(mem, outfp.begin(), outfp.size(), l);\n   mem += outfp.size();\n   memSize -= outfp.size();\n\n   i_len = u32toa(i_to_a_buff, i_to_a_buff_size, (allocationOffset) / allocator->pageSize);\n   Copy(mem, i_to_a_buff, i_len, l);\n   mem += i_len;\n   memSize -= i_len;\n\n   constexpr str_const out0(\", prev: \");\n   Copy(mem, out0.begin(), out0.size(), l);\n   mem += out0.size();\n   memSize -= out0.size();\n\n   i_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->prevOffset);\n   Copy(mem, i_to_a_buff, i_len, l);\n   mem += i_len;\n   memSize -= i_len;\n\n   constexpr str_const out1(\", next: \");\n   Copy(mem, out1.begin(), out1.size(), l);\n   mem += out1.size();\n   memSize -= out1.size();\n\n   i_len = u32toa(i_to_a_buff, i_to_a_buff_size, iter->nextOffset);\n   Copy(mem, i_to_a_buff, i_len, l);\n   mem += i_len;\n   memSize -= i_len;\n\n   u32 pathLen = 0;\n\n   if (iter->location != 0) {\n    pathLen = strlen((const u8*)iter->location);\n   }\n\n\n   if (memSize < allocator->pageSize / 4 || memSize < (pathLen + pathLen / 4)) { // Drain occasiaonally\n    // Dump what's been written so far\n    mem = i_to_a_buff + i_to_a_buff_size;\n    callback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n    // Reset memory buffer\n    Set(debugPage, 0, debugSize, l);\n    i_to_a_buff = debugPage; // Used to convert numbers to strings\n    mem = i_to_a_buff + i_to_a_buff_size;\n    memSize = allocator->pageSize - i_to_a_buff_size;\n   }\n\n   constexpr str_const out_loc(\", location: \");\n   Copy(mem, out_loc.begin(), out_loc.size(), l);\n   mem += out_loc.size();\n   memSize -= out_loc.size();\n\n\n   if (iter->location == 0) {\n\n\n\n    Memory::Assert(pathLen == 0, \"On line: \" \"1583\" \", in file: \" \"./mem.cpp\", 1583, \"./mem.cpp\");\n\n    constexpr str_const out_loc(\"null\");\n    Copy(mem, out_loc.begin(), out_loc.size(), l);\n    mem += out_loc.size();\n    memSize -= out_loc.size();\n   }\n\n   else {\n    Memory::Assert(pathLen != 0, \"On line: \" \"1592\" \", in file: \" \"./mem.cpp\", 1592, \"./mem.cpp\");\n    Copy(mem, iter->location, pathLen, l);\n    mem += pathLen;\n    memSize -= pathLen;\n   }\n\n\n   constexpr str_const out4(\"\\n\");\n   Copy(mem, out4.begin(), out4.size(), l);\n   mem += out4.size();\n   memSize -= out4.size();\n  }\n\n  if (memSize != allocator->pageSize - i_to_a_buff_size) { // Drain if needed\n   // Dump what's been written so far\n   mem = i_to_a_buff + i_to_a_buff_size;\n   callback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n   // Reset memory buffer\n   Set(debugPage, 0, debugSize, l);\n   i_to_a_buff = debugPage; // Used to convert numbers to strings\n   mem = i_to_a_buff + i_to_a_buff_size;\n   memSize = allocator->pageSize - i_to_a_buff_size;\n  }\n }\n\n // Reset memory buffer\n Set(debugPage, 0, debugSize, l);\n i_to_a_buff = debugPage; // Used to convert numbers to strings\n mem = i_to_a_buff + i_to_a_buff_size;\n memSize = allocator->pageSize - i_to_a_buff_size;\n\n constexpr str_const newline(\"\\n\\t\");\n constexpr str_const isSet(\"0\");\n constexpr str_const notSet(\"-\");\n\n { // Draw a pretty graph\n  u32 numPages = allocator->size / allocator->pageSize;\n  u32* mask = (u32*)AllocatorPageMask(allocator);\n\n  constexpr str_const out5(\"\\nPage chart:\\n\\t\");\n  Copy(mem, out5.begin(), out5.size(), l);\n  mem += out5.size();\n  memSize -= out5.size();\n\n  for (u32 i = 0; i < numPages; ++i) {\n   u32 m = i / TrackingUnitSize;\n   u32 b = i % TrackingUnitSize;\n\n   bool set = mask[m] & (1 << b);\n   if (set) {\n    Copy(mem, isSet.begin(), isSet.size(), l);\n    mem += isSet.size();\n    memSize -= isSet.size();\n   }\n   else {\n    Copy(mem, notSet.begin(), notSet.size(), l);\n    mem += notSet.size();\n    memSize -= notSet.size();\n   }\n\n   if ((i + 1) % 80 == 0) {\n    Copy(mem, newline.begin(), newline.size(), l);\n    mem += newline.size();\n    memSize -= newline.size();\n   }\n\n   if (memSize < allocator->pageSize / 4) { // Drain occasiaonally\n    // Dump what's been written so far\n    mem = i_to_a_buff + i_to_a_buff_size;\n    callback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n    // Reset memory buffer\n    Set(debugPage, 0, debugSize, l);\n    i_to_a_buff = debugPage; // Used to convert numbers to strings\n    mem = i_to_a_buff + i_to_a_buff_size;\n    memSize = allocator->pageSize - i_to_a_buff_size;\n   }\n  }\n\n  if (memSize != allocator->pageSize - i_to_a_buff_size) { // Drain if needed\n   // Dump what's been written so far\n   mem = i_to_a_buff + i_to_a_buff_size;\n   callback(mem, (allocator->pageSize - i_to_a_buff_size) - memSize, userdata);\n\n   // Reset memory buffer\n   Set(debugPage, 0, debugSize, l);\n   i_to_a_buff = debugPage; // Used to convert numbers to strings\n   mem = i_to_a_buff + i_to_a_buff_size;\n   memSize = allocator->pageSize - i_to_a_buff_size;\n  }\n }\n\n allocator->ReleaseDbgPage();\n}\n\nvoid Memory::Debug::PageContent(Allocator* allocator, u32 page, WriteCallback callback, void* userdata) {\n u8* mem = (u8*)allocator + page * allocator->pageSize;\n u32 chunk = allocator->pageSize / 4; // Does not need to be a multiple of 4\n\n callback(mem, chunk, userdata);\n mem += chunk;\n callback(mem, chunk, userdata);\n mem += chunk;\n callback(mem, chunk, userdata);\n mem += chunk;\n callback(mem, allocator->pageSize - (allocator->pageSize / 4) * 3, userdata);\n}\n\n#pragma warning(default:6011)\n#pragma warning(default:28182)\n\n\n\n\n\n\n\n\nfloat FastSin(float x);\nfloat FastCos(float x);\n\ntemplate<typename T>\nstruct TVec2 {\n union {\n  struct {\n   T x;\n   T y;\n  };\n  T v[2];\n };\n inline TVec2() : x(T(0)), y(T(0)) { }\n inline TVec2(T _x, T _y) :\n  x(_x), y(_y) { }\n inline TVec2(T* fv) :\n  x(fv[0]), y(fv[1]) { }\n};\n\ntypedef TVec2<float> vec2;\ntypedef TVec2<int> ivec2;\ntypedef TVec2<unsigned int> uivec2;\n\nstruct vec3 {\n union {\n  struct {\n   float x;\n   float y;\n   float z;\n  };\n  float v[3];\n };\n inline vec3() : x(0.0f), y(0.0f), z(0.0f) { }\n inline vec3(float _x, float _y, float _z) :\n  x(_x), y(_y), z(_z) { }\n inline vec3(float* fv) :\n  x(fv[0]), y(fv[1]), z(fv[2]) { }\n};\n\nvec3 operator+(const vec3& l, const vec3& r);\nvec3 operator-(const vec3& l, const vec3& r);\nvec3 operator*(const vec3& v, float f);\nvec3 operator*(const vec3& l, const vec3& r);\nfloat dot(const vec3& l, const vec3& r);\nfloat lenSq(const vec3& v);\nfloat len(const vec3& v);\nvoid normalize(vec3& v);\nvec3 normalized(const vec3& v);\nvec3 project(const vec3& a, const vec3& b);\nvec3 reject(const vec3& a, const vec3& b);\nvec3 reflect(const vec3& a, const vec3& b);\nvec3 cross(const vec3& l, const vec3& r);\nvec3 lerp(const vec3& s, const vec3& e, float t);\nvec3 nlerp(const vec3& s, const vec3& e, float t);\nbool operator==(const vec3& l, const vec3& r);\nbool operator!=(const vec3& l, const vec3& r);\n\ntemplate<typename T>\nstruct TVec4 {\n union {\n  struct {\n   T x;\n   T y;\n   T z;\n   T w;\n  };\n  T v[4];\n };\n inline TVec4() : x((T)0), y((T)0), z((T)0), w((T)0) { }\n inline TVec4(T _x, T _y, T _z, T _w) :\n  x(_x), y(_y), z(_z), w(_w) { }\n inline TVec4(T* fv) :\n  x(fv[0]), y(fv[1]), z(fv[2]), w(fv[3]) { }\n};\n\ntypedef TVec4<float> vec4;\ntypedef TVec4<int> ivec4;\ntypedef TVec4<unsigned int> uivec4;\n\n\nstruct mat4 {\n union {\n  float v[16];\n  struct {\n   vec4 right;\n   vec4 up;\n   vec4 forward;\n   vec4 position;\n  };\n  struct {\n   //            row 1     row 2     row 3     row 4\n   /* column 1 */float xx; float xy; float xz; float xw;\n   /* column 2 */float yx; float yy; float yz; float yw;\n   /* column 3 */float zx; float zy; float zz; float zw;\n   /* column 4 */float tx; float ty; float tz; float tw;\n  };\n  struct {\n   float c0r0; float c0r1; float c0r2; float c0r3;\n   float c1r0; float c1r1; float c1r2; float c1r3;\n   float c2r0; float c2r1; float c2r2; float c2r3;\n   float c3r0; float c3r1; float c3r2; float c3r3;\n  };\n  struct {\n   float r0c0; float r1c0; float r2c0; float r3c0;\n   float r0c1; float r1c1; float r2c1; float r3c1;\n   float r0c2; float r1c2; float r2c2; float r3c2;\n   float r0c3; float r1c3; float r2c3; float r3c3;\n  };\n };\n inline mat4() :\n  xx(1), xy(0), xz(0), xw(0),\n  yx(0), yy(1), yz(0), yw(0),\n  zx(0), zy(0), zz(1), zw(0),\n  tx(0), ty(0), tz(0), tw(1) {}\n\n inline mat4(float* fv) :\n  xx(fv[0]), xy(fv[1]), xz(fv[2]), xw(fv[3]),\n  yx(fv[4]), yy(fv[5]), yz(fv[6]), yw(fv[7]),\n  zx(fv[8]), zy(fv[9]), zz(fv[10]), zw(fv[11]),\n  tx(fv[12]), ty(fv[13]), tz(fv[14]), tw(fv[15]) { }\n\n inline mat4(\n  float _00, float _01, float _02, float _03,\n  float _10, float _11, float _12, float _13,\n  float _20, float _21, float _22, float _23,\n  float _30, float _31, float _32, float _33) :\n  xx(_00), xy(_01), xz(_02), xw(_03),\n  yx(_10), yy(_11), yz(_12), yw(_13),\n  zx(_20), zy(_21), zz(_22), zw(_23),\n  tx(_30), ty(_31), tz(_32), tw(_33) { }\n}; // end mat4 struct\n\nbool operator==(const mat4& a, const mat4& b);\nbool operator!=(const mat4& a, const mat4& b);\nmat4 operator+(const mat4& a, const mat4& b);\nmat4 operator*(const mat4& m, float f);\nmat4 operator*(const mat4& a, const mat4& b);\nvec4 operator*(const mat4& m, const vec4& v);\nvec3 transformVector(const mat4& m, const vec3& v);\nvec3 transformPoint(const mat4& m, const vec3& v);\nvec3 transformPoint(const mat4& m, const vec3& v, float& w);\nvoid transpose(mat4& m);\nmat4 transposed(const mat4& m);\nfloat determinant(const mat4& m);\nmat4 adjugate(const mat4& m);\nmat4 inverse(const mat4& m);\nvoid invert(mat4& m);\nmat4 frustum(float l, float r, float b, float t, float n, float f);\nmat4 perspective(float fov, float aspect, float znear, float zfar);\nmat4 ortho(float l, float r, float b, float t, float n, float f);\nmat4 lookAt(const vec3& position, const vec3& target, const vec3& up);\n\nstruct quat {\n union {\n  struct {\n   float x;\n   float y;\n   float z;\n   float w;\n  };\n  struct {\n   vec3 vector;\n   float scalar;\n  };\n  float v[4];\n };\n\n inline quat() :\n  x(0), y(0), z(0), w(1) { }\n inline quat(float _x, float _y, float _z, float _w) :\n  x(_x), y(_y), z(_z), w(_w) {}\n};\n\nquat angleAxis(float angle, const vec3& axis);\nquat fromTo(const vec3& from, const vec3& to);\nvec3 getAxis(const quat& quat);\nfloat getAngle(const quat& quat);\nquat operator+(const quat& a, const quat& b);\nquat operator-(const quat& a, const quat& b);\nquat operator*(const quat& a, float b);\nquat operator-(const quat& q);\nbool operator==(const quat& left, const quat& right);\nbool operator!=(const quat& a, const quat& b);\nbool sameOrientation(const quat& left, const quat& right);\nfloat dot(const quat& a, const quat& b);\nfloat lenSq(const quat& q);\nfloat len(const quat& q);\nvoid normalize(quat& q);\nquat normalized(const quat& q);\nquat conjugate(const quat& q);\nquat inverse(const quat& q);\nquat operator*(const quat& Q1, const quat& Q2);\nvec3 operator*(const quat& q, const vec3& v);\nquat mix(const quat& from, const quat& to, float t);\nquat nlerp(const quat& from, const quat& to, float t);\nquat operator^(const quat& q, float f);\nquat operator^(const quat& q, float f);\nquat slerp(const quat& start, const quat& end, float t);\nquat lookRotation(const vec3& direcion, const vec3& up);\nmat4 quatToMat4(const quat& q);\nquat mat4ToQuat(const mat4& m);\n\nfloat Sqrtf(const float& n) {\n if (n == 0.0f) {\n  return 0.0f;\n }\n\n int i = 0x2035AD0C + (*(int*)&n >> 1);\n return n / *(float*)&i + *(float*)&i * 0.25f;\n}\n\nfloat Fabsf(const float& f) {\n if (f < 0.0f) {\n  return f * -1.0f;\n }\n return f;\n}\n\ndouble Sin(const double& x) {\n int i = 1;\n double cur = x;\n double acc = 1;\n double fact = 1;\n double pow = x;\n while (acc > .00000001 && i < 100) {\n  fact *= ((2 * i) * (2 * i + 1));\n  pow *= -1 * x * x;\n  acc = pow / fact;\n  if (acc < 0.0) { // fabs\n   acc *= -1.0;\n  }\n  cur += acc;\n  i++;\n }\n return cur;\n}\n\n\n\n\n\n\ninline float Hill(float x)\n{\n const float a0 = 1.0f;\n const float a2 = 2.0f / (3.1415926535f) - 12.0f / ((3.1415926535f) * (3.1415926535f));\n const float a3 = 16.0f / ((3.1415926535f) * (3.1415926535f) * (3.1415926535f)) - 4.0f / ((3.1415926535f) * (3.1415926535f));\n const float xx = x * x;\n const float xxx = xx * x;\n\n return a0 + a2 * xx + a3 * xxx;\n}\n\nfloat FastSin(float x)\n{\n // wrap x within [0, TWO_PI)\n const float a = x * (1.0f / (2.0f * (3.1415926535f)));\n x -= static_cast<int>(a) * (2.0f * (3.1415926535f));\n if (x < 0.0f)\n  x += (2.0f * (3.1415926535f));\n\n // 4 pieces of hills\n if (x < (0.5f * (3.1415926535f)))\n  return Hill((0.5f * (3.1415926535f)) - x);\n else if (x < (3.1415926535f))\n  return Hill(x - (0.5f * (3.1415926535f)));\n else if (x < 3.0f * (0.5f * (3.1415926535f)))\n  return -Hill(3.0f * (0.5f * (3.1415926535f)) - x);\n else\n  return -Hill(x - 3.0f * (0.5f * (3.1415926535f)));\n}\n\nfloat FastCos(float x)\n{\n return FastSin(x + (0.5f * (3.1415926535f)));\n}\n\nfloat Tan(const float& d) {\n return FastSin(d) / FastCos(d);\n}\n\n\nvec3 operator+(const vec3& l, const vec3& r) {\n return vec3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\n\nvec3 operator-(const vec3& l, const vec3& r) {\n return vec3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\n\nvec3 operator*(const vec3& v, float f) {\n return vec3(v.x * f, v.y * f, v.z * f);\n}\n\nvec3 operator*(const vec3& l, const vec3& r) {\n return vec3(l.x * r.x, l.y * r.y, l.z * r.z);\n}\n\nfloat dot(const vec3& l, const vec3& r) {\n return l.x * r.x + l.y * r.y + l.z * r.z;\n}\n\nfloat lenSq(const vec3& v) {\n return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nfloat len(const vec3& v) {\n float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n if (lenSq < 0.000001f) {\n  return 0.0f;\n }\n return Sqrtf(lenSq);\n}\n\nvoid normalize(vec3& v) {\n float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n if (lenSq < 0.000001f) {\n  return;\n }\n float invLen = 1.0f / Sqrtf(lenSq);\n\n v.x *= invLen;\n v.y *= invLen;\n v.z *= invLen;\n}\n\nvec3 normalized(const vec3& v) {\n float lenSq = v.x * v.x + v.y * v.y + v.z * v.z;\n if (lenSq < 0.000001f) {\n  return v;\n }\n float invLen = 1.0f / Sqrtf(lenSq);\n\n return vec3(\n  v.x * invLen,\n  v.y * invLen,\n  v.z * invLen\n );\n}\n\nvec3 project(const vec3& a, const vec3& b) {\n float magBSq = len(b);\n if (magBSq < 0.000001f) {\n  return vec3();\n }\n float scale = dot(a, b) / magBSq;\n return b * scale;\n}\n\nvec3 reject(const vec3& a, const vec3& b) {\n vec3 projection = project(a, b);\n return a - projection;\n}\n\nvec3 reflect(const vec3& a, const vec3& b) {\n float magBSq = len(b);\n if (magBSq < 0.000001f) {\n  return vec3();\n }\n float scale = dot(a, b) / magBSq;\n vec3 proj2 = b * (scale * 2);\n return a - proj2;\n}\n\nvec3 cross(const vec3& l, const vec3& r) {\n return vec3(\n  l.y * r.z - l.z * r.y,\n  l.z * r.x - l.x * r.z,\n  l.x * r.y - l.y * r.x\n );\n}\n\nvec3 lerp(const vec3& s, const vec3& e, float t) {\n return vec3(\n  s.x + (e.x - s.x) * t,\n  s.y + (e.y - s.y) * t,\n  s.z + (e.z - s.z) * t\n );\n}\n\nvec3 nlerp(const vec3& s, const vec3& e, float t) {\n vec3 linear(\n  s.x + (e.x - s.x) * t,\n  s.y + (e.y - s.y) * t,\n  s.z + (e.z - s.z) * t\n );\n return normalized(linear);\n}\n\nbool operator==(const vec3& l, const vec3& r) {\n vec3 diff(l - r);\n return lenSq(diff) < 0.000001f;\n}\n\nbool operator!=(const vec3& l, const vec3& r) {\n return !(l == r);\n}\n\nbool operator==(const mat4& a, const mat4& b) {\n for (int i = 0; i < 16; ++i) {\n  if (Fabsf(a.v[i] - b.v[i]) > 0.000001f) {\n   return false;\n  }\n }\n return true;\n}\n\nbool operator!=(const mat4& a, const mat4& b) {\n return !(a == b);\n}\n\nmat4 operator+(const mat4& a, const mat4& b) {\n return mat4(\n  a.xx + b.xx, a.xy + b.xy, a.xz + b.xz, a.xw + b.xw,\n  a.yx + b.yx, a.yy + b.yy, a.yz + b.yz, a.yw + b.yw,\n  a.zx + b.zx, a.zy + b.zy, a.zz + b.zz, a.zw + b.zw,\n  a.tx + b.tx, a.ty + b.ty, a.tz + b.tz, a.tw + b.tw\n );\n}\n\nmat4 operator*(const mat4& m, float f) {\n return mat4(\n  m.xx * f, m.xy * f, m.xz * f, m.xw * f,\n  m.yx * f, m.yy * f, m.yz * f, m.yw * f,\n  m.zx * f, m.zy * f, m.zz * f, m.zw * f,\n  m.tx * f, m.ty * f, m.tz * f, m.tw * f\n );\n}\n\n\n\n\n\n\n\nmat4 operator*(const mat4& a, const mat4& b) {\n return mat4(\n  a.v[0 * 4 + 0] * b.v[0 * 4 + 0] + a.v[1 * 4 + 0] * b.v[0 * 4 + 1] + a.v[2 * 4 + 0] * b.v[0 * 4 + 2] + a.v[3 * 4 + 0] * b.v[0 * 4 + 3], a.v[0 * 4 + 1] * b.v[0 * 4 + 0] + a.v[1 * 4 + 1] * b.v[0 * 4 + 1] + a.v[2 * 4 + 1] * b.v[0 * 4 + 2] + a.v[3 * 4 + 1] * b.v[0 * 4 + 3], a.v[0 * 4 + 2] * b.v[0 * 4 + 0] + a.v[1 * 4 + 2] * b.v[0 * 4 + 1] + a.v[2 * 4 + 2] * b.v[0 * 4 + 2] + a.v[3 * 4 + 2] * b.v[0 * 4 + 3], a.v[0 * 4 + 3] * b.v[0 * 4 + 0] + a.v[1 * 4 + 3] * b.v[0 * 4 + 1] + a.v[2 * 4 + 3] * b.v[0 * 4 + 2] + a.v[3 * 4 + 3] * b.v[0 * 4 + 3], // Column 0\n  a.v[0 * 4 + 0] * b.v[1 * 4 + 0] + a.v[1 * 4 + 0] * b.v[1 * 4 + 1] + a.v[2 * 4 + 0] * b.v[1 * 4 + 2] + a.v[3 * 4 + 0] * b.v[1 * 4 + 3], a.v[0 * 4 + 1] * b.v[1 * 4 + 0] + a.v[1 * 4 + 1] * b.v[1 * 4 + 1] + a.v[2 * 4 + 1] * b.v[1 * 4 + 2] + a.v[3 * 4 + 1] * b.v[1 * 4 + 3], a.v[0 * 4 + 2] * b.v[1 * 4 + 0] + a.v[1 * 4 + 2] * b.v[1 * 4 + 1] + a.v[2 * 4 + 2] * b.v[1 * 4 + 2] + a.v[3 * 4 + 2] * b.v[1 * 4 + 3], a.v[0 * 4 + 3] * b.v[1 * 4 + 0] + a.v[1 * 4 + 3] * b.v[1 * 4 + 1] + a.v[2 * 4 + 3] * b.v[1 * 4 + 2] + a.v[3 * 4 + 3] * b.v[1 * 4 + 3], // Column 1\n  a.v[0 * 4 + 0] * b.v[2 * 4 + 0] + a.v[1 * 4 + 0] * b.v[2 * 4 + 1] + a.v[2 * 4 + 0] * b.v[2 * 4 + 2] + a.v[3 * 4 + 0] * b.v[2 * 4 + 3], a.v[0 * 4 + 1] * b.v[2 * 4 + 0] + a.v[1 * 4 + 1] * b.v[2 * 4 + 1] + a.v[2 * 4 + 1] * b.v[2 * 4 + 2] + a.v[3 * 4 + 1] * b.v[2 * 4 + 3], a.v[0 * 4 + 2] * b.v[2 * 4 + 0] + a.v[1 * 4 + 2] * b.v[2 * 4 + 1] + a.v[2 * 4 + 2] * b.v[2 * 4 + 2] + a.v[3 * 4 + 2] * b.v[2 * 4 + 3], a.v[0 * 4 + 3] * b.v[2 * 4 + 0] + a.v[1 * 4 + 3] * b.v[2 * 4 + 1] + a.v[2 * 4 + 3] * b.v[2 * 4 + 2] + a.v[3 * 4 + 3] * b.v[2 * 4 + 3], // Column 2\n  a.v[0 * 4 + 0] * b.v[3 * 4 + 0] + a.v[1 * 4 + 0] * b.v[3 * 4 + 1] + a.v[2 * 4 + 0] * b.v[3 * 4 + 2] + a.v[3 * 4 + 0] * b.v[3 * 4 + 3], a.v[0 * 4 + 1] * b.v[3 * 4 + 0] + a.v[1 * 4 + 1] * b.v[3 * 4 + 1] + a.v[2 * 4 + 1] * b.v[3 * 4 + 2] + a.v[3 * 4 + 1] * b.v[3 * 4 + 3], a.v[0 * 4 + 2] * b.v[3 * 4 + 0] + a.v[1 * 4 + 2] * b.v[3 * 4 + 1] + a.v[2 * 4 + 2] * b.v[3 * 4 + 2] + a.v[3 * 4 + 2] * b.v[3 * 4 + 3], a.v[0 * 4 + 3] * b.v[3 * 4 + 0] + a.v[1 * 4 + 3] * b.v[3 * 4 + 1] + a.v[2 * 4 + 3] * b.v[3 * 4 + 2] + a.v[3 * 4 + 3] * b.v[3 * 4 + 3] // Column 3\n );\n}\n\n\n\n\n\n\n\nvec4 operator*(const mat4& m, const vec4& v) {\n return vec4(\n  v.x * m.v[0 * 4 + 0] + v.y * m.v[1 * 4 + 0] + v.z * m.v[2 * 4 + 0] + v.w * m.v[3 * 4 + 0],\n  v.x * m.v[0 * 4 + 1] + v.y * m.v[1 * 4 + 1] + v.z * m.v[2 * 4 + 1] + v.w * m.v[3 * 4 + 1],\n  v.x * m.v[0 * 4 + 2] + v.y * m.v[1 * 4 + 2] + v.z * m.v[2 * 4 + 2] + v.w * m.v[3 * 4 + 2],\n  v.x * m.v[0 * 4 + 3] + v.y * m.v[1 * 4 + 3] + v.z * m.v[2 * 4 + 3] + v.w * m.v[3 * 4 + 3]\n );\n}\n\nvec3 transformVector(const mat4& m, const vec3& v) {\n return vec3(\n  v.x * m.v[0 * 4 + 0] + v.y * m.v[1 * 4 + 0] + v.z * m.v[2 * 4 + 0] + 0.0f * m.v[3 * 4 + 0],\n  v.x * m.v[0 * 4 + 1] + v.y * m.v[1 * 4 + 1] + v.z * m.v[2 * 4 + 1] + 0.0f * m.v[3 * 4 + 1],\n  v.x * m.v[0 * 4 + 2] + v.y * m.v[1 * 4 + 2] + v.z * m.v[2 * 4 + 2] + 0.0f * m.v[3 * 4 + 2]\n );\n}\n\nvec3 transformPoint(const mat4& m, const vec3& v) {\n return vec3(\n  v.x * m.v[0 * 4 + 0] + v.y * m.v[1 * 4 + 0] + v.z * m.v[2 * 4 + 0] + 1.0f * m.v[3 * 4 + 0],\n  v.x * m.v[0 * 4 + 1] + v.y * m.v[1 * 4 + 1] + v.z * m.v[2 * 4 + 1] + 1.0f * m.v[3 * 4 + 1],\n  v.x * m.v[0 * 4 + 2] + v.y * m.v[1 * 4 + 2] + v.z * m.v[2 * 4 + 2] + 1.0f * m.v[3 * 4 + 2]\n );\n}\n\nvec3 transformPoint(const mat4& m, const vec3& v, float& w) {\n float _w = w;\n w = v.x * m.v[0 * 4 + 3] + v.y * m.v[1 * 4 + 3] + v.z * m.v[2 * 4 + 3] + _w * m.v[3 * 4 + 3];\n\n return vec3(\n  v.x * m.v[0 * 4 + 0] + v.y * m.v[1 * 4 + 0] + v.z * m.v[2 * 4 + 0] + _w * m.v[3 * 4 + 0],\n  v.x * m.v[0 * 4 + 1] + v.y * m.v[1 * 4 + 1] + v.z * m.v[2 * 4 + 1] + _w * m.v[3 * 4 + 1],\n  v.x * m.v[0 * 4 + 2] + v.y * m.v[1 * 4 + 2] + v.z * m.v[2 * 4 + 2] + _w * m.v[3 * 4 + 2]\n );\n}\n\n\n\n\nvoid transpose(mat4& m) {\n {float t = m.yx; m.yx = m.xy; m.xy = t; };\n {float t = m.zx; m.zx = m.xz; m.xz = t; };\n {float t = m.tx; m.tx = m.xw; m.xw = t; };\n {float t = m.zy; m.zy = m.yz; m.yz = t; };\n {float t = m.ty; m.ty = m.yw; m.yw = t; };\n {float t = m.tz; m.tz = m.zw; m.zw = t; };\n}\n\nmat4 transposed(const mat4& m) {\n return mat4(\n  m.xx, m.yx, m.zx, m.tx,\n  m.xy, m.yy, m.zy, m.ty,\n  m.xz, m.yz, m.zz, m.tz,\n  m.xw, m.yw, m.zw, m.tw\n );\n}\n\n\n\n\n\n\nfloat determinant(const mat4& m) {\n return m.v[0] * (m.v[1 * 4 + 1] * (m.v[2 * 4 + 2] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[2 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 2]))\n  - m.v[4] * (m.v[0 * 4 + 1] * (m.v[2 * 4 + 2] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[2 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 2]))\n  + m.v[8] * (m.v[0 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[1 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 2]))\n  - m.v[12] * (m.v[0 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 2]) - m.v[1 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 2]) + m.v[2 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 2]));\n}\n\nmat4 adjugate(const mat4& m) {\n // Cofactor(M[i, j]) = Minor(M[i, j]] * pow(-1, i + j)\n mat4 cofactor;\n\n cofactor.v[0] = (m.v[1 * 4 + 1] * (m.v[2 * 4 + 2] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[2 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 2]));\n cofactor.v[1] = -(m.v[1 * 4 + 0] * (m.v[2 * 4 + 2] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[2 * 4 + 0] * (m.v[1 * 4 + 2] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 0] * (m.v[1 * 4 + 2] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 2]));\n cofactor.v[2] = (m.v[1 * 4 + 0] * (m.v[2 * 4 + 1] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 1]) - m.v[2 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 1]) + m.v[3 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 1]));\n cofactor.v[3] = -(m.v[1 * 4 + 0] * (m.v[2 * 4 + 1] * m.v[3 * 4 + 2] - m.v[2 * 4 + 2] * m.v[3 * 4 + 1]) - m.v[2 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[3 * 4 + 2] - m.v[1 * 4 + 2] * m.v[3 * 4 + 1]) + m.v[3 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[2 * 4 + 2] - m.v[1 * 4 + 2] * m.v[2 * 4 + 1]));\n\n cofactor.v[4] = -(m.v[0 * 4 + 1] * (m.v[2 * 4 + 2] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[2 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 2]));\n cofactor.v[5] = (m.v[0 * 4 + 0] * (m.v[2 * 4 + 2] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[2 * 4 + 0] * (m.v[0 * 4 + 2] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 0] * (m.v[0 * 4 + 2] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 2]));\n cofactor.v[6] = -(m.v[0 * 4 + 0] * (m.v[2 * 4 + 1] * m.v[3 * 4 + 3] - m.v[2 * 4 + 3] * m.v[3 * 4 + 1]) - m.v[2 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 1]) + m.v[3 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 1]));\n cofactor.v[7] = (m.v[0 * 4 + 0] * (m.v[2 * 4 + 1] * m.v[3 * 4 + 2] - m.v[2 * 4 + 2] * m.v[3 * 4 + 1]) - m.v[2 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[3 * 4 + 2] - m.v[0 * 4 + 2] * m.v[3 * 4 + 1]) + m.v[3 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[2 * 4 + 2] - m.v[0 * 4 + 2] * m.v[2 * 4 + 1]));\n\n cofactor.v[8] = (m.v[0 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[1 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 2]));\n cofactor.v[9] = -(m.v[0 * 4 + 0] * (m.v[1 * 4 + 2] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 2]) - m.v[1 * 4 + 0] * (m.v[0 * 4 + 2] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 2]) + m.v[3 * 4 + 0] * (m.v[0 * 4 + 2] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 2]));\n cofactor.v[10] = (m.v[0 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[3 * 4 + 3] - m.v[1 * 4 + 3] * m.v[3 * 4 + 1]) - m.v[1 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[3 * 4 + 3] - m.v[0 * 4 + 3] * m.v[3 * 4 + 1]) + m.v[3 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 1]));\n cofactor.v[11] = -(m.v[0 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[3 * 4 + 2] - m.v[1 * 4 + 2] * m.v[3 * 4 + 1]) - m.v[1 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[3 * 4 + 2] - m.v[0 * 4 + 2] * m.v[3 * 4 + 1]) + m.v[3 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[1 * 4 + 2] - m.v[0 * 4 + 2] * m.v[1 * 4 + 1]));\n\n cofactor.v[12] = -(m.v[0 * 4 + 1] * (m.v[1 * 4 + 2] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 2]) - m.v[1 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 2]) + m.v[2 * 4 + 1] * (m.v[0 * 4 + 2] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 2]));\n cofactor.v[13] = (m.v[0 * 4 + 0] * (m.v[1 * 4 + 2] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 2]) - m.v[1 * 4 + 0] * (m.v[0 * 4 + 2] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 2]) + m.v[2 * 4 + 0] * (m.v[0 * 4 + 2] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 2]));\n cofactor.v[14] = -(m.v[0 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[2 * 4 + 3] - m.v[1 * 4 + 3] * m.v[2 * 4 + 1]) - m.v[1 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[2 * 4 + 3] - m.v[0 * 4 + 3] * m.v[2 * 4 + 1]) + m.v[2 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[1 * 4 + 3] - m.v[0 * 4 + 3] * m.v[1 * 4 + 1]));\n cofactor.v[15] = (m.v[0 * 4 + 0] * (m.v[1 * 4 + 1] * m.v[2 * 4 + 2] - m.v[1 * 4 + 2] * m.v[2 * 4 + 1]) - m.v[1 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[2 * 4 + 2] - m.v[0 * 4 + 2] * m.v[2 * 4 + 1]) + m.v[2 * 4 + 0] * (m.v[0 * 4 + 1] * m.v[1 * 4 + 2] - m.v[0 * 4 + 2] * m.v[1 * 4 + 1]));\n\n return transposed(cofactor);\n}\n\nmat4 inverse(const mat4& m) {\n float det = determinant(m);\n\n if (det == 0.0f) { // Epsilon check would need to be REALLY small\n  return mat4();\n }\n mat4 adj = adjugate(m);\n\n return adj * (1.0f / det);\n}\n\nvoid invert(mat4& m) {\n float det = determinant(m);\n\n if (det == 0.0f) {\n  m = mat4();\n  return;\n }\n\n m = adjugate(m) * (1.0f / det);\n}\n\nmat4 frustum(float l, float r, float b, float t, float n, float f) {\n if (l == r || t == b || n == f) {\n  return mat4(); // Error\n }\n return mat4(\n  (2.0f * n) / (r - l), 0, 0, 0,\n  0, (2.0f * n) / (t - b), 0, 0,\n  (r + l) / (r - l), (t + b) / (t - b), (-(f + n)) / (f - n), -1,\n  0, 0, (-2 * f * n) / (f - n), 0\n );\n}\n\nmat4 perspective(float fov, float aspect, float znear, float zfar) {\n float ymax = znear * (float)Tan(fov * 3.14159265359f / 360.0f);\n float xmax = ymax * aspect;\n\n return frustum(-xmax, xmax, -ymax, ymax, znear, zfar);\n}\n\nmat4 ortho(float l, float r, float b, float t, float n, float f) {\n if (l == r || t == b || n == f) {\n  return mat4(); // Error\n }\n return mat4(\n  2.0f / (r - l), 0, 0, 0,\n  0, 2.0f / (t - b), 0, 0,\n  0, 0, -2.0f / (f - n), 0,\n  -((r + l) / (r - l)), -((t + b) / (t - b)), -((f + n) / (f - n)), 1\n );\n}\n\nmat4 lookAt(const vec3& position, const vec3& target, const vec3& up) {\n // Remember, forward is negative z\n vec3 f = normalized(target - position) * -1.0f;\n vec3 r = cross(up, f); // Right handed\n if (r == vec3(0, 0, 0)) {\n  return mat4(); // Error\n }\n normalize(r);\n vec3 u = normalized(cross(f, r)); // Right handed\n\n vec3 t = vec3(\n  -dot(r, position),\n  -dot(u, position),\n  -dot(f, position)\n );\n\n return mat4(\n  // Transpose upper 3x3 matrix to invert it\n  r.x, u.x, f.x, 0,\n  r.y, u.y, f.y, 0,\n  r.z, u.z, f.z, 0,\n  t.x, t.y, t.z, 1\n );\n}\n\nquat angleAxis(float angle, const vec3& axis) {\n vec3 norm = normalized(axis);\n float s = FastSin(angle * 0.5f);\n\n return quat(\n  norm.x * s,\n  norm.y * s,\n  norm.z * s,\n  FastCos(angle * 0.5f)\n );\n}\n\nquat fromTo(const vec3& from, const vec3& to) {\n vec3 f = normalized(from);\n vec3 t = normalized(to);\n\n if (f == t) {\n  return quat();\n }\n else if (f == t * -1.0f) {\n  vec3 ortho = vec3(1, 0, 0);\n  if (Fabsf(f.y) < Fabsf(f.x)) {\n   ortho = vec3(0, 1, 0);\n  }\n  if (Fabsf(f.z) < Fabsf(f.y) && Fabsf(f.z) < Fabsf(f.x)) {\n   ortho = vec3(0, 0, 1);\n  }\n\n  vec3 axis = normalized(cross(f, ortho));\n  return quat(axis.x, axis.y, axis.z, 0);\n }\n\n vec3 half = normalized(f + t);\n vec3 axis = cross(f, half);\n\n return quat(\n  axis.x,\n  axis.y,\n  axis.z,\n  dot(f, half)\n );\n}\n\nvec3 getAxis(const quat& quat) {\n return normalized(vec3(quat.x, quat.y, quat.z));\n}\n\nfloat getAngle(const quat& quat) {\n return 2.0f * (1.0f / FastCos(quat.w));\n}\n\nquat operator+(const quat& a, const quat& b) {\n return quat(\n  a.x + b.x,\n  a.y + b.y,\n  a.z + b.z,\n  a.w + b.w\n );\n}\n\nquat operator-(const quat& a, const quat& b) {\n return quat(\n  a.x - b.x,\n  a.y - b.y,\n  a.z - b.z,\n  a.w - b.w\n );\n}\n\nquat operator*(const quat& a, float b) {\n return quat(\n  a.x * b,\n  a.y * b,\n  a.z * b,\n  a.w * b\n );\n}\n\nquat operator-(const quat& q) {\n return quat(\n  -q.x,\n  -q.y,\n  -q.z,\n  -q.w\n );\n}\n\nbool operator==(const quat& left, const quat& right) {\n return (Fabsf(left.x - right.x) <= 0.000001f &&\n  Fabsf(left.y - right.y) <= 0.000001f &&\n  Fabsf(left.z - right.z) <= 0.000001f &&\n  Fabsf(left.w - left.w) <= 0.000001f);\n}\n\nbool operator!=(const quat& a, const quat& b) {\n return !(a == b);\n}\n\nbool sameOrientation(const quat& left, const quat& right) {\n return (Fabsf(left.x - right.x) <= 0.000001f && Fabsf(left.y - right.y) <= 0.000001f &&\n  Fabsf(left.z - right.z) <= 0.000001f && Fabsf(left.w - left.w) <= 0.000001f)\n  || (Fabsf(left.x + right.x) <= 0.000001f && Fabsf(left.y + right.y) <= 0.000001f &&\n   Fabsf(left.z + right.z) <= 0.000001f && Fabsf(left.w + left.w) <= 0.000001f);\n}\n\nfloat dot(const quat& a, const quat& b) {\n return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}\n\nfloat lenSq(const quat& q) {\n return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n}\n\nfloat len(const quat& q) {\n float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n if (lenSq < 0.000001f) {\n  return 0.0f;\n }\n return Sqrtf(lenSq);\n}\n\nvoid normalize(quat& q) {\n float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n if (lenSq < 0.000001f) {\n  return;\n }\n float i_len = 1.0f / Sqrtf(lenSq);\n\n q.x *= i_len;\n q.y *= i_len;\n q.z *= i_len;\n q.w *= i_len;\n}\n\nquat normalized(const quat& q) {\n float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n if (lenSq < 0.000001f) {\n  return quat();\n }\n float i_len = 1.0f / Sqrtf(lenSq);\n\n return quat(\n  q.x * i_len,\n  q.y * i_len,\n  q.z * i_len,\n  q.w * i_len\n );\n}\n\nquat conjugate(const quat& q) {\n return quat(\n  -q.x,\n  -q.y,\n  -q.z,\n  q.w\n );\n}\n\nquat inverse(const quat& q) {\n float lenSq = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n if (lenSq < 0.000001f) {\n  return quat();\n }\n float recip = 1.0f / lenSq;\n\n // conjugate / norm\n return quat(\n  -q.x * recip,\n  -q.y * recip,\n  -q.z * recip,\n  q.w * recip\n );\n}\n\n\nquat operator*(const quat& Q1, const quat& Q2) {\n return quat(\n  Q2.x * Q1.w + Q2.y * Q1.z - Q2.z * Q1.y + Q2.w * Q1.x,\n  -Q2.x * Q1.z + Q2.y * Q1.w + Q2.z * Q1.x + Q2.w * Q1.y,\n  Q2.x * Q1.y - Q2.y * Q1.x + Q2.z * Q1.w + Q2.w * Q1.z,\n  -Q2.x * Q1.x - Q2.y * Q1.y - Q2.z * Q1.z + Q2.w * Q1.w\n );\n}\nvec3 operator*(const quat& q, const vec3& v) {\n return q.vector * 2.0f * dot(q.vector, v) +\n  v * (q.scalar * q.scalar - dot(q.vector, q.vector)) +\n  cross(q.vector, v) * 2.0f * q.scalar;\n}\n\nquat mix(const quat& from, const quat& to, float t) {\n return from * (1.0f - t) + to * t;\n}\n\nquat nlerp(const quat& from, const quat& to, float t) {\n return normalized(from + (to - from) * t);\n}\n\nquat operator^(const quat& q, float f) {\n float angle = 2.0f * (1.0f / FastCos(q.scalar));\n vec3 axis = normalized(q.vector);\n\n float halfCos = FastCos(f * angle * 0.5f);\n float halfSin = FastSin(f * angle * 0.5f);\n\n return quat(\n  axis.x * halfSin,\n  axis.y * halfSin,\n  axis.z * halfSin,\n  halfCos\n );\n}\n\nquat slerp(const quat& start, const quat& end, float t) {\n if (Fabsf(dot(start, end)) > 1.0f - 0.000001f) {\n  return nlerp(start, end, t);\n }\n\n return normalized(((inverse(start) * end) ^ t) * start);\n}\n\nquat lookRotation(const vec3& direcion, const vec3& up) {\n // Find orthonormal basis vectors\n vec3 f = normalized(direcion);\n vec3 u = normalized(up);\n vec3 r = cross(u, f);\n u = cross(f, r);\n\n // From world forward to object forward\n quat f2d = fromTo(vec3(0, 0, 1), f);\n\n // what direction is the new object up?\n vec3 objectUp = f2d * vec3(0, 1, 0);\n // From object up to desired up\n quat u2u = fromTo(objectUp, u);\n\n // Rotate to forward direction first, then twist to correct up\n quat result = f2d * u2u;\n // Don\u00ef\u00bf\u00bdt forget to normalize the result\n return normalized(result);\n}\n\nmat4 quatToMat4(const quat& q) {\n vec3 r = q * vec3(1, 0, 0);\n vec3 u = q * vec3(0, 1, 0);\n vec3 f = q * vec3(0, 0, 1);\n\n return mat4(\n  r.x, r.y, r.z, 0,\n  u.x, u.y, u.z, 0,\n  f.x, f.y, f.z, 0,\n  0, 0, 0, 1\n );\n}\n\nquat mat4ToQuat(const mat4& m) {\n vec3 up = normalized(vec3(m.up.x, m.up.y, m.up.z));\n vec3 forward = normalized(vec3(m.forward.x, m.forward.y, m.forward.z));\n vec3 right = cross(up, forward);\n up = cross(forward, right);\n\n return lookRotation(forward, up);\n}\n\nMemory::Allocator* wasmGraphics_GlobalAllocator = 0;\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void wasmGraphics_SetGlobalAllocator(Memory::Allocator* alloc) {\n    wasmGraphics_GlobalAllocator = alloc;\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void* wasmGraphics_AllocateMem(u32 bytes) {\n return wasmGraphics_GlobalAllocator->Allocate(bytes, 0, \"JS bridge\");\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void wasmGraphics_ReleaseMem(void* mem) {\n    wasmGraphics_GlobalAllocator->Release(mem, \"JS bridge\");\n}\n\ntypedef void* (*fpWasmGraphicsAllocateMem)(u32 bytes);\ntypedef void (*fpWasmGraphicsReleaseMem)(void* mem);\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" fpWasmGraphicsAllocateMem wasmGraphics_GetAlloceFunction() {\n    return wasmGraphics_AllocateMem;\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" fpWasmGraphicsReleaseMem wasmGraphics_GetReleaseFunction() {\n    return wasmGraphics_ReleaseMem;\n}\n\n\n\n\nstruct TextureFile {\n unsigned int width;\n unsigned int height;\n unsigned int channels;\n void* data;\n};\n\nstruct MeshFile {\n unsigned int numPos;\n unsigned int numNrm;\n unsigned int numTex;\n unsigned int numTan;\n float* pos;\n float* nrm;\n float* tex;\n float* tan;\n};\n\nstruct TextFile {\n char* text;\n unsigned int length;\n};\n\ntypedef void (*OnMeshLoaded)(const char* path, MeshFile* file);\ntypedef void (*OnTextureLoaded)(const char* path, TextureFile* file);\ntypedef void (*OnTextFileLoaded)(const char* path, TextFile* file);\n\nvoid LoadMesh(const char* path, OnMeshLoaded onMeshLoad);\nvoid LoadTexture(const char* path, OnTextureLoaded onTextureLoad);\nvoid LoadText(const char* path, OnTextFileLoaded onTextLoad);\n\nvoid ReleaseMesh(MeshFile* file);\nvoid ReleaseTexture(TextureFile* file);\nvoid ReleaseText(TextFile* file);\n\n\nnamespace Internal {\n void CalculateTangentArray(unsigned int vertexCount, vec3* vertex, vec3* normal,\n  vec2* texcoord, vec3* outTangent)\n {\n  vec3* tan1 = (vec3*)wasmGraphics_AllocateMem(vertexCount * 2 * sizeof(vec3));\n  vec3* tan2 = tan1 + vertexCount;\n\n  Memory::Set(tan1, 0, vertexCount * 2 * sizeof(vec3), \"On line: \" \"11\" \", in file: \" \"./FileLoadersWASM.cpp\");\n\n  for (long a = 0; a < vertexCount; a += 3)\n  {\n   vec3 v1 = vertex[a + 0];\n   vec3 v2 = vertex[a + 1];\n   vec3 v3 = vertex[a + 2];\n\n   vec2 w1 = texcoord[a + 0];\n   vec2 w2 = texcoord[a + 1];\n   vec2 w3 = texcoord[a + 2];\n\n   float x1 = v2.x - v1.x;\n   float x2 = v3.x - v1.x;\n   float y1 = v2.y - v1.y;\n   float y2 = v3.y - v1.y;\n   float z1 = v2.z - v1.z;\n   float z2 = v3.z - v1.z;\n\n   float s1 = w2.x - w1.x;\n   float s2 = w3.x - w1.x;\n   float t1 = w2.y - w1.y;\n   float t2 = w3.y - w1.y;\n\n   float r = 1.0f / (s1 * t2 - s2 * t1);\n   vec3 sdir((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r,\n    (t2 * z1 - t1 * z2) * r);\n   vec3 tdir((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r,\n    (s1 * z2 - s2 * z1) * r);\n\n   tan1[a + 0] = tan1[a + 0] + sdir;\n   tan1[a + 1] = tan1[a + 1] + sdir;\n   tan1[a + 2] = tan1[a + 2] + sdir;\n\n   tan2[a + 0] = tan2[a + 0] + tdir;\n   tan2[a + 1] = tan2[a + 1] + tdir;\n   tan2[a + 2] = tan2[a + 2] + tdir;\n  }\n\n  for (long a = 0; a < vertexCount; a++) {\n   vec3 n = normal[a];\n   vec3 t = tan1[a];\n\n   // Gram-Schmidt orthogonalize\n\n   outTangent[a] = normalized(t - n * dot(n, t));\n\n   // Calculate handedness\n   //tangent[a].w = (dot(cross(n, t), tan2[a]) < 0.0F) ? -1.0F : 1.0F;\n  }\n\n  wasmGraphics_ReleaseMem(tan1);\n }\n\n u32 StrLen(const char* str) {\n  if (str == 0) {\n   return 0;\n  }\n\n  const char *s = str;\n  while (*s) {\n   ++s;\n  }\n  return (s - str);\n }\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void FinishLoadingText(const char* path, OnTextFileLoaded triggerThisCallback, void* withThisData, u32 whichHasThisManyBytes) {\n TextFile* result = (TextFile*)wasmGraphics_AllocateMem(sizeof(TextFile));\n result->length = whichHasThisManyBytes;\n result->text = (char*)withThisData;\n triggerThisCallback(path, result);\n}\n\nextern \"C\" void wasmFileLoaderLoadText(const char* path, int len, OnTextFileLoaded callback);\n\nvoid LoadText(const char* path, OnTextFileLoaded onTextLoad) {\n u32 path_len = Internal::StrLen(path);\n\n // Here we pass the path to load, and the callback to eventually call back to js.\n // js will stash that pointer, and load the file. When the file is loaded, \n // FinishLoadingText will be called. onTextLoad will be it's first argument,\n // It will allocate the proper data to turn the rest of its arguments into a text file.\n\n wasmFileLoaderLoadText(path, path_len, onTextLoad);\n}\n\nvoid ReleaseText(TextFile* file) {\n wasmGraphics_ReleaseMem(file->text);\n wasmGraphics_ReleaseMem(file);\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void FinishLoadingMesh(const char* path, OnMeshLoaded triggerThisCallback, void* withThisData, u32 whichHasThisManyBytes) {\n unsigned int* uint_data = (unsigned int*)withThisData;\n unsigned int sizes[3];\n sizes[0] = uint_data[0];\n sizes[1] = uint_data[1];\n sizes[2] = uint_data[2];\n\n unsigned int mem_needed = sizeof(MeshFile)\n  + sizeof(float) * 3 * sizes[0]; // tan\n\n void* mem = wasmGraphics_AllocateMem(mem_needed + 1);\n unsigned char* iter = (unsigned char* )mem;\n\n MeshFile* result = (MeshFile*)iter;\n iter += sizeof(MeshFile);\n\n float* pos = (float*)(uint_data + 3);\n float* nrm = pos + sizes[0] * 3;\n float* tex = nrm + sizes[1] * 3;\n\n result->tan = (float*)iter;\n Internal::CalculateTangentArray(sizes[0], (vec3*)pos, (vec3*)nrm, (vec2*)tex, (vec3*)result->tan);\n\n result->numTan = sizes[0];\n result->numPos = sizes[0];\n result->numNrm = sizes[1];\n result->numTex = sizes[2];\n result->pos = pos;\n result->nrm = nrm;\n result->tex = tex;\n\n triggerThisCallback(path, result);\n}\n\nextern \"C\" void wasmFileLoaderLoadMesh(const char* path, int len, OnMeshLoaded callback);\n\nvoid LoadMesh(const char* path, OnMeshLoaded onMeshLoad) {\n u32 path_len = Internal::StrLen(path);\n\n wasmFileLoaderLoadMesh(path, path_len, onMeshLoad);\n}\n\nvoid ReleaseMesh(MeshFile* file) {\n wasmGraphics_ReleaseMem(file);\n}\n\nextern \"C\" void wasmFileLoaderLoadTexture(const char* path, int len, OnTextureLoaded callback);\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void FinishLoadingTexture(const char* path, OnTextureLoaded triggerThisCallback, void* withThisData, u32 whichHasThisManyBytes) {\n unsigned int* uint_data = (unsigned int*)withThisData;\n unsigned int sizes[3];\n sizes[0] = uint_data[0];\n sizes[1] = uint_data[1];\n sizes[2] = uint_data[2];\n\n unsigned int mem_needed = sizeof(TextureFile);\n TextureFile* result = (TextureFile*)wasmGraphics_AllocateMem(mem_needed);\n\n result->width = sizes[0];\n result->height = sizes[1];\n result->channels = sizes[2];\n result->data = (unsigned char*)(uint_data + 3);\n\n triggerThisCallback(path, result);\n}\n\nvoid LoadTexture(const char* path, OnTextureLoaded onTextureLoad) {\n u32 path_len = Internal::StrLen(path);\n\n wasmFileLoaderLoadTexture(path, path_len, onTextureLoad);\n}\n\nvoid ReleaseTexture(TextureFile* file) {\n Graphics::Internal::Assert(file->data != 0, \"On line: \" \"176\" \", in file: \" \"./FileLoadersWASM.cpp\", \"Can't free null pointer\");\n unsigned int* uint_data = ((unsigned int*)file->data) - 3;\n Graphics::Internal::Assert(uint_data[0] == file->width, \"On line: \" \"178\" \", in file: \" \"./FileLoadersWASM.cpp\", \"Bad width\");\n Graphics::Internal::Assert(uint_data[1] == file->height, \"On line: \" \"179\" \", in file: \" \"./FileLoadersWASM.cpp\", \"Bad height\");\n Graphics::Internal::Assert(uint_data[2] == file->channels, \"On line: \" \"180\" \", in file: \" \"./FileLoadersWASM.cpp\", \"Bad channel count\");\n wasmGraphics_ReleaseMem(uint_data);\n wasmGraphics_ReleaseMem(file);\n}\n\n\n\n\n\n\nGraphics::Index gLightmapMVP;\n\nGraphics::FrameBuffer* gLightmapFBO;\nGraphics::Texture* gLightmapDepth;\nGraphics::Texture* gLightmapColor;\n\nGraphics::Shader* gLightmapDrawShader;\nGraphics::Shader* gLightmapBlitShader;\nGraphics::Index gLightmapFboAttachment;\nGraphics::VertexLayout* gLightmapMesh;\nGraphics::VertexLayout* gLightmapSkullLayout;\nGraphics::VertexLayout* gLightmapPlaneLayout;\n\nGraphics::Shader* gLitShader;\nGraphics::Shader* gLitShaderPCM;\nGraphics::VertexLayout* gLitSkullMesh;\nGraphics::VertexLayout* gLitPlaneMesh;\nGraphics::Texture* gPlaneTextureAlbedo;\nGraphics::Texture* gPlaneTextureNormal;\nGraphics::Index gLitModelIndex;\nGraphics::Index gLitShadowIndex;\nGraphics::Index gLitViewIndex;\nGraphics::Index gLitProjectionIndex;\nGraphics::Index gLitAlbedoIndex;\nGraphics::Index gLitLightmapIndex;\nGraphics::Index gLitNormalIndex;\nGraphics::Index gLitLightDirection;\nGraphics::Index gLitLightColor;\nGraphics::Index gLitViewPos;\nGraphics::Index gLitAmbientStrength;\nGraphics::Index gLitAmbientOnly;\n\nGraphics::Shader* gHemiShader;\nGraphics::VertexLayout* gHemiSkullMesh;\nGraphics::Texture* gSkullTextureAlbedo;\nGraphics::Texture* gSkullTextureNormal;\nGraphics::Index gAlbedoIndex;\nGraphics::Index gNormalIndex;\nGraphics::Index gModelIndex;\nGraphics::Index gViewIndex;\nGraphics::Index gHemiTop;\nGraphics::Index gHemiBottom;\nGraphics::Index gProjectionIndex;\nGraphics::Index gLightDirection;\nGraphics::Index gLightColor;\nGraphics::Index gLightAmbientOnly;\nGraphics::Index gViewPos;\n\n\nGraphics::Buffer* gBuffers[10];\n\nbool ShowDepth = true;\nbool IsRunning = true;\nfloat cameraRadius;\nfloat cameraHeight;\nvec3 cameraTarget;\nfloat camTime;\nfloat lightTime;\nfloat lightDir;\nbool enablePCM;\nbool lastPCM;\nfloat ambientOnly;\nGraphics::Shader* gPCMShader;\n\nTextFile* blit_depth_vShader;\nTextFile* blit_depth_fShader;\nTextFile* lightmap_vShader;\nTextFile* lightmap_fShader;\nTextFile* lit_vShader;\nTextFile* lit_fShader;\nTextFile* lit_pcm_fShader;\nTextFile* hemi_vShader;\nTextFile* hemi_fShader;\nMeshFile* skullMesh;\nMeshFile* planeMesh;\nTextureFile* skullNormal;\nTextureFile* planeAlbedo;\nTextureFile* planeNormal;\nTextureFile* skullAlbedo;\nu32 numFilesToLoad;\nbool isFinishedInitializing;\n\nGraphics::Device* globalDevice;\nvoid Initialize(Graphics::Dependencies* platform, Graphics::Device* gfx) {\n IsRunning = true;\n isFinishedInitializing = false;\n enablePCM = true;\n lastPCM = true;\n ambientOnly = 0.0f;\n\n cameraRadius = 7.0f;\n cameraHeight = 3.0f;\n camTime = lightTime = 0.0f;\n lightDir = 1.0f;\n cameraTarget.y = 0.0f;\n\n globalDevice = gfx;\n\n gLightmapFBO = gfx->CreateFrameBuffer();\n gLightmapColor = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, 512, 512);\n gLightmapDepth = gfx->CreateTexture(Graphics::TextureFormat::Depth, 512, 512, 0, Graphics::TextureFormat::Depth, false);\n //gLightmapFBO->AttachColor(*gLightmapColor);\n gLightmapFBO->AttachDepth(*gLightmapDepth);\n Graphics::Internal::Assert(gLightmapFBO->IsValid(), \"On line: \" \"121\" \", in file: \" \"./sample.cpp\", \"Invalid fbo\");\n\n numFilesToLoad = 15;\n LoadText(\"assets/blit-depth.vert\", [](const char* path, TextFile* file) {\n  blit_depth_vShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/blit-depth.frag\", [](const char* path, TextFile* file) {\n  blit_depth_fShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/lightmap.vert\", [](const char* path, TextFile* file) {\n  lightmap_vShader = file;\n  Graphics::Internal::Assert(lightmap_vShader->length != 0, \"On line: \" \"136\" \", in file: \" \"./sample.cpp\", \"Empty lightmap.vert\");\n  Graphics::Internal::Assert(lightmap_vShader->text != 0, \"On line: \" \"137\" \", in file: \" \"./sample.cpp\", \"No text pointer in lightmap.vert\");\n  Graphics::Internal::Assert(*lightmap_vShader->text != 0, \"On line: \" \"138\" \", in file: \" \"./sample.cpp\", \"Empty string in lightmap.vert\");\n  //GraphicsAssert(*lightmap_vShader->text == 0, file->text );\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/lightmap.frag\", [](const char* path, TextFile* file) {\n  lightmap_fShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/lit.vert\", [](const char* path, TextFile* file) {\n  lit_vShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/lit.frag\", [](const char* path, TextFile* file) {\n  lit_fShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/lit-pcm.frag\", [](const char* path, TextFile* file) {\n  lit_pcm_fShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/hemi.vert\", [](const char* path, TextFile* file) {\n  hemi_vShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadText(\"assets/hemi.frag\", [](const char* path, TextFile* file) {\n  hemi_fShader = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadMesh(\"assets/skull.mesh\", [](const char* path, MeshFile* file) {\n  skullMesh = file;\n  numFilesToLoad -= 1;\n  });\n LoadMesh(\"assets/plane.mesh\", [](const char* path, MeshFile* file) {\n  planeMesh = file;\n  numFilesToLoad -= 1;\n  });\n LoadTexture(\"assets/Skull_Normal.texture\", [](const char* path, TextureFile* file) {\n  skullNormal = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadTexture(\"assets/Plane_AlbedoSpec.texture\", [](const char* path, TextureFile* file) {\n  planeAlbedo = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadTexture(\"assets/Plane_Normal.texture\", [](const char* path, TextureFile* file) {\n  planeNormal = file;\n  numFilesToLoad -= 1;\n\n  });\n LoadTexture(\"assets/Skull_AlbedoSpec.texture\", [](const char* path, TextureFile* file) {\n  skullAlbedo = file;\n  numFilesToLoad -= 1;\n\n  });\n}\n\nvoid FinishInitializing(Graphics::Device* gfx) {\n Graphics::Internal::Assert(lightmap_vShader->length != 0, \"On line: \" \"204\" \", in file: \" \"./sample.cpp\", \"2c Empty lightmap.vert\");\n Graphics::Internal::Assert(lightmap_vShader->text != 0, \"On line: \" \"205\" \", in file: \" \"./sample.cpp\", \"2 No text pointer in lightmap.vert\");\n Graphics::Internal::Assert(*lightmap_vShader->text != 0, \"On line: \" \"206\" \", in file: \" \"./sample.cpp\", \"2 Empty string in lightmap.vert\");\n gLightmapDrawShader = gfx->CreateShader(lightmap_vShader->text, lightmap_fShader->text);\n ReleaseText(lightmap_vShader);\n ReleaseText(lightmap_fShader);\n\n gLightmapBlitShader = gfx->CreateShader(blit_depth_vShader->text, blit_depth_fShader->text);\n ReleaseText(blit_depth_vShader);\n ReleaseText(blit_depth_fShader);\n gLightmapFboAttachment = gLightmapBlitShader->GetUniform(\"fboAttachment\");\n\n gLightmapSkullLayout = gfx->CreateVertexLayout();\n Graphics::Index lightmapPositionAttrib = gLightmapDrawShader->GetAttribute(\"position\");\n\n\n gLightmapPlaneLayout = gfx->CreateVertexLayout();\n\n float quadVertices[] = {\n  // positions        // texture Coords\n  -1.0f, 1.0f, 0.0f, 0.0f, 1.0f,\n  -1.0f, -1.0f, 0.0f, 0.0f, 0.0f,\n   1.0f, 1.0f, 0.0f, 1.0f, 1.0f,\n   1.0f, -1.0f, 0.0f, 1.0f, 0.0f,\n };\n Graphics::Buffer* lightmapMesh = gfx->CreateBuffer(quadVertices, sizeof(float) * 20);\n Graphics::BufferView lightmapMeshPos(3, sizeof(float) * 5, Graphics::BufferType::Float32, 0);\n Graphics::BufferView lightmapMeshTex(2, sizeof(float) * 5, Graphics::BufferType::Float32, sizeof(float) * 3);\n Graphics::Index lightmapPosIndex = gLightmapBlitShader->GetAttribute(\"position\");\n Graphics::Index lightmapTexIndex = gLightmapBlitShader->GetAttribute(\"texCoords\");\n gLightmapMesh = gfx->CreateVertexLayout();\n gLightmapMesh->Set(lightmapPosIndex, *lightmapMesh, lightmapMeshPos);\n gLightmapMesh->Set(lightmapTexIndex, *lightmapMesh, lightmapMeshTex);\n gLightmapMesh->SetUserData(4);\n gBuffers[9] = lightmapMesh;\n\n /// Lit shader\n\n gLitShader = gfx->CreateShader(lit_vShader->text, lit_fShader->text);\n ReleaseText(lit_fShader);\n\n gLitShaderPCM = gfx->CreateShader(lit_vShader->text, lit_pcm_fShader->text);\n gPCMShader = gLitShaderPCM;\n ReleaseText(lit_vShader);\n ReleaseText(lit_pcm_fShader);\n\n gLitModelIndex = gLitShader->GetUniform(\"model\");\n gLitShadowIndex = gLitShader->GetUniform(\"shadow\");\n gLitViewIndex = gLitShader->GetUniform(\"view\");\n gLitProjectionIndex = gLitShader->GetUniform(\"projection\");\n gLitAlbedoIndex = gLitShader->GetUniform(\"uColorSpec\");\n gLitLightmapIndex = gLitShader->GetUniform(\"uShadowMap\");\n\n gLitNormalIndex = gLitShader->GetUniform(\"uNormal\");\n gLitLightDirection = gLitShader->GetUniform(\"LightDirection\");\n gLitLightColor = gLitShader->GetUniform(\"LightColor\");\n gLitViewPos = gLitShader->GetUniform(\"ViewPos\");\n gLitAmbientStrength = gLitShader->GetUniform(\"AmbientStrength\");\n gLitAmbientOnly = gLitShader->GetUniform(\"AmbientOnly\");\n\n /// Initialize skull\n\n gHemiShader = gfx->CreateShader(hemi_vShader->text, hemi_fShader->text);\n ReleaseText(hemi_vShader);\n ReleaseText(hemi_fShader);\n\n Graphics::Buffer* positions = gfx->CreateBuffer(skullMesh->pos, sizeof(float) * 3 * skullMesh->numPos);\n Graphics::Buffer* texCoords = gfx->CreateBuffer(skullMesh->tex, sizeof(float) * 2 * skullMesh->numTex);\n Graphics::Buffer* normals = gfx->CreateBuffer(skullMesh->nrm, sizeof(float) * 3 * skullMesh->numNrm);\n Graphics::Buffer* tangents = gfx->CreateBuffer(skullMesh->tan, sizeof(float) * 3 * skullMesh->numTan);\n gBuffers[0] = positions;\n gBuffers[1] = texCoords;\n gBuffers[2] = normals;\n gBuffers[3] = tangents;\n\n Graphics::Index attribPos = gHemiShader->GetAttribute(\"aPos\");\n Graphics::Index attribUv = gHemiShader->GetAttribute(\"aTexCoord\");\n Graphics::Index attribNorm = gHemiShader->GetAttribute(\"aNorm\");\n Graphics::Index attribTan = gHemiShader->GetAttribute(\"aTan\");\n\n Graphics::BufferView posView(3, 0, Graphics::BufferType::Float32, 0);\n Graphics::BufferView normView(3, 0, Graphics::BufferType::Float32, 0);\n Graphics::BufferView tanView(3, 0, Graphics::BufferType::Float32, 0);\n Graphics::BufferView texView(2, 0, Graphics::BufferType::Float32, 0);\n\n gHemiSkullMesh = gfx->CreateVertexLayout();\n gHemiSkullMesh->Set(attribPos, *positions, posView);\n gHemiSkullMesh->Set(attribNorm, *normals, normView);\n gHemiSkullMesh->Set(attribTan, *tangents, tanView);\n gHemiSkullMesh->Set(attribUv, *texCoords, texView);\n gHemiSkullMesh->SetUserData(skullMesh->numPos);\n\n gLightmapSkullLayout->Set(lightmapPositionAttrib, *positions, posView);\n gLightmapSkullLayout->SetUserData(skullMesh->numPos);\n\n positions = gfx->CreateBuffer(planeMesh->pos, sizeof(float) * 3 * planeMesh->numPos);\n texCoords = gfx->CreateBuffer(planeMesh->tex, sizeof(float) * 2 * planeMesh->numTex);\n normals = gfx->CreateBuffer(planeMesh->nrm, sizeof(float) * 3 * planeMesh->numNrm);\n tangents = gfx->CreateBuffer(planeMesh->tan, sizeof(float) * 3 * planeMesh->numTan);\n\n gBuffers[4] = positions;\n gBuffers[5] = texCoords;\n gBuffers[6] = normals;\n gBuffers[7] = tangents;\n\n gLitPlaneMesh = gfx->CreateVertexLayout();\n gLitPlaneMesh->Set(attribPos, *positions, posView);\n gLitPlaneMesh->Set(attribNorm, *normals, normView);\n gLitPlaneMesh->Set(attribTan, *tangents, tanView);\n gLitPlaneMesh->Set(attribUv, *texCoords, texView);\n gLitPlaneMesh->SetUserData(planeMesh->numPos);\n\n gLightmapPlaneLayout->Set(lightmapPositionAttrib, *positions, posView);\n gLightmapPlaneLayout->SetUserData(planeMesh->numPos);\n\n { // Build composite mesh for comparison\n  u32 bytesNeeded = skullMesh->numPos * sizeof(float) * 3 + skullMesh->numNrm * sizeof(float) * 3 + skullMesh->numTex * 2 * sizeof(float) + skullMesh->numTan * 3 * sizeof(float);\n  float* float_arr = (float*)gfx->Allocate(bytesNeeded);\n  u32 arr_size = 0;\n\n  for (u32 i = 0; i < skullMesh->numPos; ++i) {\n   float_arr[arr_size++] = skullMesh->pos[i * 3 + 0];\n   float_arr[arr_size++] = skullMesh->pos[i * 3 + 1];\n   float_arr[arr_size++] = skullMesh->pos[i * 3 + 2];\n\n   float_arr[arr_size++] = skullMesh->nrm[i * 3 + 0];\n   float_arr[arr_size++] = skullMesh->nrm[i * 3 + 1];\n   float_arr[arr_size++] = skullMesh->nrm[i * 3 + 2];\n\n   float_arr[arr_size++] = skullMesh->tan[i * 3 + 0];\n   float_arr[arr_size++] = skullMesh->tan[i * 3 + 1];\n   float_arr[arr_size++] = skullMesh->tan[i * 3 + 2];\n\n   float_arr[arr_size++] = skullMesh->tex[i * 2 + 0];\n   float_arr[arr_size++] = skullMesh->tex[i * 2 + 1];\n  }\n\n  posView = Graphics::BufferView(3, sizeof(float) * 11, Graphics::BufferType::Float32, 0);\n  normView = Graphics::BufferView(3, sizeof(float) * 11, Graphics::BufferType::Float32, sizeof(float) * 3);\n  tanView = Graphics::BufferView(3, sizeof(float) * 11, Graphics::BufferType::Float32, sizeof(float) * 6);\n  texView = Graphics::BufferView(2, sizeof(float) * 11, Graphics::BufferType::Float32, sizeof(float) * 9);\n\n  attribPos = gLitShader->GetAttribute(\"aPos\");\n  attribUv = gLitShader->GetAttribute(\"aTexCoord\");\n  attribNorm = gLitShader->GetAttribute(\"aNorm\");\n  attribTan = gLitShader->GetAttribute(\"aTan\");\n\n  gLitSkullMesh = gfx->CreateVertexLayout();\n  Graphics::Buffer* compositeBuff = gfx->CreateBuffer(float_arr, arr_size * sizeof(float));\n  gLitSkullMesh->Set(attribPos, *compositeBuff, posView);\n  gLitSkullMesh->Set(attribNorm, *compositeBuff, normView);\n  gLitSkullMesh->Set(attribTan, *compositeBuff, tanView);\n  gLitSkullMesh->Set(attribUv, *compositeBuff, texView);\n  gLitSkullMesh->SetUserData(skullMesh->numPos);\n  gBuffers[8] = compositeBuff;\n\n\n  gfx->Release(float_arr);\n }\n ReleaseMesh(skullMesh);\n ReleaseMesh(planeMesh);\n\n gAlbedoIndex = gHemiShader->GetUniform(\"uColorSpec\");\n gNormalIndex = gHemiShader->GetUniform(\"uNormal\");\n gModelIndex = gHemiShader->GetUniform(\"model\");\n gViewIndex = gHemiShader->GetUniform(\"view\");\n gHemiTop = gHemiShader->GetUniform(\"HemiTop\");\n gHemiBottom = gHemiShader->GetUniform(\"HemiBottom\");\n gProjectionIndex = gHemiShader->GetUniform(\"projection\");\n\n gLightDirection = gHemiShader->GetUniform(\"LightDirection\");\n gLightColor = gHemiShader->GetUniform(\"LightColor\");\n gLightAmbientOnly = gHemiShader->GetUniform(\"AmbientOnly\");\n gViewPos = gHemiShader->GetUniform(\"ViewPos\");\n\n Graphics::TextureFormat format = Graphics::TextureFormat::RGBA8;\n if (skullAlbedo->channels == 3) {\n  format = Graphics::TextureFormat::RGB8;\n }\n gSkullTextureAlbedo = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, skullAlbedo->width, skullAlbedo->height, skullAlbedo->data, format,true);\n ReleaseTexture(skullAlbedo);\n\n format = Graphics::TextureFormat::RGBA8;\n if (skullNormal->channels == 3) {\n  format = Graphics::TextureFormat::RGB8;\n }\n gSkullTextureNormal = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, skullNormal->width, skullNormal->height, skullNormal->data, format, true);\n ReleaseTexture(skullNormal);\n\n format = Graphics::TextureFormat::RGBA8;\n if (planeAlbedo->channels == 3) {\n  format = Graphics::TextureFormat::RGB8;\n }\n gPlaneTextureAlbedo = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, planeAlbedo->width, planeAlbedo->height, planeAlbedo->data, format, true);\n ReleaseTexture(planeAlbedo);\n\n\n format = Graphics::TextureFormat::RGBA8;\n if (planeNormal->channels == 3) {\n  format = Graphics::TextureFormat::RGB8;\n }\n gPlaneTextureNormal = gfx->CreateTexture(Graphics::TextureFormat::RGBA8, planeNormal->width, planeNormal->height, planeNormal->data, format, true);\n ReleaseTexture(planeNormal);\n\n gfx->SetDepthState(true);\n\n gLightmapMVP = gLightmapDrawShader->GetUniform(\"mvp\");\n Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"411\" \", in file: \" \"./sample.cpp\", \"INvalid lightmap mvp?\");\n\n isFinishedInitializing = true;\n}\n\nvoid Update(Graphics::Device* g, float deltaTime) {\n if (!IsRunning) {\n  return;\n }\n\n if (numFilesToLoad != 0) {\n  return;\n }\n\n if (!isFinishedInitializing) {\n  FinishInitializing(g);\n  isFinishedInitializing = true;\n  Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"428\" \", in file: \" \"./sample.cpp\", \"(3) INvalid lightmap mvp?\");\n  return;\n }\n Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"431\" \", in file: \" \"./sample.cpp\", \"(4) INvalid lightmap mvp?\");\n\n if (lastPCM != enablePCM) {\n  gLightmapDepth->SetPCM(enablePCM);\n  if (enablePCM) {\n   gPCMShader = gLitShaderPCM;\n  }\n  else {\n   gPCMShader = gLitShader;\n  }\n  lastPCM = enablePCM;\n }\n\n\n camTime += deltaTime * 0.25f;\n while (camTime >= 360.0f) {\n  camTime -= 360.0f;\n }\n\n lightTime += deltaTime * lightDir;\n if (lightTime > 5.0f) {\n  lightDir *= -1.0f;\n  lightTime = 5.0f;\n }\n else if (lightTime < 0.0f) {\n  lightDir *= -1.0f;\n  lightTime = 0.0f;\n }\n\n\n\n}\n\nvoid Render(Graphics::Device * gfx, int x, int y, int w, int h) {\n if (!IsRunning) {\n  return;\n }\n if (!isFinishedInitializing) {\n  return;\n }\n IsRunning = false;\n\n\n Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"474\" \", in file: \" \"./sample.cpp\", \"(5) INvalid lightmap mvp?\");\n\n float camX = FastSin(camTime) * cameraRadius;\n float camZ = FastCos(camTime) * cameraRadius;\n vec3 cameraPos = vec3(camX, cameraHeight, camZ);\n mat4 view = lookAt(cameraPos, cameraTarget, vec3(0, 1, 0));\n mat4 projection = perspective(45.0f, 800.0f / 600.0f, 0.1f, 1000.0f);\n mat4 model1 = mat4(0.1f, 0.0, 0.0, 0.0,\n  0.0, 0.1f, 0.0, 0.0,\n  0.0, 0.0, 0.1f, 0.0,\n  1.5f, 0.0f, -0.5, 1.0f);\n mat4 model2 = mat4(0.1f, 0.0, 0.0, 0.0,\n  0.0, 0.1f, 0.0, 0.0,\n  0.0, 0.0, 0.1f, 0.0,\n  -0.5f, -1.0f, 1.5, 1.0f);\n mat4 model3 = mat4(2.0f, 0.0, 0.0, 0.0,\n  0.0, 2.0f, 0.0, 0.0,\n  0.0, 0.0, 2.0f, 0.0,\n  0.0f, -1.5, 0.0, 1.0f);\n vec3 lightDir = vec3(0.2, -1.0, -1);\n vec3 lightColor = vec3(1.0, 1.0, 1.0);\n float ambient = 0.2f;\n vec3 HemiTop = vec3(0.3f, 0.3f, 0.3f);\n vec3 HemiBottom = vec3(ambient, ambient, ambient);\n Graphics::Sampler sampler;\n Graphics::Sampler depthSampler;\n\n vec3 lightCameraPosition = cameraTarget - normalized(lightDir) * 10.0f;\n mat4 ShadowView = lookAt(lightCameraPosition, cameraTarget, vec3(0, 1, 0));\n mat4 ShadowProjection = ortho(-7.5, 7.5, -7.5, 7.5, 0.01, 20.0);\n\n mat4 shadowMapAdjustment(\n 0.5f, 0.0f, 0.0f, 0.0f,\n 0.0f, 0.5f, 0.0f, 0.0f,\n 0.0f, 0.0f, 0.5f, 0.0f,\n 0.5f, 0.5f, 0.5f - 0.01f, 1.0f);\n\n { // Draw lightmap\n  gfx->SetRenderTarget(gLightmapFBO);\n  gfx->SetViewport(0, 0, 512, 512);\n  gfx->Clear(1.0f, 1.0f, 1.0f, 1.0f);\n\n  gfx->Bind(gLightmapDrawShader);\n  mat4 mvp = ShadowProjection * ShadowView * model1;\n  Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"518\" \", in file: \" \"./sample.cpp\", \"(2) INvalid lightmap mvp?\");\n  gfx->Bind(gLightmapMVP, Graphics::UniformType::Float16, mvp.v);\n  Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"520\" \", in file: \" \"./sample.cpp\", \"(a) INvalid lightmap mvp?\");\n  gfx->Draw(*gLightmapSkullLayout, Graphics::DrawMode::Triangles, 0, gLightmapSkullLayout->GetUserData());\n\n  mvp = ShadowProjection* ShadowView* model2;\n  Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"524\" \", in file: \" \"./sample.cpp\", \"(b) INvalid lightmap mvp?\");\n  gfx->Bind(gLightmapMVP, Graphics::UniformType::Float16, mvp.v);\n  Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"526\" \", in file: \" \"./sample.cpp\", \"(c) INvalid lightmap mvp?\");\n  gfx->Draw(*gLightmapSkullLayout, Graphics::DrawMode::Triangles, 0, gLightmapSkullLayout->GetUserData());\n\n  mvp = ShadowProjection * ShadowView * model3;\n  Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"530\" \", in file: \" \"./sample.cpp\", \"(d) INvalid lightmap mvp?\");\n  gfx->Bind(gLightmapMVP, Graphics::UniformType::Float16, mvp.v);\n  Graphics::Internal::Assert(gLightmapMVP.valid, \"On line: \" \"532\" \", in file: \" \"./sample.cpp\", \"(e INvalid lightmap mvp?\");\n  //gfx->Draw(*gLightmapPlaneLayout, Graphics::DrawMode::Triangles, 0, gLightmapPlaneLayout->GetUserData());\n\n  gfx->SetRenderTarget(0);\n  gfx->SetViewport(0, 0, 800, 600);\n }\n\n mat4 shadowMatrix1 = shadowMapAdjustment * ShadowProjection * ShadowView * model1;\n mat4 shadowMatrix2 = shadowMapAdjustment * ShadowProjection * ShadowView * model2;\n mat4 shadowMatrix3 = shadowMapAdjustment * ShadowProjection * ShadowView * model3;\n\n\n { // Draw scene\n  gfx->Clear(0.4, 0.5, 0.6, 1.0);\n  gfx->Bind(gHemiShader);\n\n  gfx->Bind(gLightDirection, Graphics::UniformType::Float3, lightDir.v);\n  gfx->Bind(gLightColor, Graphics::UniformType::Float3, lightColor.v);\n  gfx->Bind(gLightAmbientOnly, Graphics::UniformType::Float1, &ambientOnly);\n  gfx->Bind(gViewPos, Graphics::UniformType::Float3, cameraPos.v);\n\n  gfx->Bind(gAlbedoIndex, *gSkullTextureAlbedo, sampler);\n  gfx->Bind(gNormalIndex, *gSkullTextureNormal, sampler);\n  gfx->Bind(gModelIndex, Graphics::UniformType::Float16, model1.v);\n  gfx->Bind(gViewIndex, Graphics::UniformType::Float16, view.v);\n  gfx->Bind(gHemiTop, Graphics::UniformType::Float3, HemiTop.v);\n  gfx->Bind(gHemiBottom, Graphics::UniformType::Float3, HemiBottom.v);\n  gfx->Bind(gProjectionIndex, Graphics::UniformType::Float16, projection.v);\n  gfx->Draw(*gHemiSkullMesh, Graphics::DrawMode::Triangles, 0, gHemiSkullMesh->GetUserData());\n\n  gfx->Bind(gPCMShader);\n\n  gfx->Bind(gLitModelIndex, Graphics::UniformType::Float16, model2.v);\n  gfx->Bind(gLitShadowIndex, Graphics::UniformType::Float16, shadowMatrix2.v);\n  gfx->Bind(gLitViewIndex, Graphics::UniformType::Float16, view.v);\n  gfx->Bind(gLitProjectionIndex, Graphics::UniformType::Float16, projection.v);\n\n  gfx->Bind(gLitAlbedoIndex, *gSkullTextureAlbedo, sampler);\n  gfx->Bind(gLitLightmapIndex, *gLightmapDepth, depthSampler);\n  gfx->Bind(gLitNormalIndex, *gSkullTextureNormal, sampler);\n  gfx->Bind(gLitLightDirection, Graphics::UniformType::Float3, lightDir.v);\n  gfx->Bind(gLitLightColor, Graphics::UniformType::Float3, lightColor.v);\n  gfx->Bind(gLitViewPos, Graphics::UniformType::Float3, cameraPos.v);\n  gfx->Bind(gLitAmbientStrength, Graphics::UniformType::Float1, &ambient);\n  gfx->Bind(gLitAmbientOnly, Graphics::UniformType::Float1, &ambientOnly);\n\n\n  gfx->Draw(*gLitSkullMesh, Graphics::DrawMode::Triangles, 0, gLitSkullMesh->GetUserData());\n\n  ambient = 0.0f;\n  gfx->Bind(gLitModelIndex, Graphics::UniformType::Float16, model3.v);\n  gfx->Bind(gLitShadowIndex, Graphics::UniformType::Float16, shadowMatrix3.v);\n  gfx->Bind(gLitAlbedoIndex, *gPlaneTextureAlbedo, sampler);\n  gfx->Bind(gLitLightmapIndex, *gLightmapDepth, depthSampler);\n  gfx->Bind(gLitNormalIndex, *gPlaneTextureNormal, sampler);\n  gfx->Bind(gLitAmbientStrength, Graphics::UniformType::Float1, &ambient);\n  gfx->Draw(*gLitPlaneMesh, Graphics::DrawMode::Triangles, 0, gLitPlaneMesh->GetUserData());\n }\n\n if (ShowDepth) { // Draw debug\n  gfx->SetViewport(w - 20 - 256, h - 20 - 256, 266, 266);\n  gfx->SetScissorState(true, w - 20 - 256, h - 20 - 256, 266, 266);\n  gfx->Clear(0, 0, 0, 1);\n  gfx->SetScissorState(false);\n  gfx->SetViewport(w - 10 - 5 - 256, h - 10 - 5 - 256, 256, 256);\n\n  gfx->Bind(gLightmapBlitShader);\n  //gfx->Bind(gLightmapFboAttachment, *gLightmapColor, sampler);\n  gfx->Bind(gLightmapFboAttachment, *gLightmapDepth, sampler);\n  gfx->Draw(*gLightmapMesh, Graphics::DrawMode::TriangleStrip, 0, gLightmapMesh->GetUserData());\n  gfx->SetViewport(0, 0, 800, 600);\n }\n}\n\nvoid Shutdown(Graphics::Device* gfx) {\n IsRunning = false;\n\n gfx->SetRenderTarget(0);\n gfx->Bind(0);\n\n for (u32 i = 0; i < 10; ++i) {\n  gfx->Destroy(gBuffers[i]);\n }\n\n gfx->Destroy(gLightmapPlaneLayout);\n gfx->Destroy(gLightmapSkullLayout);\n gfx->Destroy(gLightmapMesh);\n gfx->Destroy(gLightmapFBO);\n gfx->Destroy(gLightmapColor);\n gfx->Destroy(gLightmapDepth);\n gfx->Destroy(gLightmapBlitShader);\n gfx->Destroy(gLightmapDrawShader);\n gfx->Destroy(gLitShader);\n gfx->Destroy(gLitShaderPCM);\n gfx->Destroy(gLitSkullMesh);\n gfx->Destroy(gLitPlaneMesh);\n gfx->Destroy(gPlaneTextureAlbedo);\n gfx->Destroy(gPlaneTextureNormal);\n gfx->Destroy(gHemiShader);\n gfx->Destroy(gHemiSkullMesh);\n gfx->Destroy(gSkullTextureAlbedo);\n gfx->Destroy(gSkullTextureNormal);\n\n Graphics::Shutdown(*gfx);\n gfx = 0;\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void StartSample(Graphics::Device* gfx) {\n    Graphics::Dependencies deps;\n    deps.Request = wasmGraphics_AllocateMem;\n    deps.Release = wasmGraphics_ReleaseMem;\n    Graphics::Internal::Assert(gfx != 0, \"On line: \" \"55\" \", in file: \" \"WasmSample.cpp\", \"Can't have null GFX\");\n    Initialize(&deps, gfx);\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void UpdateSample(Graphics::Device* gfx, float dt) {\n    Update(gfx, dt);\n}\n\n__attribute__ (( visibility( \"default\" ) )) extern \"C\" void RenderSample(Graphics::Device * gfx, int x, int y, int w, int h) {\n    if (isFinishedInitializing) {\n        Render(gfx, x, y, w, h);\n    }\n}\n"],"mappings":"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"}